---
layout: cover
title: go
level: 1
---

Prima di tutto, è essenziale capire il modello astratto che il linguaggio presenta.

Successivamente, si deve apprendere la sintassi concreta. 

Infine, è necessario familiarizzare con le librerie standard e gli idiom comuni della lingua.

---
layout: 
title: 1960
level: 3

---

Negli anni '60, un piccolo team dei Bell Telephone Laboratories scrisse un sistema operativo semplice chiamato UNICS, ispirato al progetto MULTICS, sul minicomputer PDP-7 a cui avevano accesso. Quando decisero di portarlo su un altro sistema, dovettero riscrivere tutto il codice scritto in linguaggio assembly PDP-7.

---
layout: 
title: 1960
level: 3
---

Per semplificare il processo, volevano condividere il maggior numero possibile di codice tra le diverse versioni. Avevano bisogno di un linguaggio sufficientemente a basso livello da consentire a un semplice compilatore (l'unico esistente negli anni '60) di generare codice macchina efficiente, ma che nascondesse la maggior parte dei dettagli irrilevanti della macchina di destinazione. BCPL era simile, ma era troppo complesso in alcune aree e mancava di alcune funzionalità necessarie in altre.

Dennis Ritchie creò il linguaggio di programmazione C come derivato di BCPL e alla fine la maggior parte della versione di UNIX per PDP-11 fu riscritta in esso. Quando UNIX fu portato su VAX, bastò retargettare il compilatore e scrivere una piccola quantità di codice assembly molto a basso livello. La maggior parte del sistema poté essere ricompilata senza modifiche.

---
layout: 
title: 1978
level: 3
---
Dal suo rilascio pubblico nel 1978, C è diventato un linguaggio molto popolare, diventando lo standard de facto per la programmazione a basso livello e trovando impiego anche nello sviluppo di numerose applicazioni.

Il punto di un linguaggio a basso livello è fornire un modello astratto della macchina al programmatore che rifletta strettamente l'architettura delle macchine concrete a cui è destinato. Non esiste un linguaggio a basso livello universale: un linguaggio che rappresenta l'architettura di un PDP-11 non rifletterà accuratamente qualcosa come una moderna GPU o persino un vecchio mainframe B5000. L'attrattiva di C è stata quella di fornire un modello astratto simile a un PDP-11, simile alla maggior parte delle CPU consumer economiche.

---
layout: 
title: 2000
level: 3
---
Negli ultimi anni, questa astrazione è diventata meno simile all'hardware reale. Il modello astratto di C rappresenta un singolo processore e un singolo blocco di memoria. Oggi, persino i telefoni cellulari hanno processori multicore, e un linguaggio di programmazione progettato per sistemi single-processor richiede sforzi significativi per essere utilizzato in modo efficace. È sempre più difficile per un compilatore generare codice macchina da sorgenti C che utilizzino efficientemente le risorse del sistema di destinazione.
---
layout: 
title: 2010
level: 3
---
Nel 2007, Robert Griesemer, Pike e Ken Thompson iniziarono a lavorare su un nuovo linguaggio. Thompson era stato uno degli artefici della creazione di C e Pike ci aveva lavorato in seguito ai Bell Labs, facendo parte del team originale di UNIX che aveva guidato lo sviluppo di C. Lo scopo di Go, il loro nuovo linguaggio, era quello di colmare lo stesso vuoto oggi che C aveva riempito negli anni '80. È un linguaggio a basso livello per lo sviluppo multiprocessore.

---
layout: 
title: 2020
level: 3
---

L'esperienza con C ha insegnato loro che un linguaggio di programmazione di sistemi di successo finisce per essere utilizzato per lo sviluppo di applicazioni, quindi Go incorpora una serie di funzionalità di alto livello, consentendo agli sviluppatori di utilizzarlo per cose come servizi web o applicazioni desktop, nonché per sistemi molto a basso livello.
Sia Pike che Thompson hanno lavorato su Plan 9, un sistema progettato per essere un "miglior UNIX di UNIX". Plan 9 ha dato alla luce il sistema operativo distribuito Inferno. Per Inferno, Pike ha creato il linguaggio di programmazione Limbo. Se hai usato Limbo, troverai molte idee molto simili. Il sistema di moduli, la comunicazione basata su canali, la raccolta di rifiuti, gran parte del sistema di tipi e persino molta della sintassi di Go sono ereditati direttamente da Limbo. L'implementazione di riferimento di Go si basa sul toolchain del compilatore di Plan 9.
Se provieni da C, molte cose in Go ti sembreranno familiari, ma alcune sembreranno strane. Come esempio banale, le dichiarazioni di variabili in Go di solito sembrano scritte al contrario per i programmatori C, anche se se provieni da altri membri della famiglia Algol, come Pascal, queste potrebbero non sembrare così strane. La maggior parte di questi cambiamenti derivano da decenni di esperienza lavorando con C e vedendo modi in cui può essere migliorato.

---
layout: 
title: Perchè GO
level: 3
---

Negli ultimi anni, la scalabilità è diventata molto più importante della pura velocità. La legge di Moore ci dice che il numero di transistor su una CPU può raddoppiare approssimativamente ogni 18 mesi. Per lungo tempo, questo corrispondeva approssimativamente a un raddoppio delle prestazioni per un singolo thread di esecuzione. 

Ora, generalmente significa che si ottengono il doppio dei core.

In passato, bastava aspettare sei mesi e il tuo codice C avrebbe funzionato due volte più velocemente su una nuova macchina. Questo non è più vero. Ora, se vuoi che il tuo codice sia più veloce su nuove macchine, deve essere parallelo.
C è intrinsecamente un linguaggio seriale. 

Diverse librerie, come POSIX threads e OpenMP, consentono di scrivere codice multithread in C, ma è molto difficile scrivere codice che scala bene. 

---
layout: 
title: Perchè GO
level: 3
---

Nel creare DragonFly BSD, Matt Dillon osservò che non aveva senso creare un modello di threading N:M, dove N thread di spazio utente vengono multiplexati su M thread kernel, perché il codice C che utilizza più di alcuni thread è molto raro.

Go, al contrario, è stato progettato con la concorrenza in mente. Se scrivi Go in modo idiomatico, scriverai codice che, concettualmente, svolge molte attività in parallelo. 

Il compilatore e l'ambiente di runtime possono eseguire facilmente questo codice su un singolo core semplicemente suddividendo il tempo tra le diverse parti. 

Possono anche eseguirlo su una macchina multicore distribuendo i compiti tra diversi thread.

Questo è un vantaggio molto importante.

---
layout: 
title: Perchè GO
level: 3
---
 In passato, ho dovuto scrivere del codice che funzionasse sul mio laptop single-core e che potesse scalare fino a una macchina SGI a 64 processori. 
 
 Farlo in C era molto difficile, ma farlo nello stesso modo in Erlang era banale. 

Lo svantaggio era che Erlang funziona significativamente peggio di C in un singolo thread. Fino a quando non si dispone di un gran numero di core disponibili, la versione C single-thread sarà più veloce della versione concorrente di Erlang.

---
layout: 
title: Perchè GO
level: 3
---
Go combina il meglio di entrambi i mondi. In termini di prestazioni single-thread, è vicino a C, ma incoraggia uno stile di programmazione che scala bene a un gran numero di core. 
È importante ricordare che il numero di core disponibili probabilmente seguirà un modello di crescita geometrico. Attualmente, due otto core sono comuni e le macchine tra qualche anno le vedrai in telefoni cellulari con 64 core e laptop con ancora più core. 
Scrivere codice C che scala a due o anche otto core è piuttosto difficile ma non estremamente complicato. Scrivere codice C che scala a 64 o 256 core è molto impegnativo. 
Con un linguaggio progettato per la concorrenza, è molto più facile.

---
layout: 
title: Pagina 5
level: 3
---
Go mira a fornire un ricco insieme di funzionalità senza complicare eccessivamente il linguaggio. 

Questo in contrasto con C++, dove anche dopo aver lavorato su un'implementazione della libreria standard e un paio di compilatori per il linguaggio, ti trovi ancora periodicamente a dover fare riferimento alle specifiche. 

Go include anche una ricca libreria standard, che rende semplice lo sviluppo di complesse applicazioni web. 

Fornisce diverse astrazioni di livello medio, che offrono un accesso di alto livello alle caratteristiche di basso livello.

---
layout: 
title: Goroutine
level: 3
---
# goroutine

La primitiva fondamentale per la concorrenza in Go è il **goroutine**. Questo è un gioco di parole su coroutine, un metodo di controllo del flusso reso popolare da Simula. 

Un goroutine è simile a una chiamata di funzione che viene completata asincronicamente. 

Concettualmente, viene eseguito in parallelo, ma il linguaggio non definisce come ciò funziona effettivamente in termini di parallelismo reale.

---
layout: 
title: Goroutine
level: 3
---
## Un nuovo thread

Un compilatore Go può avviare un nuovo thread del sistema operativo per ogni goroutine, oppure può utilizzare un singolo thread e usare segnali temporizzati per passare da uno all'altro. 

Il meccanismo di implementazione esatto per i goroutine non è specificato dal linguaggio e potrebbe cambiare nel tempo.
Di per sé, i goroutine non sono molto utili. 

In C puoi creare thread quasi facilmente come in Go puoi creare goroutine, eppure questo non rende facile scrivere codice concorrente in C. La creazione di sottoprogrammi concorrenti (thread, processi figlio o goroutine) è la parte facile del problema. 

---
layout: 
title: Comunicazione tra thread in C
level: 3
---
# Comunicazione tra thread in C
La parte difficile è la comunicazione tra di essi.
C non fornisce primitive per la comunicazione tra thread, perché C non riconosce i thread; sono implementati nelle librerie. 

I thread condividono tutti uno spazio degli indirizzi, quindi è possibile scrivere il proprio codice per comunicare tra di essi, e chiunque abbia scritto codice C concorrente probabilmente lo ha fatto almeno una volta.

---
layout: 
title: Comunicazione tra thread in GO
level: 3
---
# Comunicazione tra thread in GO

Go, al contrario, è progettato per la concorrenza. 

Utilizza una forma del formalismo di C. A. R. Hoare chiamato Communicating Sequential Processes (CSP) per facilitare la comunicazione tra goroutine. 

CSP definisce canali di comunicazione attraverso i quali gli eventi possono essere inviati. 
I programmi Go possono creare canali e usarli per comunicare tra i thread.

---
layout: 
title: Regola per codice concorrente
level: 3
---

Una buona regola generale per il codice concorrente è che la complessità del debug è proporzionale al numero di attività concorrenti moltiplicato per il numero di possibili modi in cui possono interagire. 

Poiché i thread C utilizzano un modello di "condivisione di tutto", il numero di possibili modi in cui possono interagire è molto grande.
Questo è peggiorato dal fatto che è banale per gli errori nel codice che utilizza puntatori significare che due thread C stanno condividendo una struttura dati che non dovrebbero condividere, ad esempio tramite un overflow del buffer o un puntatore non valido. 

---
layout: 
title: Problemi non di Go
level: 3
---

Questi problemi non si manifestano in Go perché 
Go aggiunge una caratteristica a C e ne rimuove un'altra. 
I programmi Go utilizzano la garbage collection, rendendo impossibili i puntatori non validi, e proibisce l'aritmetica dei puntatori, rendendo impossibili la maggior parte delle altre categorie di errori correlati ai puntatori. 

Guarderemo questo argomento in Comprensione del Modello di Memoria.

---
layout: 
title:Il modello di memoria in C
level: 3
---

Il modello di memoria utilizzato nelle prime implementazioni di C era molto semplice. 
Il codice veniva mappato (o copiato) nella parte inferiore dello spazio degli indirizzi. 

Lo spazio heap (memoria dinamica) veniva posizionato appena sopra la parte superiore del programma, e lo stack cresceva verso il basso dalla parte superiore dello spazio degli indirizzi. 

La gestione della memoria a basso livello funzionava utilizzando la chiamata di sistema **brk()** per aggiungere più pagine nella parte superiore del segmento heap e la chiamata **sbrk()** per aggiungere più pagine nella parte inferiore del segmento dello stack.

---
layout: 
title:thread e il modello di memoria in C
level: 3
---

L'introduzione dei thread ha complicato questo scenario. 
Lo stack tradizionale in C doveva essere un blocco continuo di memoria. 
Quando si crea un nuovo thread, è necessario allocare un blocco di memoria sufficientemente grande per la dimensione massima dello stack. 
Tipicamente, ciò equivale a circa 1MB di RAM. 
Questo significa che la creazione di un thread richiede l'allocazione di 1MB di RAM, anche se il thread utilizzerà solo pochi KB di spazio stack. 
Questo è necessario perché il codice C compilato assume di poter allocare più memoria stack spostando il puntatore dello stack. Di solito i sistemi operativi contrassegnano la pagina sotto la parte inferiore dello stack come non accessibile, quindi piccoli stack overflow causeranno un errore di segmentazione.

---
layout: 
title: lo stack e le funzioni GO
level: 3
---

Le funzioni Go sono più intelligenti. Trattano lo stack come una lista concatenata di allocazioni di memoria. 
Se c'è abbastanza spazio nella pagina dello stack corrente per il loro utilizzo, funzionano come le funzioni C; altrimenti richiederanno che lo stack cresca. 
Un goroutine di breve durata non utilizzerà più della prima allocazione di stack di 4KB, quindi è possibile crearne molti senza esaurire lo spazio degli indirizzi, anche su una piattaforma a 32 bit.

---
layout: 
title: I goroutine senza garanzia di concorrenza 
level: 3
---

I goroutine non sono progettati per essere implementati come thread del kernel. Il linguaggio non fornisce garanzie rigide sulla loro concorrenza. Come i thread Java o i processi Erlang, un gran numero di goroutine può essere multiplexato su un numero limitato di thread del kernel. Ciò significa che gli switch di contesto tra goroutine sono spesso più economici rispetto ai thread POSIX.

---
layout: 
title: Compilatori GO
level: 3
---

# Compilatori Go. 
Il compilatore Go più comune è il compilatore ufficiale `gc`, che è incluso nella distribuzione standard di Go. Questo compilatore è sviluppato dal team Go di Google e supporta tutte le piattaforme ufficialmente supportate da Go.

Un altro compilatore noto è `gccgo`, che è una parte del progetto GCC. `gccgo` è un front-end per il compilatore GCC che può essere utilizzato per compilare il codice Go. Questo compilatore può essere utile se hai bisogno di funzionalità specifiche di GCC o se stai lavorando su una piattaforma non supportata dal compilatore `gc`.

Entrambi i compilatori seguono le specifiche del linguaggio Go e dovrebbero essere in grado di compilare qualsiasi codice Go valido. Tuttavia, possono avere differenze in termini di prestazioni e funzionalità extra.

---
layout: 
title: Pagina 9
level: 3
---

L'implementazione di riferimento è `gc`, comunemente conosciuta come 6g, basata sul toolchain del compilatore Plan 9.
I programmi del toolchain Plan 9 sono denominati con un numero che indica l'architettura che mirano a supportare, seguito da una lettera che indica la loro funzione. 
Le tre architetture supportate da Go sono ARM (5), x86-64 (6) e i386 (8). 
Se stai utilizzando ARM, dovresti utilizzare il comando 5g invece di 6g per compilare i programmi Go e 5l invece di 6l per collegarli.

Come alternativa, c'è un front end per la GNU Compiler Collection (GCC) chiamato gccgo. Questo converte il codice Go in una rappresentazione intermedia più o meno simile a quella che GCC utilizza per Fortran, C e C++, e poi lo sottopone alla stessa serie di ottimizzazioni, producendo nuovamente codice nativo.

Attualmente, Gc è probabilmente la scelta migliore, anche se gccgo sta iniziando a produrre codice migliore. È l'implementazione di riferimento di Go, soggetta allo sviluppo più attivo. Tuttavia, ci sono diverse differenze importanti tra loro.

La differenza più evidente è che gccgo utilizza i thread del sistema operativo per implementare le goroutine e non utilizza stack segmentati in tutte le configurazioni. Ciò significa che creare una goroutine è costoso quanto creare un thread in C. Se stai scrivendo codice con un alto grado di parallelismo, questo renderà gccgo molto più lento di 6g. Se il tuo codice utilizza solo poche goroutine e non le crea molto frequentemente, allora il miglior backend di ottimizzazione in GCC potrebbe renderlo più veloce.

Entrambi i compilatori producono eseguibili nativi. Go utilizza lo stesso modello di implementazione di Objective-C: binari nativi e una piccola libreria di runtime che implementa la funzionalità dinamica. Non c'è interpretazione da parte di una macchina virtuale o compilazione JIT. Sarebbe possibile scrivere un ambiente di ricompilazione dinamica per Go, ma le attuali implementazioni sono compilatori statici. Ciò significa che distribuire un'applicazione scritta in Go è semplice come distribuire un'applicazione scritta in qualsiasi altro linguaggio compilato. È necessario includere tutte le librerie che si utilizzano, ma gli utenti non hanno bisogno di un ampio ambiente di runtime, come nel caso del codice .NET, Java o Python, ad esempio.

Poiché Go è un linguaggio relativamente nuovo, è probabile che nel tempo compaiano nuove implementazioni. Ad esempio, attualmente è possibile utilizzare il front end gcc con il generatore di codice LLVM tramite il plugin DragonEgg, e è probabile che compaia a un certo punto un front end nativo di Go per LLVM.

---
layout: 
title: Compilare
level: 3
---

```go
package main
import "fmt"

func main() {
    fmt.Println("Ciao, mondo!")
}

```sh
$ 6g hello.go
$ 6l hello.6
$ ./6.out
Hello World!
$ go run hello.go
Hello World!
```

Se stai utilizzando il compilatore Gc, devi invocare la versione specifica per la tua architettura.
 Se ti trovi su un sistema x86-64, allora sarà 6g. 
 Questo prende una lista di file sorgente Go e produce codice oggetto. 
 Il codice oggetto deve quindi essere collegato per produrre il binario finale.
A prima vista, questo è molto simile a C, dove si esegue prima il compilatore e poi il linker. 
Ci sono diverse differenze, che rendono principalmente Go più facile da compilare.
---

---
layout: 
title: Quando esegui 6g
level: 3
---
Quando esegui 6g, cerca le direttive di importazione e inserisce riferimenti ai pacchetti pertinenti nel codice oggetto. Questo significa che di solito non è necessario specificare alcuna libreria al linker: esso leggerà i pacchetti richiesti dal file di codice oggetto che gli viene dato e li collegherà tutti nell'eseguibile risultante.

Il passaggio di collegamento è necessario per combinare tutti i pacchetti Go che utilizzi, insieme a eventuali librerie C a cui fai riferimento tramite l'interfaccia di funzioni esterne, in un unico eseguibile. 
Il compilatore esegue il collegamento parziale per produrre pacchetti. Il passaggio finale di collegamento è richiesto solo quando si desidera importare tutte le diverse parti di codice e combinarle con il preambolo specifico del sistema che tutti gli eseguibili condividono.

---
layout: 
title: compilatore e il linker
level: 3
---
Il compilatore e il linker generano entrambi nomi di file predefiniti dall'architettura di destinazione. 
Nell'esempio all'inizio di questa sezione, il compilatore 6g genera un file di codice oggetto hello.6. Se usassi 8g invece, e generassi codice x86 a 32 bit, il file risultante sarebbe hello.8 e il linker 8l produrrebbe 8.out invece di 6.out. Questi sono solo i nomi di file di output predefiniti. Puoi utilizzare -o con entrambi gli strumenti per specificare un altro nome di file.
---
layout: 
title: Dettagli nascosti  
level: 3
---
A partire da Go 1.0, tutti i dettagli di questo processo sono generalmente nascosti a te. Il comando go può compilare ed eseguire programmi per te con un singolo passaggio. Basta digitare go run seguito dal nome del file sorgente e farà tutto questo per te. Se specifici il flag -x, puoi vedere esattamente cosa fa questo strumento mentre viene eseguito.
---
layout: 
title: Tipizzazione
level: 3
---


### Tipizzazione di Go

- **Tipizzazione Statica e Accoppiamento Stretto**
  - Go è un linguaggio con tipizzazione statica e stretto accoppiamento tra i componenti.
  - Offre anche tipizzazione dinamica e accoppiamento più lento tra i componenti, consentendo di scegliere la modalità più adatta a ciascun caso d'uso.

- **Tipi Primitivi e Strutture**
  - Go dispone di tipi primitivi simili a quelli di C e strutture simili a quelle di C.
  - Le strutture in Go includono metodi (ammessi su tutti i tipi Go, non solo sulle strutture) ma senza ereditarietà.

- **Interfacce**
  - Le interfacce in Go supportano il duck typing e non richiedono l'adozione esplicita.
  - Qualsiasi tipo che implementa i metodi elencati da un'interfaccia la implementa implicitamente.

- **Tipi di Interfaccia**
  - I tipi di interfaccia possono essere utilizzati come tipi di variabile in Go.
  - Quando si chiama un metodo su una variabile di tipo interfaccia, si utilizza il dispatch dinamico per trovare l'implementazione corretta del metodo.

---
layout: 
title: L'introspezione
level: 3
---  

L'introspezione, nel contesto della programmazione, si riferisce alla capacità di un programma di esaminare il tipo o le proprietà di un oggetto a runtime. 
In altre parole, l'introspezione permette al codice di esaminare se stesso o altri oggetti mentre viene eseguito.

Nel linguaggio di programmazione Go, l'introspezione è comunemente utilizzata con le interfacce. 
Go permette di verificare se un particolare valore implementa un'interfaccia utilizzando un tipo di asserzione o un tipo di switch. 
Questo può essere utile per scrivere codice che può manipolare oggetti di tipi diversi in modi specifici del tipo.

---
layout: 
title: L'introspezione
level: 3
---  

Ad esempio, potresti avere un'interfaccia `Forma` con metodi per calcolare l'area e il perimetro, e diverse strutture (come `Cerchio`, `Rettangolo`, ecc.) che implementano questa interfaccia. 

Utilizzando l'introspezione, potresti scrivere una funzione che prende un valore di tipo `Forma` e si comporta in modo diverso a seconda del tipo concreto del valore.

---
layout: 
title: L'introspezione
level: 3
---  

Sviluppiamo un codice, 
`Forma` è un'interfaccia con due metodi: `Area` e `Perimetro`. 

Con `Cerchio` e `Rettangolo` due strutture che implementano l'interfaccia `Forma`.

Una funzione `StampaDettagli` prende un valore di tipo `Forma` e utilizza un tipo di switch per determinare il tipo concreto del valore. 
A seconda del tipo, stampa dettagli specifici del tipo, seguiti dall'area e dal perimetro della forma.

---
layout: 
title: L'introspezione
level: 3
---  

Implementiamo l'interfaccia `Forma` e utilizzamo l'introspezione per gestire diversi tipi di forme:

```go
package main

import (
	"fmt"
	"math"
)

type Forma interface {
	Area() float64
	Perimetro() float64
}

type Cerchio struct {
	Raggio float64
}

func (c Cerchio) Area() float64 {
	return math.Pi * c.Raggio * c.Raggio
}

func (c Cerchio) Perimetro() float64 {
	return 2 * math.Pi * c.Raggio
}

type Rettangolo struct {
	Larghezza, Altezza float64
}

func (r Rettangolo) Area() float64 {
	return r.Larghezza * r.Altezza
}

func (r Rettangolo) Perimetro() float64 {
	return 2*r.Larghezza + 2*r.Altezza
}

func StampaDettagli(f Forma) {
	switch forma := f.(type) {
	case Cerchio:
		fmt.Println("Cerchio con raggio", forma.Raggio)
	case Rettangolo:
		fmt.Println("Rettangolo con larghezza", forma.Larghezza, "e altezza", forma.Altezza)
	default:
		fmt.Println("Tipo di forma sconosciuto")
	}
	fmt.Println("Area:", f.Area())
	fmt.Println("Perimetro:", f.Perimetro())
}

func main() {
	c := Cerchio{Raggio: 5}
	r := Rettangolo{Larghezza: 3, Altezza: 4}

	StampaDettagli(c)
	StampaDettagli(r)
}
```

---
layout: 
title: L'introspezione
level: 3
---  

L'introspezione può semplificare la scrittura di strutture dati generiche in Go, poiché permette di scrivere codice che può lavorare con valori di qualsiasi tipo, purché implementino una certa interfaccia.

- **Introspezione**
  - Go supporta l'introspezione sui tipi per verificare i tipi di istanze o le implementazioni di interfaccia.
  - Questa caratteristica semplifica la scrittura di strutture dati generiche in Go.

---
layout: 
title: Inferenza di Tipo
level: 3
---

# Inferenza di Tipo

L'inferenza di tipo è una caratteristica di alcuni linguaggi di programmazione che consente al compilatore di dedurre automaticamente il tipo di una espressione senza che sia necessario specificarlo esplicitamente. 

Questo può semplificare la scrittura del codice e rendere il codice più leggibile.

Nel contesto del linguaggio di programmazione Go, l'inferenza di tipo viene utilizzata principalmente nelle dichiarazioni di variabili. 

---
layout: 
title: Inferenza di Tipo in GO
level: 3
---

Se inizializzi una variabile al momento della dichiarazione, non è necessario specificare il suo tipo. 

Il compilatore Go sarà in grado di inferire il tipo della variabile dal valore con cui viene inizializzata.

Ad esempio, considera il seguente codice Go:

```go
var i = 42  // i è un intero
var s = "Ciao, mondo!"  // s è una stringa
```

In questo codice, il compilatore Go inferisce che `i` è un `int` e `s` è una `string` dai valori con cui vengono inizializzate. 
Non è necessario specificare i tipi esplicitamente. 
Questo è un esempio di inferenza di tipo.

---
layout: 
title: Inferenza di Tipo in GO
level: 3
--- 

- **Inferenza di Tipo**
  - Il compilatore Go fornisce l'inferenza di tipo, consentendo ai programmatori pigri di evitare annotazioni esplicite sui tipi nella maggior parte delle dichiarazioni di variabili.
  - Se si combina l'inizializzazione con la dichiarazione, il compilatore inferirà il tipo della variabile dal tipo dell'espressione assegnata ad essa.

---
layout: 
title: Pagina 12
level: 3
---


Contenuti
X
20
Riduzioni e completezza NP.....................324
20.1
La ﬁ capacità di Satis è almeno difficile quanto qualsiasi problema di ottimizzazione
326
20.2
Passaggi per dimostrare la completezza NP
330
20.3
Esempio: 3-color è NP-completo
338
20.4
Un algoritmo per la corrispondenza bipartita utilizzando la rete
Algoritmo di flusso
342
21
Algoritmi randomizzati..........................346
21.1
Usando la casualità per nascondere i casi peggiori
347
21.2
Soluzioni di problemi di ottimizzazione con una struttura casuale
350
Parte quarta.APPENDICE
22
Quantità esistenziali e universali...................357
23
Complessità temporale..............................366
23.1
La complessità del tempo (e dello spazio) di un algoritmo
366
23.2
La complessità temporale di un problema computazionale
371
24
Logaritmi ed esponenziali.......................374
25
Crescita asintotica.............................377
25.1
Passaggi per classificare una funzione
379
25.2
Maggiori informazioni sulla notazione asintotica
384
26
Approssimazioni di aggiunta di fabbriche....................388
26.1
La tecnica
389
26.2
Alcune prove per la tecnica di aggiunta
393
27
Relazioni di ricorrenza............................398
27.1
La tecnica
398
27.2
Alcune prove
401
28
Una prova formale di correttezza.......................408
Parte quinta.Soluzioni di esercizio............................411
Conclusione ....................................437
Indice
439

---
layout: 
title: Pagina 13
level: 3
---


xi
PREFAZIONE
All'educatore e allo studente
Questo libro è progettato per essere utilizzato in un corso di algoritmi del terzo anno di dodici settimane.IL
L'obiettivo è insegnare agli studenti a pensare astrattamente agli algoritmi e alle principali tecniche algoritmiche utilizzate per svilupparli.
Meta-algoritmi: gli studenti devono imparare così tanti algoritmi che a volte sono
sopraffatto.Al fine di facilitare la loro comprensione, la maggior parte dei libri di testo copre il
Temi standard di algoritmi iterativi, ricorsione, algoritmi avidi e dinamici
programmazione.Generalmente, tuttavia, quando si tratta di presentare gli algoritmi stessi e le loro prove di correttezza, i concetti sono nascosti all'interno di ottimizzati
Codice e prove liscia.Un obiettivo di questo libro è presentare una via uniforme e pulita
di pensare agli algoritmi.Lo facciamo concentrandoci sulla struttura e sulla prova di
correttezza dei meta-algoritmi iterativi e ricorsivi, e all'interno di questi gli avidi
e meta-algoritmi di programmazione dinamica.Imparando queste e le loro prove di
Correzione, la maggior parte degli algoritmi effettivi possono essere facilmente compresi.La sfida è quella
Pensare ai meta-algoritmi richiede un grande pensiero astratto.
Pensiero astratto: gli studenti sono molto bravi nell'apprendimento
Come applicare un codice concreto a un'istanza di input concreta.Tendono, tuttavia, a trovarlo difficile pensare
Abstracamente sugli algoritmi.Lo sostengo
più astrazioni una persona ha da cui visualizzare
Il problema, più profondo la sua comprensione sarà, più strumenti avrà a sua disposizione e più preparato sarà quello di progettare il proprio innovativo
Modi per risolvere nuovi problemi.Quindi, presento un numero
di diverse notazioni, analogie e paradigmi all'interno
che sviluppare e pensare agli algoritmi.

---
layout: 
title: Pagina 14
level: 3
---


Prefazione
XII
Modo di pensare: le persone che sviluppano algoritmi hanno vari modi di pensare e
Intuizione che tende a non essere insegnate.L'ipotesi, suppongo, è che questi non possono
essere insegnato ma deve essere fisso da solo.Questo testo tenta di insegnare agli studenti
pensare come un designer di algoritmi.
Non un libro di riferimento: la mia intenzione non è quella di insegnare una selezione specifica di algoritmi
per scopi specifici.Quindi, il libro non è organizzato in base all'applicazione
degli algoritmi, ma secondo le tecniche e le astrazioni utilizzate per sviluppare
loro.
Sviluppo di algoritmi: l'obiettivo non è presentare algoritmi completati in una bella
Pacchetto pulito, ma per attraversare lentamente ogni fase dello sviluppo.Molti falsi
Inizio sono stati aggiunti.La speranza è che ciò aiuti gli studenti a imparare a sviluppare algoritmi da soli.La differenza è un po 'come la differenza tra lo studio
Carpenteria guardando le case e guardando i martelli.
Prova della correttezza: la nostra filosofia non è quella di seguire un algoritmo con un formale
prova che è corretto.Invece, questo testo riguarda l'apprendimento di come pensare, sviluppare e descrivere gli algoritmi in modo tale che la loro correttezza sia trasparente.
Immagine generale contro piccoli passi: per ogni argomento, cerco di dare il quadro generale e
per scomporlo in passi facilmente compresi.
Livello di presentazione: questo materiale è difficile.Non si può aggirare questo.IO
ho cercato di figurare dove potrebbe sorgere confusione e coprire questi punti in più
dettaglio.Cerco di bilanciare la succinta chiarezza che deriva dal formalismo matematico
Contro le analogie e le metafore personalizzate che aiutano a fornire entrambe le intuizioni
e umorismo.
Modulo punto: il testo è organizzato in blocchi, ciascuno contenente un titolo e un singolo
Pensiero.Spero che questo renderà il testo più facile da lezione e da cui studiare.
Prerequisiti: il testo presuppone che gli studenti abbiano completato un primo anno
Corso di programmazione e avere una maturità matematica generale.L'appendice
(Parte quarta) copre gran parte della matematica che sarà necessaria.
Domande sui compiti: sono incluse alcune domande per i compiti.Spero di svilupparmi molti altri, insieme alle loro soluzioni.I contributi sono benvenuti.
Leggi in anticipo: lo studente dovrebbe leggere il materiale prima della lezione.Questo sarà
Facilitare una discussione produttiva durante le lezioni.
Spiegare: per essere in grado di metterti alla prova su un test o sul lavoro, devi essere in grado
per spiegare bene il materiale.Inoltre, spiegarlo a qualcun altro è il modo migliore
per impararlo da solo.Quindi, consiglio vivamente di passare molto tempo a spiegare

---
layout: 
title: Pagina 15
level: 3
---


Prefazione
XIII
il materiale più e più volte è ad alta voce a te stesso, all'altro e al tuo
orso imbottito.
Sognando: vorrei enfatizzare l'importanza di
Pensare, anche sognare ad occhi aperti, sul materiale.Questo
Può essere fatto mentre attraversa la giornata, mentre nuoti, fa la doccia, cucina o sdraiati sul letto.Fare domande.Perché è fatto in questo modo e non in questo modo?Inventare altri algoritmi per risolvere un problema.Quindi guarda
per istanze di input per le quali il tuo algoritmo fornisce il
risposta sbagliata.La matematica non è tutto il pensiero lineare.
Se l'essenza del materiale, ciò che le domande sono veramente porre, è autorizzato a filtrare
giù nel tuo subconscio quindi con il tempo piccoli pensieri inizieranno a percolare
su.Perseguire queste idee.A volte appaiono anche le soffioni di ispirazione.
Riconoscimenti
Vorrei ringraziare Andy Mirzaian, Franck Van Breugel, James Elder, Suprakash
Datta, Eric Ruppert, Russell Impagliazzo, Toniann Pitassi e Kirk Pruhs, con cui
Ho insegnato e co-ricercato algoritmi per molti anni.Vorrei ringraziare Jennifer Wolfe e Lauren Cowles per i loro fantastici lavori di montaggio.Tutte queste persone lo erano
Un enorme supporto per questo lavoro.

---
layout: 
title: Pagina 16
level: 3
---


---
layout: 
title: Pagina 17
level: 3
---


1
introduzione
Dal determinare il modo più economico per fare un hot dog al monitoraggio del funzionamento
Di una fabbrica, ci sono molti problemi computazionali complessi da risolvere.Prima
Il codice eseguibile può essere prodotto, gli informatici devono essere in grado di progettare il
Gli algoritmi che si trovano dietro il codice, essere in grado di comprendere e descrivere tali algoritmi in modo astratto ed essere convinti che funzionano correttamente ed efficienti.Questi sono
Gli obiettivi degli informatici.
Un problema computazionale: una specifica di un problema computazionale utilizza precondizioni e postcondizioni per descrivere per ogni istanza di input legale che il calcolo potrebbe ricevere, quali sono l'output o le azioni richieste.Questa può essere una funzione mappatura di ciascuna istanza di input all'output richiesto.Potrebbe essere un'ottimizzazione
Problema che richiede una soluzione per essere emessa che è "ottimale" da un
Enorme serie di possibili soluzioni per la data istanza di input.Potrebbe anche essere un in corso
Sistema o struttura dei dati che risponde in modo appropriato a un flusso costante di input.
Esempio: il problema di smistamento è definito come segue:
Precondizioni: l'input è un elenco di valori N, comprese possibili ripetizioni.
PostConditions: l'output è un elenco costituito dagli stessi valori N in ordine non aressante.
Un algoritmo: un algoritmo è una procedura passo-passo che, a partire da un'istanza di input, produce un output adatto.È descritto a livello di dettaglio e astrazione più adatti al pubblico umano che deve capirlo.Al contrario, il codice è un'implementazione di un algoritmo che può essere eseguito da un computer.Lo pseudocodice si trova tra questi due.
Un tipo di dati astratto: i computer usano zeri e quelli, e ori, IFS e
Andare a S.Questo non significa che dobbiamo.La descrizione di un algoritmo può
parlare di oggetti astratti come numeri interi, reali, stringhe, set, stack, grafici e alberi;

---
layout: 
title: Pagina 18
level: 3
---


introduzione
2
Operazioni astratte come "Ordina l'elenco", "Pop the Stack" o "Trace A Path";e relazioni astratte come maggiori di, pre -ﬁ x, sottoinsieme, connesso e bambino.Essere
Utile, la natura di questi oggetti e l'effetto di queste operazioni devono essere compresi.Tuttavia, al fine di nascondere i dettagli che sono noiosi o irrilevanti, il preciso
Le implementazioni di queste struttura e algoritmi di dati non devono essere specificate.
Per ulteriori informazioni su questo vedi il capitolo 3.
Correzione: un algoritmo per il problema è corretto se per ogni istanza di input legale, viene prodotto l'output richiesto.Sebbene sia necessario un certo pensiero logico, l'obiettivo di questo testo è insegnare come pensare, sviluppare e descrivere
Algoritmi in modo tale che la loro correttezza sia trasparente.Vedere il capitolo 28 per il
Passaggi formali necessari per dimostrare la correttezza e il capitolo 22 per una discussione di forall
ed esistono dichiarazioni essenziali per fare dichiarazioni formali.
Tempo di esecuzione: non è sufficiente che un calcolo alla fine ottenga il corretto
risposta.Deve anche farlo usando un ragionevole quantità di tempo e spazio di memoria.
Il tempo di esecuzione di un algoritmo è una funzione della dimensione N dell'istanza di input data a un limite al numero di operazioni che il calcolo deve fare.(Vedere
Capitolo 23.) Si dice che l'algoritmo sia fattibile se questa funzione è un polinomio come
Tempo (n) = (n2) e si dice che sia impossibile se questa funzione è un tipo esponenziale
Tempo (n) = (2n).(Vedi i capitoli 24 e 25 per ulteriori informazioni sugli asintotici delle funzioni.)
Per essere in grado di calcolare il tempo di esecuzione, è necessario essere in grado di sommare i tempi
preso in ogni iterazione di un ciclo e per risolvere la relazione di ricorrenza che definisce il
tempo di un programma ricorsivo.(Vedi il capitolo 26 per una comprensione di n
i = 1 i = (n2) e capitolo 27 per una comprensione di t (n) = 2t (n
1) + n = (n logn).)
Meta-algoritmi: la maggior parte degli algoritmi sono meglio descritti come iterativi o
ricorsivo.Un algoritmo iterativo (prima parte) fa un passo alla volta, garantendo questo
Ogni passaggio fa progressi mantenendo l'invariante del loop.Un algoritmo ricorsivo
(Parte due) interrompe la sua istanza in casi più piccoli, che fa risolvere un amico, quindi combina le loro soluzioni in una delle sue.
I problemi di ottimizzazione (parte tre) formano un'importante classe di computazionale
i problemi.Gli algoritmi chiave per loro sono i seguenti.Gli algoritmi avidi (capitolo 16) continuano a afferrare l'oggetto successivo che sembra migliore.Algoritmi di backtracking ricorsivi (capitolo 17) prova le cose e, se non funzionano, backtrack e prova qualcosa
altro.La programmazione dinamica (capitolo 18) risolve una sequenza di istanze sempre più grandi, riutilizzando le soluzioni precedentemente salvate per le istanze più piccole, fino a quando non viene ottenuta una soluzione per la data istanza.Riduzioni (capitolo 20) Utilizzare un algoritmo per
Un problema per risolverne un altro.Algoritmi randomizzati (capitolo 21) monete di flusso per aiutare
decidono quali azioni intraprendere.Infine, i limiti inferiori (capitolo 7) dimostrano che lì
non sono algoritmi più veloci.

---
layout: 
title: Pagina 19
level: 3
---


PRIMA PARTE
Algoritmi iterativi e
Invarianti ad anello

---
layout: 
title: Pagina 20
level: 3
---


---
layout: 
title: Pagina 21
level: 3
---


5
1 algoritmi iterativi: misure di
Progressi e invarianti ad anello
L'uso di un algoritmo iterativo per risolvere un problema computazionale è un po 'come seguire una strada, possibilmente
lungo e difficile, dalla tua posizione iniziale al tuo
destinazione.Con ogni iterazione, hai un metodo
Questo ti ci vuole un solo passo.Per assicurarti che tu
Vai avanti, devi avere una misura di progresso
Dicendoti fino a che punto sei dal tuo inizio
posizione o dalla tua destinazione.Non puoi aspettarti
per sapere esattamente dove andrà l'algoritmo, così tu
Devo aspettarsi un po 'di tessitura e avvolgimento.Sul
Altro mano, non vuoi sapere come
per gestire ogni fossato e vicolo cieco del mondo.
Un compromesso tra questi due è avere un ciclo
invariante, che definisce una strada (o regione) che tu
potrebbe non andarsene.Mentre viaggi, preoccuparsi di un passo
Al tempo.Devi sapere come salire sulla strada da qualsiasi posizione iniziale.Da
Ogni luogo lungo la strada, devi sapere quali azioni intraprenderai per
Fai un passo avanti senza lasciare la strada.Infine, quando sono stati sufficienti progressi
Realizzato lungo la strada, devi sapere come uscire e raggiungere la tua destinazione in un
ragionevole quantità di tempo.
1.1
Un turno di paradigma: una sequenza di azioni rispetto a una sequenza
di affermazioni
Comprendere gli algoritmi iterativi richiede la comprensione della differenza tra
un loop invariante, che è un'affermazione o un'immagine del calcolo in un particolare
punto nel tempo e le azioni necessarie per mantenere un tale loop invariante.
Quindi, inizieremo con il tentativo di capire questa differenza.

---
layout: 
title: Pagina 22
level: 3
---


Algoritmi iterativi e invarianti ad anello
6
Max (a,
B,
C)
Prend: l'input ha 3 numeri.
m = a
Assert: m è massimo in {a}.
if (b> m)
m = b
finisci se
Assert: m è massimo in {a, b}.
if (c> m)
m = c
finisci se
Assert: m è massimo in {a, b, c}.
restituzione (m)
Postcond: return max in {a, b, c}.
Algoritmo di fine
Uno dei primi cambiamenti di paradigma
che i programmatori lottano per fare proviene
visualizzare un algoritmo come una sequenza di azioni a
Visualizzandolo come una sequenza di istantanee dello stato
del computer.I programmatori tendono a fissare
Sul primo punto di vista, perché il codice è una sequenza di
istruzioni per l'azione e un calcolo è un
sequenza di azioni.Sebbene questa sia una visione importante, ce n'è un'altra.Immagina di fermarti
tempo in punti chiave durante il calcolo e
scattare foto dello stato del computer.
Quindi un calcolo può essere ugualmente visto come
una sequenza di tali istantanee.Avere due modi
di visualizzare la stessa cosa dà uno di più
strumenti per gestirlo e una comprensione più profonda di
Esso.Un esempio di visualizzazione di un calcolo come un
alterazione tra asserzioni sulla corrente
stato del calcolo e blocchi di azioni
che porta lo stato del calcolo al
Il prossimo stato è mostrato qui.
La sfida della vista della sequenza delle azioni: supponiamo che si stia progettando a
Nuovo algoritmo o spiegare un algoritmo a un amico.Se uno ci sta pensando come una sequenza di azioni, probabilmente inizierà dall'inizio: fallo.Fai quello.Fare
Questo.A poco a poco si può perdersi e non sapere dove si trova.Per gestire questo, contemporaneamente deve tenere traccia di come lo stato del computer cambia con ogni nuovo
azione.Per sapere quale azione prendere il prossimo, è necessario avere un piano globale di
dove deve andare il calcolo.A peggiorare le cose, il calcolo ha molti IF e
Loops Quindi si devono considerare tutti i vari percorsi che il calcolo può intraprendere.
I vantaggi della sequenza della vista delle istantanee: questo nuovo paradigma è
utile da cui si può pensare, spiegare o sviluppare un algoritmo.
Pre e postcondizioni: prima che si possa considerare un algoritmo, è necessario definire attentamente il problema computazionale da esso.Questo è fatto con pre-e
Postconditions fornendo l'immagine iniziale o l'affermazione sull'istanza di input
e un'immagine o un'affermazione corrispondente sull'output richiesto.
Inizia nel mezzo: invece di iniziare con la prima riga di codice, un modo alternativo
Progettare un algoritmo è saltare nel mezzo del calcolo e disegnare
Un quadro statico o un'affermazione sullo stato che vorremmo che il calcolo fosse
In questo momento.Questa immagine non ha bisogno di indicare il valore esatto di ciascuna variabile.

---
layout: 
title: Pagina 23
level: 3
---


Misure di progresso e invarianti ad anello
7
Invece, fornisce proprietà generali e relazioni tra le varie strutture di dati che sono fondamentali per comprendere l'algoritmo.Se questa affermazione è sufficientemente generale, catturerà non solo questo punto durante il calcolo, ma molti simili
punti.Quindi potrebbe diventare parte di un ciclo.
Sequenza di istantanee: una volta che si crea una sequenza di asserzioni in questo modo, si può vedere l'intero percorso del calcolo stabilito davanti a uno.
Compila le azioni: queste affermazioni sono solo istantanee statiche del calcolo
con il tempo fermato.Nessuna azione è stata ancora considerata.Il passo finale è riempire
Azioni (codice) tra asserzioni consecutive.
Un passo alla volta: ogni blocco di azioni di questo tipo può essere eseguito completamente indipendentemente dagli altri.È molto più facile considerarli uno alla volta che
Preoccupati per l'intero calcolo contemporaneamente.In effetti, si possono completare questi blocchi
In ogni ordine si desidera e modificare un blocco senza preoccuparsi dell'effetto su
gli altri.
Vola da Marte: ecco come dovresti riempire nel codice tra ith e il
I + 1 ° affermazione.Supponiamo di avere solo flusso da Marte e assolutamente l'unico
cosa che sai sullo stato attuale del tuo calcolo è che l'affermazione
tiene.Il calcolo potrebbe effettivamente essere in uno stato completamente impossibile
Arrivo, dato l'algoritmo che è stato progettato finora.Sta permettendo questo
Fornisce l'indipendenza tra questi blocchi di azioni.
Fai un passo: essere in uno stato in cui è valida l'affermazione, il tuo compito è semplicemente
Per scrivere un codice semplice per fare alcune semplici azioni, che cambiano lo stato del
Calcolo in modo che l'affermazione I + 1 ° valga.
Prova della correttezza di ogni passaggio: la prova che il tuo algoritmo funziona anche
essere fatto un blocco alla volta.Devi dimostrare che se il tempo viene fermato e lo stato di
Il calcolo è tale che l'affermazione è valida e ti ricomincia a lungo
abbastanza per eseguire il blocco successivo di codice, quindi quando si ferma il tempo lo stato di
Il calcolo sarà tale che vale l'asserzione I + 1 °.Questa prova potrebbe essere
una prova matematica formale, o potrebbe essere la mano di mano informale.Ad ogni modo, il
La dichiarazione formale di ciò che deve essere dimostrato è la seguente:
⟨Ith -assertion⟩ & codei ⇒⟨i + 1st -assertion⟩
Prova della correttezza dell'algoritmo: tutti questi singoli passaggi possono essere messi
insieme in un intero algoritmo di lavoro.Supponiamo che l'istanza di input fornita
incontra il presupposto.Ad un certo punto, abbiamo dimostrato che se la presuppunzione contiene e
Viene eseguito il primo blocco di codice, quindi lo stato del calcolo sarà tale

---
layout: 
title: Pagina 24
level: 3
---


Algoritmi iterativi e invarianti ad anello
8
Tale affermazione detiene.Ad un altro punto, abbiamo dimostrato che se la prima affermazione
Holds e il secondo blocco di codice viene eseguito quindi lo stato del calcolo
sarà tale che la seconda affermazione detiene.Questo è stato fatto per ogni blocco.Tutti questi
Dichiarazioni dimostrate indipendentemente possono essere messe insieme per dimostrare che se inizialmente il
L'istanza di input soddisfa la presupposizione e l'intero codice viene eseguito, quindi in
Termina lo stato del calcolo sarà tale che la postconditazione è stata soddisfatta.
Questo è ciò che è necessario per dimostrare che l'algoritmo funziona.
1.2
I passaggi per sviluppare un algoritmo iterativo
Algoritmi iterativi: un buon modo per strutturare molti programmi per computer è archiviare
le informazioni chiave che si conosci attualmente in alcune struttura dei dati e poi ne hai ciascuno
iterazione del ciclo principale fai un passo verso la tua destinazione creando un semplice
cambiare a questi dati.
Loop Invariant: un loop invariante esprime importanti relazioni tra i
Variabili che devono essere vere all'inizio di ogni iterazione e quando il ciclo termina.Se è vero, il calcolo è ancora sulla strada.Se è falso, allora il
L'algoritmo è fallito.
La struttura del codice: la struttura di base del codice è la seguente.
Inizia la routine
⟨Pre-Cond⟩
CodePre-Loop
% Stabilisci il ciclo invariante
ciclo continuo
⟨Loop-invariante⟩
uscita quando ⟨exit-cond⟩
Codeloop
% Fa progressi mantenendo l'invariante in loop
End Loop
codepost-loop
% Pulire le estremità sciolte
⟨Post-Cond⟩
routine di fine
Prova della correttezza: naturalmente, vuoi essere sicuro che il tuo algoritmo funzioni
Tutti gli ingressi specificati e danno la risposta corretta.
Tempo di esecuzione: vuoi anche essere sicuro che il tuo algoritmo sia completato in un ragionevole periodo di tempo.
I passaggi più importanti: se è necessario progettare un algoritmo, non iniziare digitando il codice senza sapere davvero come o perché l'algoritmo funziona.Invece, consiglio prima di svolgere i seguenti compiti.Vedi Figura 1.1.Questi compiti devono adattarsi

---
layout: 
title: Pagina 25
level: 3
---


Misure di progresso e invarianti ad anello
9
Definire il problema
Definire loop
Invarianti
Definire il passaggio
Fare progressi
Condizioni iniziali
Finale
Uscita
Definire la condizione di uscita
Mantieni il loop inv
Definire la misura di
Progresso
79 km
a scuola
Figura 1.1: i requisiti di un algoritmo iterativo.
insieme in modi molto sottili.Potrebbe essere necessario scorrere attraverso di loro diverse volte, regolando ciò che hai fatto, fino a quando non si mettono tutti insieme come richiesto.
1) Specifiche: che problema stai risolvendo?Quali sono i suoi pre e postcondizioni: vale a dire dove stai iniziando e dov'è la tua destinazione?
2) Passaggi di base: quali passaggi di base ti guideranno più o meno nella direzione corretta?
3) Misura del progresso: è necessario definire una misura del progresso: dove sono il miglio
marcatori lungo la strada?
4) Il ciclo invariante: devi definire un loop invariante che darà un'immagine di
Lo stato del tuo calcolo quando è in cima al ciclo principale, in altre parole, definisce la strada su cui rimarrai.
5) Passi principali: per ogni posizione sulla strada, è necessario scrivere lo pseudocodice
Codeloop per fare un singolo passaggio.Non è necessario iniziare con la prima posizione.Raccomando prima di considerare un passo tipico da fare durante il centro del calcolo.
6) Fai progressi: ogni iterazione del tuo passaggio principale deve fare progressi secondo
alla tua misura di progresso.
7) Mantenere invariante loop: ogni iterazione del passo principale deve garantire che il
Loop Invariant è di nuovo vero quando il calcolo torna in cima al ciclo.
(L'induzione dimostrerà quindi che rimane vera sempre.)
8) Stabilire l'invariante del loop: ora che hai un'idea di dove stai andando, hai un'idea migliore su come iniziare.Devi scrivere lo pseudocodice

---
layout: 
title: Pagina 26
level: 3
---


Algoritmi iterativi e invarianti ad anello
10
CodePre-loop per stabilire inizialmente l'invariante in loop.Come si ottiene da casa tua
sulla strada corretta?
9) Condizione di uscita: è necessario scrivere la condizione ⟨xit-confid⟩ che fa uscire il calcolo dal loop.
10) finale: in che modo la condizione di uscita insieme all'invariante garantisce che il
problema risolto?Quando alla fine della strada ma ancora su di essa, come si produce il
Output richiesto?È necessario scrivere lo pseudocodice codepost-loop per pulire le estremità allentate
e per restituire l'output richiesto.
11) Termine e tempo di esecuzione: quanti progressi devi fare prima di sapere che raggiungerai questa uscita?Questa è una stima del tempo di esecuzione
algoritmo.
12) Casi speciali: quando si tenta di progettare un algoritmo, è necessario solo
Considera un tipo generale di istanze di input.Più tardi, devi scorrere i passaggi
ancora considerando altri tipi di casi e casi speciali.Allo stesso modo, testare il tuo algoritmo a mano su diversi esempi.
13) Dettagli di codifica e implementazione: ora sei pronto a mettere insieme tutti i pezzi e produrre pseudocodi per l'algoritmo.Potrebbe essere necessario a questo punto
Per fornire ulteriori dettagli sull'implementazione.
14) Prova formale: se i pezzi di cui sopra si mettono insieme come richiesto, allora il tuo algoritmo
lavori.
Esempio 1.2.1
L'algoritmo a due dita finta
Per illustrare queste idee
1) Specifiche: un'istanza di input è costituita da un elenco L (1..n) di elementi.Il risultato
è costituito da un indice i tale che L (i) abbia un valore massimo.Se ci sono più voci
Con lo stesso valore, quindi uno di essi viene restituito.
2) Passaggi di base: decidi il metodo a due finali.Il tuo difenatore destro scorre il
elenco.
3) Misura del progresso: la misura del progresso è fino a che punto è la tua destra
la finzione è.
4) The Loop Invariant: The Loop Invariant afferma che la tua finzione sinistra punta a uno di
Le voci più grandi riscontrate finora dal tuo destro destro.
5) Passaggi principali: ogni iterazione, si sposta il tuo difenatore a destra giù per una voce nell'elenco.
Se il tuo finto destro sta ora puntando a una voce più grande, quindi la voce del finta sinistro, sposta il tuo difenatore sinistro per stare con il tuo finto destro.

---
layout: 
title: Pagina 27
level: 3
---


Misure di progresso e invarianti ad anello
11
6) Fai progressi: fai progressi perché la tua finzione giusta sposta una voce.
7) Mantieni loop invariante: sai che l'invariante in loop è stato mantenuto come
segue.Per ogni passaggio, il nuovo elemento di finta sinistro è massimo (vecchio elemento di finta sinistro, nuovo
elemento).Con loop invariant, questo è max (max (elenco più corto), nuovo elemento).Matematicamente, questo è Max (elenco più lungo).
8) Stabilire l'invariante del loop: inizialmente stabilisci l'invariante invariante indicando entrambi i finali al primo elemento.
9) CONDIZIONE ESCITA: hai finito quando il tuo finanziamento giusto ha finito di attraversare l'elenco.
10) Fine: alla fine, sappiamo che il problema è risolto come segue.A causa della condizione di uscita, il tuo affinché ha incontrato tutte le voci.Dal ciclo invariante, la tua sinistra
I punti di finzione al massimo di questi.Restituisci questa voce.
11) Termine e tempo di esecuzione: il tempo richiesto è alcuni tempi costanti il
durata dell'elenco.
12) Casi speciali: controlla cosa succede quando ci sono più voci con il
stesso valore o quando n = 0 o n = 1.
13) Dettagli di codifica e implementazione:
Algoritm Findmax (L)
⟨Pre-Cond⟩: L è un array di N valori.
⟨Post-Cond⟩: restituisce un indice con il valore massimo.
inizio
i = 1;j = 1
ciclo continuo
⟨Loop-invariant⟩: l [i] è massimo in l [1..j].
Esci quando (J ≥N)
% Fa progressi mantenendo l'invariante in loop
j = j + 1
if (l [i] <l [j]) allora i = j
End Loop
restituire (i)
Algoritmo di fine
14) Prova formale: la correttezza dell'algoritmo segue dai passaggi precedenti.
Un nuovo modo di pensare: potresti essere tentato di credere che le misure di progresso
e gli invarianti ad anello sono irrilevanti teoriche.Ma l'industria, dopo molti costosi
errori, ha un apprezzamento più profondo per la necessità di correttezza.La nostra filosofia è
per imparare a pensare, sviluppare e descrivere gli algoritmi in modo tale da
La loro correttezza è trasparente.Per questo, le misure di progresso e invarianti loop sono

---
layout: 
title: Pagina 28
level: 3
---


Algoritmi iterativi e invarianti ad anello
12
essenziale.La descrizione degli algoritmi precedenti e le loro prove di correttezza
sono avvolti in uno.
Tenere a terra: gli invarianti ad anello costituiscono una filosofia della vita.Portano a sentirsi radicati.La maggior parte del codice che segna come insegnante mi fa sentire senza terra.Esso
cicli, ma non so cosa significano le variabili, come si adattano, dove il
L'algoritmo sta andando o come iniziare a pensarci.Invarianti ad anello significa iniziare
La mia giornata a casa, dove so cosa è vero e cosa significano le cose.Da lì, ho
Abbastanza confidenza per avventurarsi nell'ignoto.Tuttavia, anche loop invarianti
significa tornare al punto di partenza nella mia casa sicura alla fine della mia giornata.
Esercizio 1.2.1 Quali sono le cose matematiche formali che coinvolgono invarianti ad anello
Questo deve essere dimostrato, per dimostrare che se il programma esce, ottiene la postcondizionamento?
1.3
Maggiori informazioni sui passaggi
In questa sezione fornisco maggiori dettagli sui passaggi per lo sviluppo di un algoritmo iterativo.
1) Specifiche: prima di poter progettare un algoritmo iterativo, dobbiamo sapere
esattamente quello che dovrebbe fare.
Precondizioni: quali sono le istanze di input legali?Eventuali affermazioni che sono
Promesso di essere vero sull'istanza di input è indicato come precondizioni.
Postconditions: qual è l'output richiesto per ogni istanza legale?Eventuali affermazioni che devono essere vere per l'output sono indicate come postcondizioni.
Correzione: un algoritmo per il problema è corretto se per ogni istanza di input legale, viene prodotto l'output richiesto.Se l'istanza di input non soddisfa il
Precondizioni, quindi tutte le scommesse sono spente.Formalmente, lo esprimiamo come
⟨Pre-Cond⟩ & codealg ⇒⟨post-conf⟩
Questa correttezza è solo rispetto alle specifiche.
Esempio: il problema di smistamento è definito come segue:
Precondizioni: l'input è un elenco di valori N, comprese possibili ripetizioni.
PostConditions: l'output è un elenco costituito dagli stessi valori N in ordine non aressante.
Il contratto: pre e postcondizioni sono, in un certo senso, il contratto tra il
Implemener e l'utente (o invocatore) dell'algoritmo codificato.

---
layout: 
title: Pagina 29
level: 3
---


Misure di progresso e invarianti ad anello
13
Implementatore: quando si scrive una subroutine, puoi assumere l'input
Viene al tuo programma nella forma corretta, soddisfacendo tutte le condizioni preliminari.
Devi scrivere la subroutine in modo che garantisca le postcondizioni
Dopo l'esecuzione.
Utente: quando si utilizza la subroutine, è necessario assicurarsi che l'input
Fornisci le condizioni preliminari della subroutine.Allora puoi fidarti
che l'output soddisfa i suoi postcondizioni.
2) Passaggi di base: come preliminare alla progettazione dell'algoritmo, può essere utile considerare quali passaggi o operazioni di base potrebbero essere eseguiti per fare progressi
verso risolvere questo problema.Fai alcuni di questi passaggi su una semplice istanza di input
Per ottenere un po 'di intuizione su dove potrebbe andare il calcolo.Come potrebbe il
Le informazioni hanno ottenuto stretto il problema del calcolo?
3) Misura del progresso: è necessario definire una funzione che, quando viene dato lo stato corrente del calcolo, restituisce un valore intero che misura quanto
progressi il calcolo ha già fatto o quanti progressi devono ancora essere
fatto.Questo è indicato come una misura del progresso o come una potenziale funzione.Esso
deve essere tale che il progresso totale richiesto per risolvere il problema non sia in ﬁ nito e
che ad ogni iterazione, il calcolo fa progressi.Oltre a ciò, hai la completa libertà di definire questa misura come preferisci.Ad esempio, la tua misura potrebbe
indicare l'importo dell'uscita prodotta, l'importo dell'input considerato, il
misura in cui lo spazio di ricerca è stato ristretto, una funzione più creativa di
Il lavoro svolto finora o quanti casi sono stati processati.La sezione 1.4 delinea come
Queste diverse misure portano a diversi tipi di algoritmi iterativi.
4) Il ciclo invariante: spesso, inventare il loop invariante è il più difficile
Parte della progettazione di un algoritmo.Richiede pratica, perseveranza, creatività e intuizione.Tuttavia, da esso il resto dell'algoritmo spesso segue facilmente.Eccone alcuni
Pointatori utili.
Definizione: un ciclo invariante è un'affermazione che è posizionata nella parte superiore di un ciclo e
Ciò deve essere vero ogni volta che il calcolo ritorna in cima al ciclo.
Asserzioni: più in generale, un'affermazione è una dichiarazione fatta in un particolare
Punto durante l'esecuzione di un algoritmo sullo stato corrente delle strutture di dati del calcolo che è vera o falsa.Se è falso, allora qualcosa
è andato storto nella logica dell'algoritmo.I pre e le postcondizioni sono speciali
Casi di asserzioni che forniscono limiti puliti tra sistemi, sottosistemi, routine e subroutine.All'interno di tale parte, le asserzioni possono anche fornire punti di controllo lungo il percorso del calcolo per consentire a tutti di sapere cosa dovrebbe
sono stati realizzati finora.Gli invarianti sono uguali, tranne che si applicano

---
layout: 
title: Pagina 30
level: 3
---


Algoritmi iterativi e invarianti ad anello
14
a un ciclo che viene eseguito molte volte o in una struttura di dati orientata agli oggetti che
ha una vita in corso.
Progettare, comprendere e dimostrare corretto: generalmente le affermazioni lo sono
Non compiti per l'esecuzione dell'algoritmo, ma sono solo commenti che vengono aggiunti
per aiutare il designer, l'implementatore e il lettore a comprendere il
Algoritmo e la sua correttezza.
Debug: alcune lingue ti consentono di inserire asserzioni come righe di codice.Se
Durante l'esecuzione tale affermazione è falsa, il programma si interrompe automaticamente con un utile messaggio di errore.Questo è utile sia durante il debug
e dopo il completamento del codice.È ciò che sta accadendo quando si verifica una casella di errore
Durante l'esecuzione di un programma che ti dice di contattare il venditore se il
l'errore persiste.Non tutte le affermazioni interessanti, tuttavia, possono essere testate in modo fattibile
all'interno del calcolo stesso.
Immagine dal mezzo: un ciclo invariante dovrebbe descrivere cosa vorresti
la struttura dei dati da apparire quando il calcolo è all'inizio di un
iterazione.La tua descrizione dovrebbe lasciare il tuo lettore con un'immagine visiva.Disegnare un
immagine se vuoi.
Non essere spaventato: un loop invariante non deve essere costituito da matematico formale
Mumbo Jumbo Se una descrizione informale ottiene l'idea migliore.Dall'altra
La mano, l'inglese a volte è fuorviante, e quindi una lingua più matematica a volte aiuta.Dire cose due volte se necessario.Consiglio di fingere
che stai descrivendo l'algoritmo a uno studente di primo anno.
Sulla strada: un loop invariante deve assicurarsi che il calcolo sia ancora sul
strada verso la destinazione e non è caduto in un fossato o è atterrato su un albero.
Una strada ampia: dato un algoritmo fisso su un input fisso, il calcolo seguirà una linea fissa.Quando il designer dell'algoritmo sa esattamente dove questa linea
Andrà, può usare un ciclo molto stretto invariante per definire una strada molto stretta.Sul
Altra mano, perché il tuo algoritmo deve funzionare per un numero infinito di input
istanze e poiché puoi passare molti ostacoli lungo la strada, può essere difficile prevedere dove il calcolo potrebbe essere nel mezzo della sua esecuzione.
In tali casi, l'uso di un ciclo molto sciolto invariante per definire una strada molto ampia è completamente accettabile.La linea effettivamente seguita dal calcolo potrebbe intrecciare
e vento, ma fintanto che rimane entro i confini della strada e continua
Per fare progressi, va tutto bene.Un vantaggio di un'ampia strada è che dà di più
Flight nel modo in cui viene implementato il ciclo principale.Uno svantaggio è che ci sono
poi più luoghi in cui potrebbe essere il calcolo e per ogni algoritmo
Deve definire come fare un passo.
Esempio: come esempio di invariante a loop allentato, nel Tw
algoritmo, l'invariante in loop non detta completamente quale ingresso il tuo

---
layout: 
title: Pagina 31
level: 3
---


Misure di progresso e invarianti ad anello
15
Il finto sinistro dovrebbe puntare quando ci sono un numero di voci con la stessa
valore massimo.
Significativo e realizzabile: vuoi un invariante in loop che sia significativo, il che significa che è abbastanza forte che, con una condizione di uscita appropriata, garantirà
la postcondizionamento.Vuoi anche che l'invariante in loop sia realizzabile, il significato
Puoi stabilirlo e mantenerlo.
Sapere cos'è un ciclo invariante: sii chiaro su cosa sia un loop invariante.Non è
Codice, un preliminare, una postcondizionamento o qualche altra informazione inappropriata.Ad esempio, affermare qualcosa che è sempre vero, come “1 + 1 =
2 "o" La radice è il massimo di qualsiasi heap ", possono essere informazioni utili per la risposta
al problema, ma non dovrebbe far parte dell'invariante in loop.
Flusso senza intoppi: il ciclo invariante
dovrebbe fluire senza intoppi dall'inizio alla fine dell'algoritmo.
r all'inizio, dovrebbe seguire
Facilmente dai precondizioni.
r dovrebbe progredire in piccoli naturali
Passi.
r una volta che la condizione di uscita è stata
incontrato, il
Postconditions
Dovrebbe
Segui facilmente.
Chiedi il 100%: una buona filosofia nella vita è chiedere il 100% di ciò che desideri, ma
Non supporre che lo otterrai.
Dream: non essere timido.Cosa vorresti essere vero nel mezzo del tuo
calcolo?Questo può essere un ciclo ragionevole invariante e potrebbe non essere.
Fai finta: fingi che un genio abbia concesso il tuo desiderio.Ora sei nel mezzo del tuo calcolo e il tuo anello dei sogni è vero.
Mantieni l'invariante del loop: da qui, sei in grado di adottare alcuni passaggi computazionali che faranno progressi mantenendo l'invariante del loop?
In tal caso, fantastico.In caso contrario, ci sono due ragioni comuni.
Troppo debole: se il tuo ciclo invariante è troppo debole, allora il genio non ti ha fornito tutto ciò di cui hai bisogno per andare.
Troppo forte: se il tuo ciclo invariante è troppo forte, allora non sarai in grado
per stabilirlo inizialmente o mantenerlo.
Nessun ipotesi non dichiarata: non vuoi invarianti a loop che non dispongono di dettagli o lo sono
Troppo debole per procedere al passaggio successivo.Non fare ipotesi che non lo fai

---
layout: 
title: Pagina 32
level: 3
---


Algoritmi iterativi e invarianti ad anello
16
stato.Come assegno, fai finta di essere un marziano che è saltato in cima
Il ciclo che non sa nulla che non è indicato nel loop invariante.
Esempio: nell'algoritmo a due finanze-max-max, l'invariante del loop fa alcune ipotesi non dichiarate.Presuppone
Che i numeri sopra il tuo finto destro siano stati riscontrati dal tuo finto destro e quelli sotto non lo hanno fatto.
Forse soprattutto per, ± 1 errori, è se
È stato riscontrato il numero attualmente in fase di appunti
Già.L'invariante del loop presuppone anche che i numeri nell'elenco abbiano
non modificato dai loro valori originali.
Una notte stellata: come ha fatto Van Gogh a venire con il suo famoso
dipingendo, una notte stellata?Non c'è risposta facile.Allo stesso modo, inventare invarianti e algoritmi loop è una forma d'arte.
Usa questo processo: non trovare il loop invariante dopo il
fatto.Usalo per progettare il tuo algoritmo.
5) Passaggi principali: lo pseudocodice codeloop deve essere definito in modo che possa essere preso
non solo da dove pensi che potrebbe essere il calcolo, ma da qualsiasi stato del
Struttura dei dati per la quale è vera l'invariante del loop e la condizione di uscita non ha ancora
stato incontrato.
Preoccupati di un passo alla volta.Non farti tirare nel forte desiderio di comprendere l'intero calcolo in una volta.In generale, questo porta solo paura e infelicità.Ripeto la saggezza insegnata sia dai buddisti che dai programmi di dodici fasi: oggi potresti sentirti come se fossi lasciato in una strana città senza
Sapere come ci sei arrivato.Non preoccuparti del passato o del futuro.Essere rassicurato
Che sei da qualche parte lungo la strada corretta.Il tuo obiettivo è solo fare un passo così
Che fai progressi e rimani sulla strada.Un'altra analogia è immaginare di essere
Parte di una gara di staffetta.Un compagno di squadra ti consegna il testimone.Il tuo compito è portarlo solo una volta
Intorno alla pista e consegnarlo al prossimo compagno di squadra.
6) Fai progressi: è necessario dimostrare che il progresso di almeno un'unità della tua misura viene compiuto ogni volta che l'algoritmo gira intorno al ciclo.A volte ci sono
situazioni strane in cui l'algoritmo può iterare senza rendere misurabile
progresso.Questo non è accettabile.Il pericolo è che l'algoritmo si avvicini per sempre.
Devi definire un'altra misura che meglio mostra come stai facendo
progressi durante tali iterazioni o modificare il passo fatto nel ciclo principale in modo che
sono fatti progressi.La prova formale di questo è simile a quella per mantenere il loop
invariante.
7) Mantenere l'invariante in loop: è necessario dimostrare che l'invariante del loop è mantenuto in ogni iterazione.

---
layout: 
title: Pagina 33
level: 3
---


Misure di progresso e invarianti ad anello
17
La dichiarazione formale: se vuoi o meno dimostrarlo formalmente, il formale
L'affermazione che deve essere vera è
⟨Loop-invariant ′⟩ & not⟨exit-cond⟩ & codeloop ⇒ tloop-invariant ′ ′⟩
Tecnica di prova:
R supponiamo che il calcolo sia in cima al ciclo.
R supporre che l'invariante in loop sia soddisfatto;altrimenti il ​​programma avrebbe
già fallito.Fare riferimento all'immagine che hai disegnato per vedere cosa ti dice questo
sullo stato attuale della struttura dei dati.
r puoi anche supporre che la condizione di uscita non sia soddisfatta, perché altrimenti
Il ciclo sarebbe uscito.
r eseguire lo pseudocodice codeloop, in una iterazione del loop.Come fa questo
Modificare la struttura dei dati?
r dimostra che quando torni di nuovo in cima al ciclo, i requisiti stabiliti
dal ciclo invariante si incontrano ancora una volta.
Situazioni diverse: molte sottigliezze possono derivare dall'enorme numero di diverse istanze di input e dall'enorme numero di luoghi diversi il calcolo
potrebbe trovare se stesso.
r I Consiglia di progettare la prima volta lo pseudocodice codeloop per funzionare per un generale
Iterazione media quando viene data un'istanza di input grande e generale.Il ciclo è invariante mantenuto in questo caso?
R quindi prova la prima e l'ultima coppia di iterazioni.
r Prova anche istanze di input del caso speciale.Prima di scrivere un codice separato per questi, controlla se il codice che hai già capita di gestire questi casi.Se
Sei costretto a modificare il codice, assicurati di verificare che il precedentemente gestito
I casi sono ancora gestiti.
r per dimostrare che l'invariante in loop è vero in tutte le situazioni, fai finta di essere
In cima al ciclo, ma non sai come ci sei arrivato.Tu forse hai
lasciato cadere da Marte.Oltre a sapere che l'invariante in loop è vero e il
La condizione di uscita non lo è, non sai nulla sullo stato della struttura dei dati.
Non fare altri ipotesi.Quindi girare intorno al ciclo e dimostra che il ciclo
invariante è mantenuto.
Differenziazione tra iterazioni: l'assegnazione x = x + 2 è significativo come a
riga di codice, ma non come una dichiarazione matematica.Definire X ′ essere il valore di
x all'inizio dell'iterazione e x ′ ′ quello dopo aver girato il ciclo uno
più tempo.L'effetto del codice x = x + 2 è che x ′ ′ = x ′ + 2.
8) Stabilire l'invariante del loop: è necessario dimostrare che il codice iniziale stabilisce l'invariante loop.
L'affermazione formale: l'affermazione formale che deve essere vera è
⟨Pre-Cond⟩ & CodePre-Loop ⇒⟨loop-invariante⟩

---
layout: 
title: Pagina 34
level: 3
---


Algoritmi iterativi e invarianti ad anello
18
Tecnica di prova:
R supponiamo che tu stia appena iniziando il calcolo.
r puoi supporre che l'istanza di input soddisfi la presupposti;Altrimenti
Non ci si aspetta che tu risolva il problema.
r eseguire il codice codice-loop prima del ciclo.
r dimostra che quando si arriva al massimo in cima al ciclo, i requisiti stabiliti dal
Loop invariant sono soddisfatti.
Modo più semplice: stabilire il ciclo invariante nel modo più semplice possibile.Ad esempio, se è necessario costruire un set in modo tale che tutti i draghi al suo interno siano viola, il modo più semplice per farlo è costruire il set vuoto.Nota che tutti i draghi
Questo set è viola, perché non contiene draghi che non sono viola.
Attento: a volte è difficile sapere come impostare le variabili per fare il
Loop invariant inizialmente vero.In tali casi, prova a impostarli per assicurarti che sia vero
Dopo la prima iterazione.Ad esempio, qual è il valore massimo all'interno di un vuoto
Elenco dei valori?Si potrebbe pensare 0 o ∞.Tuttavia, una risposta migliore è −∞.Quando
Aggiunta di un nuovo valore, si utilizza il codice newMax = max (oldmax, newValue).A partire da OldMax = −∞, fornisce la risposta corretta quando viene aggiunto il primo valore.
9) Condizione di uscita: generalmente esci dal ciclo quando hai completato l'attività.
Bloccato: A volte, tuttavia, sebbene l'intuizione è che il tuo algoritmo progettato finora sta facendo progressi ogni iterazione, non hai idea se, in questa direzione, l'algoritmo risolverà mai il problema o come faresti
Sapalo se succede.Perché l'algoritmo non può fare progressi per sempre, lì
Devono essere situazioni in cui il tuo algoritmo rimane bloccato.Per tali situazioni, tu
deve pensare ad altri modi per il tuo algoritmo di fare progressi o averlo
Uscita.Un buon passo è uscire.Nel passaggio 10, dovrai dimostrarlo quando il tuo
L'algoritmo esce, in realtà sei in grado di risolvere il problema.Se non sei in grado di farlo
Fallo, quindi dovrai tornare indietro e ridisegnare il tuo algoritmo.
Loop While vs Exit Quando: i seguenti sono equivalenti:
mentre (a e b)
...
terminare mentre
ciclo continuo
⟨Loop-invariante⟩
Esci quando (non a o no b)
...
End Loop
Il secondo è più utile qui perché si concentra sulle condizioni necessarie
Esci dal ciclo, mentre il primo si concentra sulle condizioni necessarie per continuare.Un altro vantaggio del secondo è che ti permette anche di scivolare nel ciclo invariante
tra la parte superiore del ciclo e la condizione di uscita.

---
layout: 
title: Pagina 35
level: 3
---


Misure di progresso e invarianti ad anello
19
10) finale: in questo passaggio, devi assicurarti che una volta uscito il ciclo sarai
in grado di risolvere il problema.
L'affermazione formale: l'affermazione formale che deve essere vera è
⟨Loop-invariante⟩ & ⟨Exit-Cond⟩ & CodePost-Loop ⇒ ⇒ Post-COND⟩
Tecnica di prova:
R su di quanto tu sia appena scoppiato dal ciclo.
r puoi presumere che l'invariante in loop sia vero, perché hai mantenuto
che è sempre vero.
r puoi anche supporre che la condizione di uscita sia vera dal fatto che il ciclo ha
uscito.
r eseguire il codice codepost-loop dopo il ciclo per dare alcuni tocchi verso
Risolvere il problema e restituire il risultato.
r da solo questi fatti, devi essere in grado di dedurre che il problema è stato
Risolto correttamente, vale a dire che la postconditazione è stata stabilita.
11) Termine e tempo di esecuzione: devi dimostrare che l'algoritmo no
Loop per sempre.Questo viene fatto dimostrando che se la misura del progresso soddisfa alcuni
Importo dichiarato, quindi la condizione di uscita è stata definitivamente soddisfatta.(Se esce prima di
Questo, tanto meglio.) Il numero di iterazioni necessarie è quindi delimitato da questo dichiarato
Importo dei progressi divisi per la quantità di progressi fatti ogni iterazione.Il tempo di esecuzione viene stimato aggiungendo il tempo richiesto per ciascuna di queste iterazioni.Per
Alcune applicazioni, limiti di spazio (ovvero la quantità di memoria utilizzata) possono anche essere importanti.Discutiamo di concetti importanti relativi al tempo di esecuzione nei capitoli 23–26:
Complessità del tempo e dello spazio, le idee utili di logaritmi ed esponenziali, bigoh
(O) e la notazione theta () e diverse approssimazioni pratiche.
12) Casi speciali: quando si progetta un algoritmo, non si desidera preoccupare
Ogni possibile tipo di istanza di input contemporaneamente.Invece, ottieni prima l'algoritmo
lavorare per un tipo generale, poi un altro e un altro.Sebbene il successivo tipo di istanze di input possa richiedere un codice separato, inizia tracciando quale sia l'algoritmo
Hai già progettato farebbe un tale input.Spesso questo algoritmo lo farà
capita di gestire molti di questi casi automaticamente senza richiedere separati
codice.Quando si aggiunge codice per gestire un caso speciale, assicurarsi di verificare che il precedente
I casi gestiti sono ancora gestiti.
13) Dettagli di codifica e implementazione: anche dopo aver delineato l'algoritmo di base, ci possono essere molti piccoli dettagli da considerare.Molte di queste implementazione
I dettagli possono essere nascosti nei tipi di dati astratti (vedere il capitolo 3).Se un dettaglio non lo fa davvero
Fai la differenza per un algoritmo, è meglio mantenere aperte tutte le possibilità, dando un extra
flessibilità all'implementatore.Per molti dettagli, non importa quale scelta te
fare, ma i bug possono essere introdotti se non sei coerente e chiaro su ciò che tu

---
layout: 
title: Pagina 36
level: 3
---


Algoritmi iterativi e invarianti ad anello
20
Ho scelto.Questo testo non si concentra sui dettagli di codifica.Questo non significa che loro
non sono importanti.
14) Prova formale: i passaggi 1-11 sono sufficienti per garantire che il tuo algoritmo iterativo
Opere, cioè che fornisce la risposta corretta su tutti gli input specifici.Considera un po '
istanza che soddisfa i precondizioni.Al passaggio 8 stabiliamo il ciclo invariante il
prima volta il calcolo è in cima al ciclo e al passaggio 7 lo manteniamo ciascuno
iterazione.Quindi, a titolo di induzione, sappiamo che l'invariante in loop è vero ogni
Tempo il calcolo è in cima al ciclo.(Vedi la seguente discussione.) Quindi, al passaggio 5, il passo fatto nel ciclo principale è sempre definito ed esegue senza
Crashing fino a quando il ciclo esce.Inoltre, al passaggio 6 Ognuno di questi iterazione fa progressi
di almeno uno.Quindi, al passaggio 11, la condizione di uscita viene infine soddisfatta.Passaggio 10 quindi
dà che la postcondizionamento sia raggiunta, in modo che l'algoritmo funzioni in questo caso.
Induzione matematica: l'induzione è un matematico estremamente importante
tecnica per dimostrare dichiarazioni universali ed è la pietra angolare di iterativi
Algoritmi.Quindi, lo considereremo più in dettaglio.
Ipotesi di induzione: per ogni n ≥0, Sia (n) l'affermazione “Se il ciclo
non è ancora uscito, quindi l'invariante in loop è vero quando sei in cima
il ciclo dopo aver girato e n. n. ”
Obiettivo: l'obiettivo è dimostrare che ∀n ≥0, s (n), vale a dire: “Finché il ciclo ha
Non ancora uscito, l'invariante in loop è sempre vero quando sei in cima al
ciclo continuo."
Schema di prova: prova per induzione su n.
Caso base: dimostrare s (0) implica dimostrare che l'invariante in loop è vero
Quando l'algoritmo arriva prima in cima al ciclo.Questo è ottenuto da
Dimostrando l'istruzione ⟨pre-Cond⟩ & CodePre-Loop ⇒ classifica invariante⟩.
Fase di induzione: dimostrare s (n - 1) ⇒s (n) implica la prova che il loop
invariante è mantenuto.Ciò si ottiene dimostrando l'affermazione
⟨Loop-invariant ′⟩ & not ⟨exit-cond⟩ & codeLoop ⇒⟨ ′ ′ ′ ′ ′ ′⟩.
Conclusione: a titolo di induzione, possiamo concludere che ∀n ≥0, s (n), cioè che il ciclo invariante è sempre vero quando in cima al ciclo.
Il processo di induzione:
S (0) è vero
(per caso di base)
S (0) ⇒s (1)
(per fase di induzione, n = 1)
Quindi, s (1) è vero
S (1) ⇒s (2)
(per fase di induzione, n = 2)
Quindi, s (2) è vero
S (2) ⇒s (3)
(per fase di induzione, n = 3)
Quindi, s (3) è vero...

---
layout: 
title: Pagina 37
level: 3
---


Misure di progresso e invarianti ad anello
21
Altre tecniche di prova: altri passaggi formali per la prova della correttezza sono descritte nel capitolo 28.
Fede nel metodo: convincere te stesso che questi passaggi sono sufficienti a definire un
algoritmo in modo da non avere riconvocare te stesso ogni volta che hai bisogno di progettare
un algoritmo.
1.4
Diversi tipi di algoritmi iterativi
Per aiutarti a progettare una misura di progresso e un ciclo invariante per il tuo algoritmo, ecco alcuni tipi classici, seguiti da esempi di ogni tipo.
Più output: se la soluzione è una struttura composta da molti pezzi (ad esempio, una serie di numeri interi, un set o un percorso), una cosa naturale da provare è costruire la soluzione
Un pezzo alla volta.
Misura del progresso: l'importo dell'output costruito.
Loop Invariant: l'output costruito finora è corretto.
Più dell'input: supponiamo che l'input sia costituito da N oggetti (ad es. Un array di N interi o un grafico con N nodi).Sarebbe ragionevole che l'algoritmo li legga
in uno alla volta.
Misura del progresso: l'importo dell'input considerato.
Loop invariant: fingendo che questo prefisso dell'input sia l'intero input, ho
una soluzione completa.
Esempi: dopo aver iterazioni dell'algoritmo a due finali colpisce il precedente algoritmo a due finali, il
Punti di finzione sinistra al punteggio più alto all'interno del prefumo dell'elenco finora visto.Dopo
I iterazioni di una versione del tipo di inserzione, i primi elementi dell'input sono
smistato.Vedi Figura 1.2.
23
32
23
32
12
14
16
23
32
<
12
12
3
14
14
3
7
12
2
5
23
14
8
32
16
3
7
2
5
8
16
8
5
2
7
3
16
8
5
2
7
Ordinamento di inserzione
Ordine di selezione
Produzione
Ingresso
Figura 1.2: vengono dimostrati gli invarianti ad anello per l'ordinamento di inserimento e l'ordinamento di selezione.

---
layout: 
title: Pagina 38
level: 3
---


Algoritmi iterativi e invarianti ad anello
22
Bad Loop Invariant: un errore comune è quello di dare il loop invariante "Ho gestito e ho una soluzione per ciascuno degli oggetti I I input."Questo è sbagliato
Perché ogni oggetto nell'ingresso non ha bisogno di una soluzione separata;l'input come
un insieme lo fa.Ad esempio, nell'algoritmo a due finali colpiti, non si può
sapere se un elemento è il massimo considerandolo in isolamento da
gli altri elementi.Un elemento è solo il massimo rispetto al
Altri elementi nel sublist.
Restringendo lo spazio di ricerca: se stai cercando qualcosa, prova a restringere
Lo spazio di ricerca, forse diminuendolo di uno o, ancora meglio, tagliandolo a metà.
Misura del progresso: le dimensioni dello spazio in cui hai ridotto il
ricerca.
Loop invariant: se la cosa che viene cercata è ovunque, allora è in questo
Sublist ristretto.
Esempio: ricerca binaria.
Lavoro svolto: la misura del progresso potrebbe anche essere qualche altra funzione più creativa del lavoro svolto finora.
Esempio: la specie di bolle misura il suo progresso da quante coppie di elementi
fuori servizio.
Analisi del caso: prova la cosa ovvia.Per quali istanze di input funziona e
Per quale non funziona?Ora devi solo trovare un algoritmo per cui funziona
quei casi successivi.Una misura del progresso potrebbe includere quali casi hai provato.
Ora daremo un semplice esempi di ciascuno di questi.Anche se probabilmente conosci già questi algoritmi, usali per comprendere questi diversi tipi di algoritmi iterativi
e per rivedere i passaggi richiesti.
Esempio 1.4.1
Più dell'output: selezione
1) Specificazioni: l'obiettivo è riorganizzare un elenco di N valori in ordine non gradito.
2) Passaggi di base: selezioneremo ripetutamente l'elemento non selezionato più piccolo.
3) Misura del progresso: la misura del progresso è il numero K degli elementi selezionati.
4) Il ciclo invariante: il loop invariante afferma che gli elementi selezionati sono il k
più piccoli degli elementi e che questi sono stati ordinati.Gli elementi più grandi sono in un
impostato sul lato.

---
layout: 
title: Pagina 39
level: 3
---


Misure di progresso e invarianti ad anello
23
5) Passi principali: il passo principale è trovare l'elemento più piccolo tra quelli del
Set rimanente di elementi più grandi e per aggiungere questo elemento appena selezionato alla fine di
L'elenco ordinato di elementi.
6) Fai progressi: viene fatto progressi perché K aumenta.
7) Mantieni loop invariante: dobbiamo dimostrare che ⟨loop-invariant ′⟩ & not ⟨exit−
Cond⟩ & CodeLoop ⇒⟨Loop-Invariant ′ ′⟩.Dal precedente loop invariante, il recente
L'elemento selezionato è almeno la dimensione degli elementi precedentemente selezionati.Dal passo, lo è
Non più grande degli elementi sul lato.Ne consegue che deve essere l'elemento k + 1st in
la lista.Quindi, spostando questo elemento dal set sul lato alla fine dell'elenco ordinato
Garantisce che gli elementi selezionati nel nuovo elenco siano i più piccoli K + 1 e ordinati.
8) Stabilire l'invariante in loop: dobbiamo dimostrare che ⟨pre-Cond⟩ & CodePre-Loop ⇒
⟨Loop-invariante⟩.Inizialmente, k = 0 sono ordinati e tutti gli elementi sono messi da parte.
9) Condizione di uscita: fermati quando k = n.
10) Ending: dobbiamo dimostrare ⟨loop-invariante⟩ & ⟨exit-Cond⟩ & codepost-loop ⇒
⟨Post-Cond⟩.Dalla condizione di uscita, tutti gli elementi sono stati selezionati e da
L'anello invariante questi elementi selezionati sono stati ordinati.
11) Termine e tempo di esecuzione: non abbiamo considerato quanto tempo ci vuole
trovare il prossimo elemento più piccolo o per gestire le strutture di dati.
Esempio 1.4.2
Più dell'input: ordinamento
1) Specificazioni: ancora una volta l'obiettivo è riorganizzare un elenco di n valori in nonno.
ordine.
2) Passaggi di base: questa volta inseriremo ripetutamente alcuni elementi a cui appartiene.
3) Misura del progresso: la misura del progresso è il numero K degli elementi inseriti.
4) The Loop Invariant: The Loop Invariant afferma che gli elementi inseriti K sono
Ordinati all'interno di un elenco e che, come prima, gli elementi rimanenti sono partiti da qualche parte.
5) Passaggi principali: il passo principale è prendere uno qualsiasi degli elementi che sono fuori lato e
Inseriscilo nell'elenco ordinato a cui appartiene.
6) Fai progressi: viene fatto progressi perché K aumenta.
7) Mantieni loop invariante: ⟨loop-invariant ′⟩
& non
⟨Exit-cond⟩
E
Codeloop
⇒
⟨Loop-invariant ′ ′⟩.Sai che l'invariante in loop è stato mantenuto perché il
Il nuovo elemento viene inserito nel luogo corretto nell'elenco precedentemente ordinato.
8) Stabilire l'invariante in loop: inizialmente, con k = 1, pensa al primo elemento in
L'array come elenco ordinato di lunghezza uno.

---
layout: 
title: Pagina 40
level: 3
---


Algoritmi iterativi e invarianti ad anello
24
9) Condizione di uscita: fermati quando k = n.
10) finale: ⟨loop-invariante⟩ & ⟨exit-cond⟩ & codepost-loop ⇒⟨post-cond⟩.Dall'uscita
Condizioni, tutti gli elementi sono stati inseriti e, dall'anello invariante, questi elementi inseriti sono stati ordinati.
11) Termine e tempo di esecuzione: non abbiamo considerato quanto tempo impiega per inserire l'elemento o per gestire le strutture di dati.
Esempio 1.4.3
Restringendo lo spazio di ricerca: ricerca binaria
1) Specifiche: un'istanza di input è costituita da un elenco ordinato A [1..n] di elementi e
una chiave da cercare.Gli elementi possono essere ripetuti.Se la chiave è nell'elenco, allora il
L'output è costituito da un indice i tale che una chiave [i] =.Se la chiave non è nell'elenco, allora il
Output riporta questo.
2) Passaggi di base: continuare a tagliare lo spazio di ricerca in cui la chiave potrebbe essere a metà.
4) Il ciclo invariante: l'algoritmo mantiene un sublist a [i..j] tale che se la chiave è
contenuto nell'elenco originale A [1..n], quindi è contenuto in questo sublist ristretto.(Se
L'elemento viene ripetuto, quindi potrebbe anche essere al di fuori di questo sublist.)
3) Misura del progresso: la misura del progresso è il numero di elementi nel nostro
Sublist, vale a dire J −i + 1.
5) Passaggi principali: ogni iterazione confronta la chiave con l'elemento al centro del
sublist.Ciò determina quale metà del sublist non si trova in e quindi in quale
metà da mantenere.Più formalmente, lascia che il medio indice l'elemento nel mezzo della nostra corrente
sublist a [i..j].Se la chiave ≤a [metà], il sublist è ristretto a un [i..mid].Altrimenti, esso
è ristretto a un [Mid + 1..J].
6) Fai progressi: la dimensione del sublist diminuisce di un fattore due.
7) Mantieni loop invariante: ⟨loop-invariant ′⟩
& non
⟨Exit-cond⟩
E
Codeloop
⇒
⟨Loop-invariant ′ ′⟩.L'anello precedente invariante dà che la ricerca è stata ridotta al sublist A [i..j].Se la chiave> A [metà], quindi perché l'elenco è ordinato, sappiamo che la chiave non è in un [1..mid] e quindi questi elementi possono essere gettati via, restringendo la ricerca a un [Mid + 1..J].Allo stesso modo se la chiave <a [mid].Se key = a [mid], allora potremmo riferire che la chiave è stata trovata.Tuttavia, anche l'invariante in loop è
mantenuto restringendo la ricerca a un [i..mid].
8) Stabilire il loop invariante: ⟨pre-Cond⟩ & CodePre-Loop ⇒ insiughel-froop-invariante⟩.
Inizialmente, si ottiene il loop invariante considerando l'intero elenco come sublist.Esso
Ne consegue banalmente che se la chiave è nell'intero elenco, allora è anche in questo sublist.
9) Condizione di uscita: usciamo quando il sublist contiene uno (o zero) elementi.
10) finale: ⟨loop-invariante⟩ & ⟨exit-cond⟩ & codepost-loop ⇒⟨post-cond⟩.Dall'uscita
condizione, il nostro sublist contiene al massimo un elemento e dal ciclo invariante, se il

---
layout: 
title: Pagina 41
level: 3
---


Misure di progresso e invarianti ad anello
25
La chiave è contenuta nell'elenco originale, quindi la chiave è contenuta in questo sublist, ovvero deve
Sii questo elemento.Quindi, il codice finale verifica se questo elemento è la chiave.Se
È, quindi il suo indice viene restituito.In caso contrario, l'algoritmo riporta che la chiave non lo è
nella lista.
11) Termine e tempo di esecuzione: le dimensioni dei sublisti sono approssimativamente
n, n
2, n
4, n
8, n
16 ,..., 8, 4, 2, 1. Quindi, sono necessarie solo (log).Ogni divisione prende O (1)
tempo.Quindi, il tempo totale è (logn).
12) Casi speciali: un caso speciale da considerare è quando la chiave non è contenuta in
Elenco originale A [1..N].Si noti che il ciclo invariante tiene conto attentamente questo caso.
L'algoritmo restringerà il sublist fino a uno (o zero) elementi.Il contropiede positivo dell'invariante in loop indica quindi se la chiave non è contenuta in questo ristretto
Sublist, quindi la chiave non è contenuta nell'elenco originale A [1..N].
13) Dettagli di codifica e implementazione: in
aggiunta
A
Test
se
chiave ≤
A [metà], ogni iterazione potrebbe testare per vedere se un [metà] è la chiave.Anche se trovare la chiave
In questo modo ti consentirebbe di fermare i test in anticipo, estesi mostra che questo extra
Il confronto rallenta il calcolo.
Esempio 1.4.4
Lavoro svolto: ordinamento
1) Specificazioni: l'obiettivo è riorganizzare un elenco di N valori in ordine non gradito.
2) Passaggi di base: scambiare elementi fuori servizio.
3) Misura del progresso: un involuzione è una coppia di elementi fuori servizio, cioè a
coppia I, j dove 1 ≤i <j ≤n, a [i]> a [j].La nostra misura del progresso sarà il numero
di involuti nel nostro attuale ordinamento degli elementi.Ad esempio, in [1, 2, 5, 4, 3, 6], ci sono tre involuti.
4) Il ciclo invariante: il ciclo invariante è relativamente debole, affermando solo che abbiamo
Una permutazione degli elementi di input originali.
5) Passaggi principali: il passo principale è trovare due elementi adiacenti che sono fuori servizio
e per scambiarli.
6) Fai progressi: un tale passo diminuisce il numero di involuti di uno.
7) Mantieni loop invariante: ⟨loop-invariant ′⟩
& non
⟨Exit-cond⟩
E
Codeloop
⇒
⟨Loop-invariant ′ ′⟩.Dal precedente anello invariante abbiamo avuto una permutazione del
elementi.Lo scambio di una coppia di elementi non cambia questo.
8) Stabilire il loop invariante: ⟨pre-Cond⟩ & CodePre-Loop ⇒ tloop-invariante⟩.
Inizialmente, abbiamo una permutazione degli elementi.
9) Condizione di uscita: fermati quando abbiamo un elenco ordinato di elementi.

---
layout: 
title: Pagina 42
level: 3
---


Algoritmi iterativi e invarianti ad anello
26
10) finale: ⟨loop-invariante⟩ & ⟨exit-cond⟩ & codepost-loop ⇒⟨post-cond⟩.Dal ciclo
Invariante, abbiamo una permutazione degli elementi originali e dalla condizione di uscita
Questi sono ordinati.
11) Termine e tempo di esecuzione: inizialmente, la misura del progresso non può essere
superiore a n (n −1)/2 perché questo è il numero di coppie di elementi che ci sono.In
Ogni iterazione, questa misura diminuisce di una.Quindi, dopo al massimo le iterazioni N (N −1)/2, la misura del progresso è diminuita a zero.A questo punto l'elenco è stato
Ordinato e la condizione di uscita è stata soddisfatta.Non abbiamo considerato quanto tempo ci vuole
per trovare due elementi adiacenti che sono fuori servizio.
Esercizio 1.4.1 (vedere la soluzione nella parte quinta.) Fornire i dettagli di implementazione e il
tempi di esecuzione per il tipo di selezione.
Esercizio 1.4.2 (vedi soluzione nella parte quinta.) Fornire i dettagli di implementazione e il
Tempi di esecuzione per l'ordinamento di inserimento.Utilizza la ricerca binaria per trovare l'elemento più piccolo
O per trovare dove inserire aiuto?Fa la differenza se gli elementi sono
memorizzato in un array o in un elenco collegato?
Esercizio 1.4.3 (vedi soluzione nella parte quinta.) Fornire i dettagli di implementazione e il
tempi di esecuzione per la bolle: utilizzare un altro loop invariante per dimostrare che il numero totale di confronti necessari è O (N2).
1.5
Errori tipici
In uno studio, a un gruppo di programmatori esperti è stato chiesto di programmare la ricerca binaria.
Facile, sì?L'80% ha sbagliato!La mia ipotesi è che se avessero usato gli invarianti ad anello, tutti loro
Avrebbe ottenuto corretto.
Sii chiaro: il codice specifica l'attuale sottointervallo a [i..j] con due tentesi e j.
Documenta chiaramente se il sublist include i punti finali I e J o no.Lo fa
Non importa quale, ma devi essere coerente.Confusione nei dettagli come questo è il
Causa di molti bug.
Dettagli matematici: piccole operazioni matematiche come calcolare l'indice dell'elemento medio del sottointervallo A (i..j) sono soggette a bug.Controlla te stesso che la risposta
è mid = ⌊i+j
2 ⌋.
6) Fai progressi: assicurati che ogni progresso dell'iterazione sia compiuto in ogni speciale
caso.Ad esempio, nella ricerca binaria, quando l'attuale sublist ha una lunghezza uniforme, è ragionevole (come fatto sopra) lasciare che Mid sia l'elemento solo a sinistra del centro.È altresì
ragionevole includere l'elemento medio nella metà destra del sublist.Tuttavia,

---
layout: 
title: Pagina 43
level: 3
---


Misure di progresso e invarianti ad anello
27
Insieme questi causano un bug.Dato il sublist a [i..j] = a [3, 4], il mezzo sarà il
Elemento indicizzato con 3 e il sublist destro sarà ancora un [Mid..j] = A [3, 4].Se questo
Sublist è mantenuto, non verranno fatti progressi e l'algoritmo si aggirerà per sempre.
7) Mantenere invariante loop: assicurarsi che l'invariante loop sia mantenuto in ogni caso speciale.Ad esempio, nella ricerca binaria, è ragionevole verificare se
Chiave <a [mid] o chiave ≥a [mid].È anche ragionevole per tagliare il sublist a [i..j]
in un [i..mid] e un [mid + 1..j].Tuttavia, insieme questi causano un bug.Quando la chiave e
A [metà] è uguale, il tasto di prova <a [mid] fallirà, causando il pensiero dell'algoritmo il
La chiave è più grande e per mantenere la metà giusta [metà + 1..J].Tuttavia, questo salta sulla chiave.
LOOP semplice: codice come “i = 1;while (i ≤n) a [i] = 0;i = i + 1;End mentre "è sorprendentemente inclinato all'errore di essere spento di uno.Il ciclo invariante “quando in cima
Il ciclo, indicizza l'elemento successivo da gestire "aiuta molto.
Esercizio 1.5.1 (vedi soluzione nella quinta parte.) Ora sei il professore.Quale dei
Passaggi per sviluppare un algoritmo iterativo lo studente non è riuscito a fare correttamente nel seguente codice?Come?Come lo faresti?
Algoritmo EG (I)
⟨Pre-Cond⟩: I è un numero intero.
⟨Post-Cond⟩: output i
j = 1 j.
inizio
S = 0
i = 1
while (i ≤i)
⟨Loop-invariant⟩: ogni iterazione aggiunge la successiva
termine dando quell'e = i
j = 1 j.
s = s + i
i = i + 1
End Loop
ritorna)
Algoritmo di fine
1.6
Esercizi
Esercizio 1.6.1 Sei nel mezzo di un lago di raggio 1. Puoi nuotare a una velocità di
1 e può funzionare in modo infinitamente veloce.C'è un mostro intelligente sulla riva che non può andare nel
acqua ma può correre a una velocità di 4. Il tuo obiettivo è nuotare a riva, arrivando in un punto in cui
Il mostro non lo è, e poi fuggito.Se nuoti direttamente a riva, ti ci vorrà 1

---
layout: 
title: Pagina 44
level: 3
---


Algoritmi iterativi e invarianti ad anello
28
Unità temporale.In questo momento, il mostro eseguirà la distanza <4 intorno a dove tu
terra e mangiarti.La tua strategia migliore è quella di mantenere l'invariante in loop più ovvio
aumentando la misura più evidente del progresso il più a lungo possibile e poi
nuota per questo.Descrivi come funziona.
Esercizio 1.6.2
Dato un grafico non indirizzato g tale che ogni nodo abbia al massimo D + 1
vicini, colora ogni nodo con uno dei colori d + 1 in modo che per ogni bordo i due nodi
avere colori diversi.Suggerimento: non pensare troppo.Basta colorare i nodi.Di quale loop invariante hai bisogno?

---
layout: 
title: Pagina 45
level: 3
---


29
2 esempi che utilizzano più di input
Invarianti ad anello
Ora siamo pronti a guardare altri esempi di algoritmi iterativi.Per ogni esempio, cerca i passaggi chiave del paradigma invariante del loop.Qual è il ciclo invariante?Come
È ottenuto e mantenuto?Qual è la misura del progresso?Come è corretto
Risposta finale assicurata?
In questo capitolo, incontreremo alcuni di quegli algoritmi che usano il tipo di loop invariante.L'algoritmo legge gli oggetti N che compongono il
Inserisci uno alla volta.Dopo aver letto il primo I di loro, l'algoritmo finge temporaneamente che questo prefisso dell'input sia in realtà l'intero input.L'anello invariante è “Io
Attualmente hanno una soluzione per l'input costituito esclusivamente da questi primi oggetti (e
Forse alcune informazioni aggiuntive). "Nella sezione 2.3, incontriamo anche alcuni algoritmi che utilizzano il tipo di loop invariante più output.
2.1
Colorare il piano
Vedi Figura 2.1.
1) Specificazioni: un'istanza di input è costituita da un insieme di linee N (in modo infinitamente lungo).
Queste linee formano una suddivisione del piano, cioè, diviso il piano in a
Numero finito di regioni (alcune delle quali illimitate).L'output è costituito da una colorazione di ciascuna regione con nero o nero in modo che due regioni con un comune
Il confine ha colori diversi.Un algoritmo per questo problema dimostra il teorema
che tale colorazione esiste per tale suddivisione del piano.
2) Passaggi di base: quando un'istanza è costituita da un insieme di oggetti, una tecnica comune
è considerarli uno alla volta, risolvendo in modo incrementale il problema per quegli oggetti
considerato finora.
3) Misura del progresso: la misura del progresso è il numero di linee, i, quella
sono stati considerati.
4) Il ciclo invariante: abbiamo considerato le prime linee.C è una colorazione adeguata
del piano suddiviso da queste linee.

---
layout: 
title: Pagina 46
level: 3
---


Algoritmi iterativi e invarianti ad anello
30
Figura 2.1: un esempio di colorazione del piano.
5) Passaggi principali: abbiamo una colorazione corretta C per le prime linee.Line I + 1 taglia il
Aereo a metà, tagliando molte regioni a metà.Ognuna di queste metà ha bisogno di un diverso
colore.Quindi quando cambiamo il colore di una regione, i suoi vicini devono cambiare colore
pure.Lo realizzeremo mantenendo tutti i colori su un lato di Linei + 1 lo stesso
e fluttuando quelli dall'altra parte dal bianco al nero e dal nero al bianco.
6) Fai progressi: ogni iterazione aumenta i di uno.
7) Mantieni invariante loop: ⟨loop-invariant ′⟩ & not⟨exit-confid⟩ & codeLoop ⇒⟨loopinvariant ′ ′⟩.Dobbiamo controllare ogni limite per assicurarci che le regioni su entrambi
il lato ha colori opposti.I confini formati da una delle prime linee avevano l'opposto
colori prima del cambiamento.I colori delle regioni su entrambi i lati non erano né
fluoted o entrambi fluttuati.Quindi, hanno ancora colori opposti.Confini formati da
La linea I + 1 aveva gli stessi colori prima del cambiamento.Uno di questi colori è stato fluito, il
Altro no.Quindi, ora hanno colori opposti.
8) Stabilire il loop invariante: ⟨pre-Cond⟩ & CodePre−
looporto ⟨⟩-invariante⟩.
Con i = 0 linee, il piano è tutto una regione.La colorazione che rende l'intero piano
White Works.
9) Condizione di uscita: uscita quando tutte le linee N sono state considerate, cioè i = n.
10) finale: ⟨loop-invariante⟩ & ⟨exit-cond⟩ & codepost-loop ⇒⟨post-cond⟩).Se C è un
Colorazione adeguata data le prime linee e i = n, quindi chiaramente C è una colorazione adeguata
Date tutte le linee.
11) Termine e tempo di esecuzione: chiaramente, sono necessarie solo n iterazioni.
12) Casi speciali: non ci sono casi speciali che dobbiamo considerare.
13) Dettagli di codifica e implementazione:
ALGORITHM PLAGLINGA DELL'ALGORITMA (LINE)
⟨Pre-Cond⟩: linee specifiche (in finzione) linee.
⟨Post-Cond⟩: C è una colorazione corretta del piano suddiviso dalle linee.

---
layout: 
title: Pagina 47
level: 3
---


Esempi che utilizzano invarianti ad anello più
31
inizio
C = "La colorazione che colora l'intero piano bianco."
i = 0
ciclo continuo
⟨Loop-invariant⟩: c è una colorazione adeguata del piano suddiviso
dalle prime linee.
uscita quando (i = n)
% Fa progressi mantenendo l'invariante in loop
La linea I + 1 taglia il piano a metà.
Con una metà, la nuova colorazione C ′ è uguale a quella vecchia C.
Dall'altra metà, la nuova colorazione C ′ è la stessa della vecchia C, tranne che il bianco è passato da nero e nero a bianco.
i = i + 1 & c = c ′
End Loop
restituzione (c)
Algoritmo di fine
2.2
Automate deterministico finito
Una grande classe di problemi che possono essere risolti usando un algoritmo iterativo con il
L'aiuto di un ciclo invariante è la classe di lingue regolari.Potresti averlo imparato
Questa è la classe di lingue che possono essere decise da un automoto ﬁ nito deterministico
(DFA) o descritto usando un'espressione regolare.
Applicazioni: questa classe è utile per la modellazione
r semplici algoritmi iterativi
r semplici dispositivi meccanici o elettronici come elevatori e calcolatori
R semplici processi come la coda di lavoro di un sistema operativo
R semplici motivi all'interno delle stringhe di personaggi.
Caratteristiche: tutte queste hanno le seguenti caratteristiche simili.
Stream di input: ricevono un flusso di informazioni a cui devono reagire.
Ad esempio, il flusso di input per un semplice algoritmo è costituito dai caratteri
leggere dall'input;Per un calcolatore, è la sequenza di pulsanti premuti;per il lavoro
coda, è il flusso di lavori in arrivo;e per il modello all'interno di una stringa, uno
Scansiona la stringa una volta da sinistra a destra.
Input di lettura: una volta arrivato un token delle informazioni, non può essere richiesto.
Memoria limitata: l'algoritmo, il dispositivo, il processo o il pattern matcher ha una memoria limitata con cui ricordare le informazioni che hanno visto finora.

---
layout: 
title: Pagina 48
level: 3
---


Algoritmi iterativi e invarianti ad anello
32
Sebbene la quantità di memoria possa essere qualsiasi importo fisso, tale importo non può
Cresci anche se l'istanza di input diventa davvero grande.
Esempio 2.2.1
Un semplice DFA
1) Specifiche: data una stringa α come istanza di input, determinare se è contenuta nel set (lingua)
L = {α ∈ {0, 1} ∗ |α ha la lunghezza al massimo tre e il numero di 1 è dispari}
Nella maggior parte, ma non a tutti, DFA, l'attività del calcolo è di accettare o rifiutare l'input.
2) Passaggi di base: i caratteri dell'istanza di input vengono letti uno alla volta.Perché
Il calcolo non sarà mai più in grado di leggere un personaggio, deve ricordare cosa
Ha bisogno di ciò che ha letto finora.
3) Misura del progresso: la misura del progresso è il numero di caratteri letti così
lontano.
4) Il ciclo invariante: ω denotare il prefisso dell'istanza di input letta finora.IL
Loop Invariant afferma quali informazioni sono ricordate al riguardo.La sua lunghezza e il numero di lettura 1 finora non possono essere ricordati con una quantità limitata di memoria, perché questi conteggi crescerebbero arbitrariamente grandi dove l'istanza di input per crescere arbitrariamente a lungo.Fortunatamente, la lingua si preoccupa solo di questa lunghezza fino a tre e
Se il numero di 1 è uniforme o strano.Questo può essere accumulato con due variabili: lunghezza, l ∈ {0, 1, 2, 3, più} e parità, r ∈ {anche, dispari}.Questo richiede solo un fisso
quantità di memoria.
5) Passaggi principali: leggi un carattere e aggiorna ciò che sappiamo sul pre -ﬁ x.
6) Fai progressi: il progresso aumenta perché il numero di caratteri letti finora
aumenta di uno.
7) Mantenimento dell'invariante in loop: dopo aver letto un altro carattere C, le letture pre -file
ora è ωc.Sappiamo che la lunghezza di ωc è una più di quella di ω e che il numero
di 1 è un altro mod 2 o lo stesso, a seconda che il nuovo
Il carattere C è un 1.
8) Stabilire l'invariante in loop: all'inizio del calcolo, il prefisso
Questo è stato letto finora è la stringa vuota ω = ϵ, la cui lunghezza è l = 0, e il numero di 1 è r = pari.
9) Condizione di uscita: usciamo quando è stata letta l'intera istanza di input.
10) finale: quando l'istanza di input è stata completamente letta, la conoscenza che
L'invariante Loop afferma ciò che sappiamo è sufficiente per noi calcolare la risposta finale.
Accettiamo se l'istanza ha la lunghezza al massimo tre e il numero di 1 è strano.
11) Termine e tempo di esecuzione: il numero di iterazioni è chiaramente la lunghezza n
dell'istanza di input.
12) Casi speciali: non ci sono casi speciali che dobbiamo considerare.

---
layout: 
title: Pagina 49
level: 3
---


Esempi che utilizzano invarianti ad anello più
33
13) Dettagli di codifica e implementazione:
Algoritmo DFA ()
⟨Pre-Cond⟩: l'istanza di input α verrà letta in un carattere alla volta.
⟨Post-Cond⟩: l'istanza sarà accettata se ha una lunghezza al massimo tre e il
Il numero di 1 è strano.
inizio
l = 0 e r = anche
ciclo continuo
⟨Loop-Invariant⟩: quando il programma iterativo ha letto in alcuni prefiniti dell'istanza di ingresso α, la memoria limitata della macchina
ricorda la lunghezza l ∈ {0, 1, 2, 3, più} di questo pre -ﬁ x e
Se il numero di 1 in esso è r ∈ {anche, dispari}.
Esci quando la fine dell'input
Ottieni (c)
% Legge il prossimo carattere di input
if (l <4) allora l = l + 1
if (c = 1) allora r = (r + 1) mod 2
End Loop
if (l <4 e r = dispari)
accettare
altro
rifiutare
finisci se
Algoritmo di fine
Compilare meccanicamente un programma iterativo in un DFA: qualsiasi programma iterativo con memoria limitata e un flusso di input può essere compilato meccanicamente
in un DFA che risolve lo stesso problema.Questo fornisce un altro modello o notazione
per comprendere l'algoritmo.Un DFA è specificato da M = ⟨, Q, Δ, S, F⟩.
Alphabet — Precondizione: il preliminare del problema fornisce un alfabeto di caratteri e specifica che qualsiasi stringa di questi caratteri è valida
istanza di input.Questo può essere {a, b}, {a, b ,..., Z}, ASCII o qualsiasi altro set concentrato di
token che il programma può inserire.Nell'esempio 2.2.1, che stiamo continuando, = {0, 1}.
Set di stati, Q - The Loop Invariant: The Loop Invariant afferma quali informazioni
è ricordato sulla lettura pre ﬁ x ω finora.Un modo discreto per indicare questo ciclo
Invariant sta costruendo l'insieme Q di diversi stati che questo programma iterativo ricorda potrebbe trovarsi in cima al ciclo.In questo esempio, questi stati sono q = {q⟨l = 0, r = even⟩, q⟨l = 0, r = odd⟩ ,..., q⟨l = più, r = odd⟩}, perché a ciascuno
punto nel tempo Il calcolo ricorda sia la lunghezza l ∈ {0, 1, 2, 3, più}
e parity r ∈ {anche, dispari} della lettura prefatta.
Ricordiamo che una restrizione che stiamo imponendo su DFAS è che l'importo
della memoria che usano è fisso e non può crescere anche se l'istanza di input

---
layout: 
title: Pagina 50
level: 3
---


Algoritmi iterativi e invarianti ad anello
34
diventa davvero grande.La conseguenza di questo è che il numero | Q |di stati che
Il DFA potrebbe trovarsi è fisso a un numero concreto.
Ogni stato Q ∈Q del DFA specifica un valore per ciascuna delle variabili del programma.Se le variabili sono allocate nei bit di memoria totali di memoria, allora ci sono
| Q |= 2r diversi afferma che queste variabili potrebbero essere. Al contrario, con | Q |
Stati, un DFA può ricordare r = log2 | q |Bit di informazioni.Se l'algoritmo ha
Due variabili, una con | Q1 |stati diversi e uno con | q2 |, quindi l'algoritmo
Può essere in | Q |= | Q1 |× | Q2 |stati diversi.
Nel nostro esempio, | Q |= 5 × 2 = 10.
Assicurati di assegnare nomi significativi agli stati, cioè non Q0, Q1 ,..., Q | Q |, come i
hanno spesso visto.
A volte, quando si stringono l'algoritmo, alcuni di questi stati possono essere
collassato in uno, se non è necessario che l'algoritmo distinguisca tra
loro.Nel nostro esempio, ci sono tre stati che possono essere crollati in un morto
stato da cui è noto la risposta finale per essere rifiutata.Inoltre, lo stato q⟨l = 0, r = odd⟩
dovrebbe essere eliminato perché è impossibile esserci.
Rappresentazione grafica: perché il numero di stati che il calcolo
Potrebbe essere in grado di essere fisso ad un numero concreto, il DFA può essere rappresentato graficamente avendo un nodo per ogni stato:
1
1
1
1
0
0
0
0
0
0
Anche
Strano
Leng 0
Leng 1
0,1
Leng> 3
Leng 3
Leng 2
1
1
morto
0,1
Funzione di transizione Δ: loop invariante invariante: supponiamo che il calcolo
ha letto il prefisso ω ed è in cima al ciclo.Dal ciclo invariante, il DFA lo farà
Ricordare qualcosa su questo pre -ﬁ x ω e un risultato sarà in qualche stato
q ∈q.Dopo aver letto un altro carattere C, la lettura pre -X è ora ωc.Manteniamo
il ciclo invariante mettendo il DFA nello stato Q ′ corrispondente a quello che è
Per ricordare questo nuovo prefisso ωc.Perché il DFA non sa nulla
A proposito dell'attuale pre -ﬁ x Ω diverso dal fatto che è nello stato Q, lo stato successivo
che il DFA sarà in può dipendere solo dal suo stato attuale Q e dal prossimo
Carattere C Leggi.
La funzione di transizione del DFA Δ definisce il modo in cui la macchina passa da
stato a stato.Formalmente, è una funzione Δ: Q × → Q.Se lo stato attuale del DFA lo è
q ∈q e il carattere di input successivo è c ∈, quindi viene dato lo stato successivo del DFA
BYQ ′ = Δ (Q, C).Considera un po 'di statoq ∈Q e un po' di carattere c ∈.Imposta le variabili del programma sui valori corrispondenti a Stateq, assumi il personaggio letto
è C ed eseguire il codice una volta attorno al ciclo.Il nuovo stato Q ′ = Δ (Q, C) del

---
layout: 
title: Pagina 51
level: 3
---


Esempi che utilizzano invarianti ad anello più
35
DFA è definito lo stato corrispondente ai valori delle variabili del programma quando il calcolo ha raggiunto nuovamente la parte superiore del ciclo.
In una rappresentazione grafica di un DFA, per ogni stato Q e carattere C, c'è
Un bordo etichettato C dal nodo Q al nodo Q ′ = Δ (Q, C).
Lo stato di partenza S: stabilimento dell'invariante in loop: lo stato iniziale del DFA M
è lo stato in q corrispondente ai valori iniziali che il programma assegna
Le sue variabili prima di leggere eventuali caratteri di input.Nella rappresentazione del grafico, il
Il nodo corrispondente ha una freccia ad esso.
Accetta gli stati F - INDIENI: Quando l'istanza di input è stata completamente letta, il DFA potrebbe essere in uno degli stati Q ∈q.Perché il DFA non lo sa
qualsiasi cosa sull'istanza di input diversa dal fatto che è nello stato Q, il
Il risultato del calcolo può dipendere solo da questo stato.Se il compito del DFA è
Solo per accettare o rifiutare l'istanza di input, quindi l'insieme di stati Q, deve essere
partizionato in stati di accettazione e rifiuto.Se il DFA è in uno stato di accettazione quando il
L'istanza termina, quindi l'istanza è accettata.Altrimenti, viene respinto.Quando il
DFA è specificato da M = ⟨, Q, Δ, S, F⟩, F indica l'insieme di questi stati di accettazione.
Nella rappresentazione del grafico questi nodi sono indicati da doppi cerchi.
Esempio 2.2.2
Aggiunta
Nell'algoritmo della scuola elementare standard per l'aggiunta, l'input è costituito da due numeri interi X e Y rappresentati come stringhe di cifre.L'output è la somma z, anche rappresentata
come una stringa di cifre.L'input può essere visualizzato come un flusso se l'algoritmo viene dato prima
Le cifre più basse di X e di Y, quindi la seconda più bassa, e così via.L'algoritmo emette i caratteri di Z mentre procede.L'unica memoria richiesta è un solo bit da archiviare
la parte di carry.A causa di queste caratteristiche, l'algoritmo può essere modellato come DFA.
algoritmo aggiungendo ()
⟨Pre-Cond⟩: le cifre di due numeri interi xey vengono letti all'indietro in parallelo.
⟨Post-Cond⟩: le cifre della loro somma verranno eliminate all'indietro.
inizio
allocare carry ∈ {0, 1}
carry = 0
ciclo continuo
⟨Loop-invariant⟩: se sono state lette le cifre I di ordine basso di X e di Y, le cifre I a basso ordine della somma z = x + y sono state emesse.La memoria limitata della macchina ricorda il trasporto.
Esci quando la fine dell'input
get (⟨xi, yi⟩)
s = xi + yi + carry
zi = cifra a basso ordine di s
trasportare = cifra di alto ordine di s
put (zi)

---
layout: 
title: Pagina 52
level: 3
---


Algoritmi iterativi e invarianti ad anello
36
End Loop
if (carry = 1) allora
put (carry)
finisci se
Algoritmo di fine
Il DFA è il seguente.
Set di stati: q = {q⟨carry = 0⟩, q⟨carry = 1⟩}.
Alfabet: = {⟨xi, yi⟩ |xi, yi ∈ [0..9]}.
State di avvio: s = q⟨carry = 0⟩.
Funzione di transizione: Δ (q⟨carry = c⟩, ⟨xi, yi⟩) = ⟨qcarry = c ′, zi⟩
dove c ′ è la cifra di alto ordine e Zi è la cifra di basso ordine di xi + yi + c.
Esempio 2.2.3
Divisione
Dividere un numero intero per sette richiede un algoritmo abbastanza complesso.Sorprendentemente, può essere
fatto da un DFA.L'input è costituito da un numero intero x letto in una cifra alla volta, iniziando
con la cifra di alto ordine.Contemporaneamente, le cifre dell'uscita ⌊x
7 ⌋ sono emessi.In
La fine, il resto è fornito.Prova a calcolare ⌊39591
7
⌋ = 5655. Dopo il pre ﬁ x ω =
395 è stato letto, l'invariante loop afferma che la risposta z = ⌊395
7 ⌋ = 56 è stato
Output e il suo resto r = 395 Mod 7 = 3 ∈ {0, 1 ,..., 6} è stato ricordato.
Quando viene letto il carattere successivo xi = 9, dobbiamo fare lo stesso per ω9 = 3959. il nuovo
la risposta è
z ′ =
3959
7

=
395 × 10 + 9
7

=
395
7

× 7 + r

× 10 + 9
7

=
395
7

× 10 +
R × 10 + 9
7

= Z × 10 +
3 × 10 + 9
7

= 56 × 10 + 5 = 565.
In generale, forr ∈ {0, 1 ,..., 6} e xi ∈ {0, 1 ,..., 9}, il valore zi = ⌊r × 10+xi
7
⌋ È una singola cifra facile da calcolare.Questo dà che z ′ come stringa è z concatenata con questo
Nuova cifra zi.Dato che Z è già stato eliminato, ciò che rimane è quello di produrre ZI.Allo stesso modo, il nuovo resto r ′ = 3959 mod 7 = (395 × 10 + 9) mod 7 = ((395 mod 7) ×
10 + (9 mod 7)) mod 7 = ((3) × 10 + (2)) mod 7 = 32 mod 7 = 4. più in generale, r ′ =
R × 10 + C Mod 7. Inizialmente, la lettura prefistica finora è la stringa vuota ω che rappresenta 0, dando z = ⌊0
7⌋ = 0 = stringa vuota e r = 0 mod 7 = 0. Alla fine, z = ⌊x
7 ⌋has è stato
Output e ciò che rimane è quello di produrre il resto r.Il DFA per calcolare questo
avrà sette stati Q0 ,..., Q6.La funzione di transizione è Δ (QR, C) = Q⟨R · 10+C Mod 7⟩.
Esempio 2.2.4
Calcolatrice
Gli invarianti possono essere utilizzati per comprendere un sistema informatico che, invece di semplicemente calcolare una funzione, continuano a prendere input e produrre output.In

---
layout: 
title: Pagina 53
level: 3
---


Esempi che utilizzano invarianti ad anello più
37
La nostra semplice calcolatrice, i tasti sono limitati a = {0, 1, 2 ,..., 9, +, Clr}.Puoi entrare
un numero.Mentre lo fai, appare sullo schermo.Il tasto + aggiunge il numero su
Schermo sulla somma accumulata e visualizza la somma sullo schermo.Il tasto CLR ripristina sia lo schermo che l'accumulatore a zero.La macchina può solo archiviare positivo
Integri da zero a 99999999. Le aggiunte sono eseguite Mod 108.
Set di stati: q = {q⟨acc, cur, scr⟩ |ACC, CUR ∈ {0..108 −1} e scr ∈ {showa, showc}}.
Ci sono stati 108 × 108 × 2 in questo set, quindi non vorresti disegnare il
diagramma.
Alphabet: = {0, 1, 2 ,..., 9, +, Clr}.
State State: S = Q⟨0,0, showc⟩.
Funzione di transizione:
r per c ∈ {0..9}, Δ (q⟨acc, cur, scr⟩, c) = q⟨acc, 10 × cur+c, showc⟩.
R Δ (Q⟨ACC, CUR, SCR⟩, +) = Q⟨ACC +CUR, CUR, SHOWA⟩.
R Δ (Q⟨ACC, CUR, Scr⟩, Clr) = Q⟨0,0, showc⟩.
Esempio 2.2.5
Blocco più lungo di quelli
Supponiamo che l'input sia costituito da una sequenza A [1..n] di zeri e di quelli, e vogliamo
per trovare un blocco contiguo più lungo a [p, q] di quelli.Ad esempio, sull'input A [1..n] =
[1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0], il blocco A [5..7] di lunghezza 3 è una soluzione adatta e
Così è il blocco A [10..12].Ecco alcune cose che dobbiamo considerare quando progettiamo il
Loop invariant.
Memoria non finita: sia la dimensione del blocco più lungo che gli indici del suo inizio
e la fine sono numeri interi in [1..n].Questi richiedono bit (logn) da ricordare.Quindi, questo
L'algoritmo non sarà un automobile ﬁ nito deterministico.
Ricorda la soluzione per il prefisso: dopo aver letto il pre -ﬁ x a [1..i], è chiaro che
Devi ricordare il blocco più lungo.È abbastanza per un ciclo invariante?Come
Mantieni questo ciclo invariante quando leggi solo nel personaggio successivo
A [i + 1]?Ad esempio, se a [1..i] = [0, 1, 1, 0, 0, 1, 1], allora l'invariante del loop può darci
Solo il blocco A [2..3] di lunghezza 2. Quindi se leggiamo un [i + 1] = 1, allora il blocco più lungo di
A [1..I + 1] = [0, 1, 1, 0, 0, 1, 1, 1] diventa un [6..8] di lunghezza 3. Come farebbe il tuo programma
Conosci questo blocco?
Ricorda il blocco corrente più lungo: devi anche tenere un puntatore all'inizio
del blocco attuale su cui si lavora, cioè il più lungo che termina nel valore a [i] e
la sua taglia.Con questo l'algoritmo può sapere se la corrente aumenta contigua
La successione diventa più lunga della precedente.Questo deve essere incluso nel
Loop invariant.
Mantenimento dell'invariante in loop: se hai queste informazioni su un [1..I], allora tu
può impararlo su un [1..I + 1] come segue.Se a [i + 1] = 1, allora il blocco più lungo di quelli
La fine del valore corrente aumenta di lunghezza di uno.Altrimenti, si riduce all'essere

---
layout: 
title: Pagina 54
level: 3
---


Algoritmi iterativi e invarianti ad anello
38
la stringa vuota.Se questo blocco aumenta per essere più lungo del nostro precedente più lungo, allora
Sostituisce il precedente più lungo.Alla fine, conosciamo il blocco più lungo di quelli.
Blocchi vuoti: A [3..3] è un blocco di lunghezza 1 e un [4..3] è un blocco di lunghezza zero che termina in un [3].Ecco perché inizialmente, con i = 0, i blocchi sono impostati su un [1..0] e quando il
Il blocco corrente che termina in un [i + 1] diventa vuoto, è impostato su un [i + 2..i + 1].
Programmazione dinamica: la programmazione dinamica, coperta nel capitolo 18, è molto
Potente tecnica per risolvere i problemi di ottimizzazione.Molti di questi equivalgono a
Leggendo gli elementi dell'istanza di input uno [1..n] uno alla volta e, quando a un [i], salvando la soluzione ottimale per il prefisso A [1..I] e il suo costo.Ciò equivale a un automa determinante non definito.Il problema massimo del blocco di uno è un banale
Esempio di questo.Le soluzioni ai seguenti due problemi e più problemi possono
essere trovato nel capitolo 19.2.
La sottosequenza contigua più lunga in aumento: l'input è costituito da una sequenza
A [1..N] di numeri interi, e vogliamo trovare la successione contigua più lunga a [k1..k2]
in modo tale che gli elementi siano monotonicamente in aumento.Ad esempio, la soluzione ottimale per [5, 3, 1, 3, 7, 9, 8] è [1, 3, 7, 9].
La sottosequenza di aumento più lunga: questo è un problema più difficile.Ancora una volta l'input è costituito da una sequenza A di numeri interi di dimensione n.Tuttavia, ora vogliamo trovare il più lungo
(non necessariamente contiguo) SUSSEZIONE S ⊆ [1..N] in modo tale che gli elementi, nel
L'ordine che appaiono in A, sono monotonicamente in aumento.Ad esempio, un ottimale
La soluzione per [5, 1, 5, 7, 2, 4, 9, 8] è [1, 5, 7, 9], e così è [1, 2, 4, 8].
Esercizio 2.2.1 (vedere la soluzione nella parte cinque.) Fornire il codice per questi esempi:
1.
Dividere
2.
Calcolatrice
3.
Blocco più lungo di quelli
Esercizio 2.2.2 Per il blocco più lungo di quelli, cosa sono, q, Δ, s e f?
Esercizio 2.2.3
Per ciascuno dei seguenti esempi, dare il codice e dare
Il DFA o, se necessario, fornisce un automa determinante non finito come fatto nell'esempio 2.2.5.
1.
L = {0n1n |n ≥0} = {α ∈ {0, 1} ∗ |α ha zero o più zeri seguiti dallo stesso
Numero di quelli}.
2.
L = {α ∈ {0, 1} ∗ |Ogni terzo carattere di α è un 1}.ad esempio, 1010011110110 ∈L, ϵ ∈L, 0 ∈L e 100 ̸∈L.
3.
Lor = {α ∈ {0, 1} ∗ |α ha la lunghezza al massimo tre o il numero di 1 è dispari}.
4.
L = {α ∈ {0, 1} ∗ |α contiene la sottostringa 0101}.Ad esempio, α = 1110101101 ∈
L, poiché contiene la sottostringa, vale a dire α = 111 0101 101.

---
layout: 
title: Pagina 55
level: 3
---


Esempi che utilizzano invarianti ad anello più
39
2.3
Più di input vs. più dell'output
A volte non è chiaro al primo posto se utilizzare invarianti più di input o più di teatro.Questa sezione fornisce due problemi simili, di cui il primo
Funziona meglio per l'uno e in cui il secondo funziona meglio per l'altro.
Esempio 2.3.1
Torneo
Un torneo è un grafico diretto (vedere la sezione 3.1) formata prendendo il grafico non indiretto completo e assegnando direzioni arbitrarie ai bordi, ovvero un grafico G = (V, E)
tale che per ogni u, v ∈V, esattamente uno di ⟨u, v ⟩or ⟨v, U⟩is in E. un percorso hamiltoniano
è un percorso attraverso un grafico che può iniziare e finire ovunque ma deve visitare ogni nodo
esattamente una volta ciascuno.Progetta un algoritmo che, dato qualsiasi torneo, trova un percorso hamiltoniano attraverso di esso.Perché trova un percorso hamiltoniano per qualsiasi torneo, questo
L'algoritmo, di per sé, agisce come prova che ogni torneo ha un percorso hamiltoniano.
Più output: è naturale voler spingere in avanti e trovare il percorso richiesto
attraverso un grafico.La misura del progresso sarebbe l'importo del percorso superato
E l'invariante in loop direbbe "Ho i primi nodi (o bordi) nel percorso finale".
Mantenere questo ciclo invariante richiederebbe di estendere il percorso costruito finora
Un altro nodo.Il problema, tuttavia, è che l'algoritmo potrebbe rimanere bloccato quando il
Il percorso costruito finora non ha bordi dall'ultimo nodo a un nodo che non è ancora stato
visitato.Questo rende il ciclo invariante come falso indicato.
Backtracking ricorsivo: uno è quindi tentato di avere l'algoritmo Backtrack quando
Si blocca, provando una direzione diversa per il percorso.Ciò si traduce in un algoritmo finale.Vedere gli algoritmi di backtracking ricorsivi nel capitolo 17. Tuttavia, a meno che uno non lo sia
Molto attento, tali algoritmi tendono a richiedere tempo esponenziale.
Più dell'input: invece, prova a risolvere questo problema utilizzando un ciclo più di input
invariante.Supponiamo che i nodi siano numerati da 1 a N in modo arbitrario.L'algoritmo
Finge temporaneamente che il sottografo sul primo I dei nodi sia l'intero input
esempio.L'invariante in loop è "Attualmente ho una soluzione per questa sottoinstabilità".Come
Una soluzione è un percorso hamiltoniano U1 ,..., UI che visita esattamente ciascuno dei primi nodi
Una volta e quella stessa è semplicemente una permutazione i primi nodi.Mantenere questo ciclo
Invariant richiede la costruzione di un percorso per i nodi FIRSTI + 1.Non è necessario
che questo nuovo percorso assomiglia al percorso precedente.Per questo problema, tuttavia, può essere
realizzato trovando un posto per inserire il nodo I + 1 ° all'interno della permutazione di
I primi nodi.In questo modo, l'algoritmo assomiglia molto a un tipo di inserimento.
Analisi del caso: quando si sviluppa un algoritmo, una buona tecnica è vedere per cui
istanze di input La cosa ovvia e poi prova a progettare un altro algoritmo per
I casi rimanenti:
UI
vi+1
(C)
2
u
U1
io
(UN)
3
2
u
u
U1
u
v
1
u
u
2
3
io
u
I+1
J+1
J
u
u
vi+1
(B)
u

---
layout: 
title: Pagina 56
level: 3
---


Algoritmi iterativi e invarianti ad anello
40
(a) Se ⟨vi+1, u1⟩ è un bordo, allora il percorso esteso è facilmente vi+1, u1 ,..., ui.
(b) Allo stesso modo, se ⟨ui, vi+1⟩ è un bordo, allora il percorso esteso è facilmente u1 ,..., UI, VI+1.
(c) Altrimenti, perché il grafico è un torneo, entrambi ⟨u1, vi+1⟩ e ⟨vi+1, ui⟩are
bordi.Colora ogni nodo uj rosso se ⟨uj, vi+1⟩ è un bordo e blu se ⟨vi+1, uj⟩is.Perché
U1 è rosso e l'interfaccia utente è blu, ci deve essere un posto Uj a Uj+I nel percorso in cui cambia
Colore dal rosso al blu.Perché entrambi ⟨uj, vi+1⟩and ⟨vi+1, uj+i⟩are bordi, possiamo formare
Il percorso esteso U1 ,..., uj, vi+1, uj+i ,..., ui.
Esempio 2.3.2
Ciclo di eulero
Un ciclo euleriano in un grafico non orientato è un ciclo che passa attraverso ogni bordo esattamente una volta.Un grafico contiene un ciclo euleriano Iff è collegato e il grado di ciascuno
Il vertice è pari.Dato un tale grafico, trova un tale ciclo.
Più output: inizieremo di nuovo tentando di risolvere il problema usando
La tecnica più e-output, vale a dire, inizia da qualsiasi nodo e costruisci il percorso di output
un bordo alla volta.Non avere alcuna visione reale di quale bordo dovrebbe essere preso in seguito, li sceglieremo in modo cieco o avido (vedi capitolo 16).L'anda invariante è
che dopo i passi hai qualche percorso attraverso i bordi diversi da alcuni nodi a
un po 'di nodo v.
Resta bloccato: il prossimo passo nella progettazione di questo algoritmo è determinare quando, se
mai, questo semplice algoritmo cieco rimane bloccato, e per far fronte a come evitarlo
situazione o per risolverla.
Fare progressi: se S ̸ = V, allora il nodo finale V deve essere adiacente a un numero dispari
di bordi che sono sul percorso.Vedere la Figura 2.2.A.Questo perché c'è l'ultimo vantaggio
Nel percorso e per ogni bordo del percorso che entra nel nodo c'è uno in partenza.
Quindi, poiché V ha anche un grado, ne consegue che V è adiacente ad almeno un bordo
non è nel percorso.Segui questo bordo, estendendo il percorso di un bordo.Questo mantiene il
Loop invariant mentre fa progressi.Questo processo può rimanere bloccato solo quando il percorso
succede di tornare al nodo iniziale, dando s = v. In tal caso, unisciti al percorso
Qui per formare un ciclo.
Fine: se il ciclo creato copre tutti i bordi, allora abbiamo finito.
Sbrontore: se il ciclo che abbiamo creato dal nostro nodo prescelto è tornato a S lo fa
non coprire tutti i bordi, quindi cerchiamo un nodo u in questo ciclo adiacente a
un bordo non nel ciclo.Vedere la Figura 2.2.b.Cambia S per essere questo nuovo nodo u.Rompiamo il
Cycle a U, dandoci un percorso da te a te.La differenza con questo percorso è che possiamo
estenderlo oltre U lungo il bordo non visitato.Ancora una volta l'invariante del ciclo è stato mantenuto
mentre fa progressi.
S
v
u = nuovo s
(B)
(UN)
v
S
Figura 2.2: percorso costruito finora da
l'algoritmo Eulero all'interno dell'umore
grafico.

---
layout: 
title: Pagina 57
level: 3
---


Esempi che utilizzano invarianti ad anello più
41
esiste: l'unica cosa che rimane da dimostrare è che quando v arriva per incontrare s
Ancora una volta e non abbiamo finito, quindi c'è in realtà un nodo U nel percorso adiacente a
un bordo non nel percorso.Perché non abbiamo finito, c'è un bordo e nel grafico che
non è nel nostro cammino.Poiché il grafico è collegato, deve esserci un percorso nel grafico
da E al nostro percorso costruito.Il nodo u in cui questo percorso di collegamento incontra il nostro
Il percorso costruito deve essere come richiesto, perché l'ultimo vantaggio {u, w} nella connessione
Il percorso non è nel nostro percorso costruito.
Loop invariante esteso: per evitare di dover trovare un tale nodo u quando è necessario, estendiamo il ciclo invariante per affermare che oltre al percorso, l'algoritmo ricorda un nodo U diverso da S e V che è nel percorso ed èadiacente a un bordo no
nel percorso.
Esercizio 2.3.1 (vedi soluzione nella parte quinta.) Taglie di torta iterativa: il famoso algoritmo per tagliare abbastanza una torta in due è per una persona di tagliare la torta nel posto
Crede che sia metà e per l'altra persona scegliere quale "metà" gli piace.Un giocatore
può valorizzare la glassa e mentre l'altra è di più la torta, ma non importa.Il secondo giocatore è garantito per ottenere un pezzo che considera vale almeno la metà, perché sceglie tra due pezzi il cui valore di somma per lui è almeno uno.Poiché la prima persona lo ha tagliato a metà secondo i suoi criteri, è felice
mai il pezzo è rimasto per lui.Il nostro obiettivo è scrivere un algoritmo iterativo che risolve lo stesso
problema per n giocatori.
Per semplificare la nostra vita, consideriamo una torta non come una cosa tridimensionale, ma come la
linea da zero a uno.Diversi giocatori apprezzano diversi sottointervalli della torta in modo diverso.Per esprimere questo, ogni giocatore assegna un valore numerico a ciascun sottointervallo.
Ad esempio, se il nome del giocatore PI è scritto sul sottointervallo [I - 1
2n, i
2n] di torta, poi lui
potrebbe allocare un valore più elevato ad esso, diciamo 1
2. L'unico requisito è che il valore totale
della torta è una.
Il tuo algoritmo è consentito solo le seguenti due operazioni.In una valutazione
query, v = eval (p, [a, b]), l'algoritmo chiede a un giocatore p quanto (v) apprezza a
subtervallo particolare [a, b] dell'intera torta [0, 1].In una query di taglio, b = taglio (p, a, v), il protocollo chiede al giocatore p di identificare il sottointervallo più breve [a, b], a partire da A
Dato l'endpoint sinistro a, con un dato valore v. Nell'esempio sopra, valuta (PI, [I - 1
2n, i
2n])
Restituisce 1
2 e taglio (pi, i - 1
2n, 1
2) restituzioni
io
2n.Usando questi, l'algoritmo a due giocatori è come
segue:
Algoritm Partition2 ({p1, p2}, [a, b])
⟨Pre-Cond⟩: P1 e P2 sono giocatori.
[A, B] ⊆ [0, 1] è un sottointervallo dell'intera torta.
⟨Post-Cond⟩: restituisce un partizionamento di [a, b] in due pezzi disgiunti [a1, b1] e
[A2, B2] in modo che il giocatore PI valori [AI, BI] almeno la metà di lui valori [a, b].
inizio
v1 = valuta (p1, [a, b])
c = taglio (p1, a, v1
2)

---
layout: 
title: Pagina 58
level: 3
---


Algoritmi iterativi e invarianti ad anello
42
if (valuta (p2, [a, c]) ≤val (p2, [c, b])) quindi
[A1, B1] = [A, C] e [A2, B2] = [C, B]
altro
[A1, B1] = [C, B] e [A2, B2] = [A, C]
finisci se
restituzione ([A1, B1] e [A2, B2])
Algoritmo di fine
Il problema che devi risolvere è il seguente:
Partizione algoritmo (N, P)
⟨Pre-Cond⟩: P è un insieme di n giocatori.
Ogni giocatore in P apprezza l'intera torta [0, 1] di almeno 1.
⟨Post-Cond⟩: restituisce un partizionamento di [0, 1] in n pezzi disgiunti [ai, bi] in modo che
Per ogni i ∈p, il giocatore PI valori [ai, bi] di almeno 1
N.
inizio
...
Algoritmo di fine
1.
Puoi tagliare n pezzi di torta, ciascuno di dimensioni rigorosamente più grande di 1
n, e avere una torta
rimasto?A volte è possibile aver assegnato un pezzo disgiunta per ogni giocatore, ciascuno vale molto più di 1
n, al giocatore ricevente, e per essere ancora una torta
Sinistra?Spiegare.
2.
Come grande suggerimento per la progettazione di un algoritmo iterativo, ti dirò qual è la prima iterazione.(Iterazioni successive possono fare cose leggermente modificate.) Ogni giocatore
specifica dove avrebbe tagliato se avesse tagliato la prima frazione 1
n del [a, b]
torta.Il giocatore che desidera la quantità minore di questa prima parte della torta
Dato questo pezzo di torta.Il codice per questo è il seguente:
Loop i ∈P
ci = taglio (pi, 0, 1
N)
End Loop
imin = i ∈p che minimizza ci
[Aimin, Bimin] = [0, Cimin]
Come il tuo primo passo nella progettazione dell'algoritmo, qual è il tuo ciclo invariante?Dovrebbe
includere:
(a) Come è stata tagliata la torta finora
(b) a chi è stata data la torta e come si sente al riguardo
(c) Come si sentono i giocatori rimanenti riguardo alla torta rimanente.
3.
Dai lo pseudocodice iterativo.
4.
Dimostra formalmente che è stabilito l'invariante in loop.
5.
Dimostra formalmente che il ciclo invariante è mantenuto.
6.
Dimostra formalmente che è stabilita la postconditazione.
7.
Qual è il tempo di esecuzione di questo algoritmo?
8.
È questo invariante più di input o invariante più output?

---
layout: 
title: Pagina 59
level: 3
---


43
3 tipi di dati astratti
I tipi di dati astratti (ADT) forniscono sia una lingua di cui parlare e strumenti per
Operando su strutture di dati complesse.Ognuno è definito dai tipi di oggetti che esso
può archiviare e le operazioni che possono essere eseguite.A differenza di una funzione che prende un
Input e produce un output, un ADT è più dinamico, ricevendo periodicamente informazioni e comandi a cui deve reagire in un modo che riflette la sua cronologia.In un
linguaggio orientato agli oggetti, questi sono implementati con oggetti, ognuno dei quali ha
possedere variabili e operazioni interne.Un utente di un ADT non ha accesso al proprio interno
struttura tranne attraverso le operazioni fornite.Questo è indicato come informazione
Nascondere e fornire un confine pulito tra l'utente e l'ADT.Una persona
può usare l'ADT per sviluppare altri algoritmi senza preoccuparsi di come esso
è implementato o preoccupato di incastrare accidentalmente la struttura dei dati.Un altro può implementare e modificare l'ADT senza sapere come viene utilizzato o preoccupato di effetti imprevisti sul resto del codice.Un ADT generale, non solo
Il codice, ma anche la comprensione e la teoria matematica: possono essere riutilizzati in
Molte applicazioni.Avere un insieme limitato di operazioni operative per l'implementatore da utilizzare
Le tecniche che sono efficienti per queste operazioni possono essere lente per le operazioni
escluso.Al contrario, usando un ADT come uno stack nel tuo algoritmo automaticamente
Dice a qualcuno che tenta di comprendere molto il tuo algoritmo sullo scopo di questa struttura di dati.Generalmente, il tempo di esecuzione di un'operazione non fa parte
della descrizione di un ADT, ma è legato a una particolare implementazione.Tuttavia, esso
è utile per l'utente conoscere la spesa relativa dell'uso delle operazioni in modo che possa
Fai le sue scelte su quali ADT e quali operazioni utilizzare.
Questo capitolo tratterà i seguenti ADT: elenchi, stack, code, code prioritarie, grafici, alberi e set.Dal punto di vista dell'utente, sono costituiti da una struttura di dati
e una serie di operazioni con cui accedere ai dati.Dal punto di vista del
Struttura dei dati stessa, è un sistema in corso che continua a ricevere un flusso di comandi a cui deve reagire in modo dinamico.Gli ADT hanno una serie di invarianti o integrità
vincoli (sia pubblici che nascosti) che devono essere veri ogni volta che il sistema viene inserito o lasciato.Immaginare un grande ciclo attorno al sistema ci consente di considerarli come a
tipo di loop invariante.

---
layout: 
title: Pagina 60
level: 3
---


Algoritmi iterativi e invarianti ad anello
44
3.1
Specifiche e suggerimenti alle implementazioni
I seguenti sono esempi di ADT usati frequentemente.
Tipi semplici: numeri interi, numeri di punta, stringhe, array e record sono tipi di dati astratti forniti da tutti i linguaggi di programmazione.
L'elenco ADT:
Specifica: un elenco è costituito da una sequenza ordinata di elementi.A differenza degli array, non contengono posizioni vuote.Gli elementi possono essere inseriti, eliminati, letti, modificati e cercati.
Implementazioni di array: ci sono diverse implementazioni che hanno compromesso
Nel tempo di esecuzione, i requisiti di memoria e la difficoltà dell'implementazione.IL
L'ovvia implementazione di un elenco è quella di mettere gli elementi in un array.Se gli elementi
sono imballati uno dopo l'altro, quindi è possibile accedere all'elemento Ith in (1)
tempo, ma l'inserimento o l'eliminazione di un elemento richiede un tempo (n) perché tutti gli elementi devono essere spostati.In alternativa, gli spazi vuoti potrebbero essere lasciati tra il
elementi.Questo lascia spazio per inserire o eliminare elementi in (1) tempo, ma scoprire
L'elemento potrebbe ora richiedere (n) tempo.
Implementazioni di elenchi collegati: un problema con l'implementazione dell'array è quello
L'array deve essere assegnato una dimensione fissa di memoria quando inizializzato.UN
L'implementazione alternativa, che può essere ampliata o ridotta di dimensioni secondo necessità, utilizza un elenco collegato.Questa attuazione ha lo svantaggio di richiedere (n)
tempo per accedere a un elemento particolare.Vedere la Sezione 3.2.
Implementazioni degli alberi: un buon equilibrio tra i vantaggi dell'array e il
Le implementazioni di elenchi collegate è una struttura di dati chiamata heap.I cumuli possono fare ogni
operazione in tempo (logn).Vedere la Sezione 10.4.ADELSON-VELSKY-LANDIS (AVL)
E gli alberi rossi -neri hanno proprietà simili.
Lo stack ADT:
Specifica: uno stack ADT è uguale a un elenco ADT, tranne le sue operazioni
limitato.È analogo a una pila di piastre.Una spinta è il funzionamento dell'aggiunta di un
Nuovo elemento nella parte superiore dello stack.Un pop è il funzionamento della rimozione della parte superiore
Elemento dallo stack.Il resto dello stack è nascosto alla vista.Questo ordine è
indicato come ultimo in, primo fuori (LIFO).
Usa: gli stack sono la struttura dei dati chiave per la ricorsione e l'analisi.Avere le operazioni limitate significa che tutte le operazioni possono implementare facilmente ed essere eseguite in tempo costante.

---
layout: 
title: Pagina 61
level: 3
---


Tipi di dati astratti
45
Implementazione dell'array: gli invarianti nascosti in un'implementazione dell'array di a
stack sono che gli elementi nello stack sono memorizzati in un array a partire dal
fondo dello stack e che un variabile indicizza la voce dell'array contenente l'elemento superiore.Non è difficile implementare la spinta e il pop in modo che loro
mantenere questi invarianti.Lo stack cresce a destra quando gli elementi vengono spinti
e si restringe a sinistra mentre vengono scoppiati elementi.Per il codice, vedere l'esercizio 3.1.1.
superiore
/
7
2
3
4
5
/
/
/
8
6
1
Implementazione degli elenchi collegati: come con gli elenchi, gli stack sono spesso implementati utilizzando
elenchi collegati.Vedere la Sezione 3.2.
La coda ADT:
Specifica: la coda ADT è anche la stessa di un elenco ADT, tranne con un diverso insieme limitato di operazioni.Una coda è analoga a una line-up per i biglietti per film.
Si è in grado di inserire un elemento nella parte posteriore e rimuovere l'elemento che si trova al
davanti.Questo ordine è per la prima volta in primo luogo (FIFO).
Uso della coda: un sistema operativo avrà una coda di lavori da eseguire e una rete
Hub avrà una coda di pacchetti da trasmettere.Ancora una volta tutte le operazioni possono essere implementate facilmente per funzionare in tempo costante.
Implementazione dell'array:
Provare piccoli passi: se l'elemento anteriore viene sempre memorizzato all'indice 1 del
Array, quindi quando viene rimosso il fronte corrente, tutti gli elementi rimanenti
Dovrebbe spostarsi di uno per prendere il suo posto.Per risparmiare tempo, una volta che un elemento è
Inserito nell'array, non vogliamo spostarlo fino a quando non viene rimosso.L'effetto
è che la parte posteriore si sposta a destra quando arrivano gli elementi e la parte anteriore si sposta a
I destra come elementi vengono rimossi.Usiamo due diverse variabili, davanti e
retro, per indicizzare le loro posizioni.Mentre la coda migra a destra, alla fine
raggiungerà la fine dell'array.Per evitare di rimanere bloccato, tratteremo l'array
Come cerchio, indicizzare il modulo delle dimensioni dell'array.Ciò consente alla coda di farlo
Migrare intorno e intorno mentre gli elementi arrivano e lasciano.
Invarianti nascosti: gli elementi sono archiviati in ordine dall'iscrizione indicizzati
davanti a quel
vettore.
davanti
/
7
/
/
/
8
3
4
5
6
1
2
posteriore

---
layout: 
title: Pagina 62
level: 3
---


Algoritmi iterativi e invarianti ad anello
46
Estremi: si scopre che i casi di una coda completamente vuota e completamente piena sono indistinguibili, perché con entrambi i fronti saranno uno
a sinistra del retro.La soluzione più semplice non è lasciare che la coda diventa completamente
pieno.
Codice: vedere gli esercizi 3.1.2 e 3.1.3.
Implementazione dell'elenco collegato: consultare nuovamente la Sezione 3.2.
La coda prioritaria ADT:
Specifica: una coda prioritaria è ancora analoga a una line-up per i biglietti per film.
Tuttavia, in queste code gli elementi più importanti possono spostarsi
la parte anteriore della linea.Quando si inserisce un elemento, la sua priorità deve essere specificata.
Questa priorità può successivamente essere cambiata.Durante la rimozione, l'elemento con il più alto
La priorità nella coda viene rimossa e restituita.I legami sono rotti arbitrariamente.
Implementazioni degli alberi: cumuli, alberi AVL e alberi rossi -neri possono eseguire ogni operazione in tempo (Log).Vedi sezioni 4.1, 10.2 e 10.4.
Il set ADT:
Specifica: un set è fondamentalmente una borsa all'interno della quale è possibile inserire qualsiasi elemento che
ti piace.È lo stesso di un elenco, tranne per il fatto che gli elementi non possono essere ripetuti o
ordinato.
Implementazione del vettore indicatore: se l'universo di possibili elementi è sufficientemente piccolo, allora una buona struttura di dati è quella di avere un array booleano indicizzato con
Ognuno di questi possibili elementi.Una voce essendo vera indicherà che l'elemento corrispondente è nel set.Tutte le operazioni del set possono essere eseguite in tempo costante, ovvero in un tempo indipendente dal numero di elementi nel set.
Implementazione della tabella di hash: sorprendentemente, anche se l'universo di possibili elementi è in concomitanza, si può fare un trucco simile, usando una struttura di dati chiamata hash
tavolo.Viene scelto una funzione pseudorandom h che mappe possibili elementi del
impostato sulle voci [1, n] nella tabella.È una funzione deterministica in quanto è facile
calcolare e mappare sempre un elemento alla stessa voce.È pseudorandom
in quanto sembra mappare ogni elemento in un luogo casuale.Si spera, tutto il
Gli elementi che si trovano nel set sono inseriti in diverse voci nel tavolo.In questo caso, si può determinare se un elemento è contenuto in
Il set, richiede un elemento arbitrario dal set, determina il numero di elementi nell'insieme, itera attraverso tutti gli elementi e aggiungi ed elimina elementi—
tutto in tempo costante, cioè indipendentemente dal numero di elementi nel set.Se si verificano collisioni, il che significa che due degli elementi impostati vengono mappati sullo stesso
Ingresso, quindi ci sono una serie di possibili metodi per riformularli da qualche parte
altro.

---
layout: 
title: Pagina 63
level: 3
---


Tipi di dati astratti
47
Il sistema set ADT:
Specifica: un sistema di set consente di avere un set (o elenco) di set.Operazioni
Consentire la creazione, unione, l'intersezione, il complemento e la sottrazione degli insiemi.
L'operatore trovare determina quale impostato un determinato elemento è contenuto in.
Vettori di elenco-industrici o implementazioni di tavola hash: un modo per implementarli è avere un elenco di elementi implementati utilizzando un array o un collegato
Elenca dove ciascuno di questi elementi è un'implementazione di un set.Ciò che rimane è
per implementare operazioni che operano su più set.Generalmente, queste operazioni richiedono (N) tempo.
Implementazione del sistema union -find set: un altro risultato abbastanza sorprendente è quello
Sui set disgiunti, le operazioni sindacali e trovano possono essere eseguite in media in una quantità costante di tempo per tutti gli scopi pratici.Vedi la fine di questa sezione.
Il dizionario ADT: un dizionario associa un significato con ogni parola.Allo stesso modo, un dizionario ADT associa i dati a ciascuna chiave.
Grafici:
Specifica: un grafico è un set di nodi con bordi tra di loro.Possono rappresentare reti di strade tra città o amicizie tra le persone.Il tasto
Le informazioni memorizzate sono quali coppie di nodi sono collegate da un bordo.A volte
I dati, come peso, costo o lunghezza, possono essere associati a ciascun bordo o con
ogni nodo.Sebbene un disegno collochi implicitamente ogni nodo in qualche posizione
La pagina, un'astrazione chiave di un grafico è che la posizione di un nodo non è specificata.Le operazioni di base sono determinare se un bordo è in un grafico, da aggiungere
o elimina un bordo e per iterare attraverso i vicini di un nodo.C'è un enorme
Letteratura di operazioni più complesse che si potrebbero voler fare.Ad esempio, si potrebbe voler determinare quali nodi hanno percorsi tra loro o da trovare
Il percorso più breve tra due nodi.Vedi il capitolo 14.
u
u
v
w
v
w
1
1
1
Un elenco di adiacenza
w
v
u
v
u
w
Una matrice di adiacenza
Un grafico
u
v
w
Implementazione della matrice di adiacenza: questo
consiste
Di
un n × n
matrice
con
M (u, v) = 1 se ⟨u, v⟩is un bordo.Richiede (n2) spazio (corrispondente al numero di potenziali bordi) e (1) tempo per accedere a un determinato bordo, ma (n) tempo per trovare
I bordi adiacenti a un determinato nodo e (N2) per iterare attraverso tutti i nodi.
Questo è solo un problema quando il grafico è grande e scarso.

---
layout: 
title: Pagina 64
level: 3
---


Algoritmi iterativi e invarianti ad anello
48
ghepardo
Papà
Gamekeeper
orso
gatto
Gamekeeper
animale
invertebrato
vertebrato
uccello
rettile
serpente
polare
panda
nero
umano
lucertola
mammifero
canino
homosapien
+
y
7
X
\*
F
(UN)
(B)
Figura 3.1: albero di classificazione degli animali e un albero che rappresenta l'espressione f = x × (y + 7).
Implementazione dell'elenco di adiacenza: elenca per ciascun nodo i nodi adiacenti ad esso.
Richiede (e) spazio (corrispondente al numero di bordi effettivi) e può
Iterare rapidamente attraverso i bordi adiacenti a un nodo di dare, ma richiede tempo proporzionale al grado di un nodo per accedere a un bordo specifico.
Alberi:
Specifica: i dati sono spesso organizzati in una gerarchia.Una persona ha figli, che hanno figli propri.Il capo ha persone sotto di lei, che hanno persone
sotto di loro.Il tipo di dati astratti per l'organizzazione di questi dati è un albero.
Usi: esiste un elenco sorprendentemente ampio di applicazioni per gli alberi.Per due esempi
Vedere la Figura 3.1 e la sezione 10.5.
Implementazione del puntatore: gli alberi sono generalmente implementati avendo ciascun nodo
indica ciascuno dei suoi figli:
X
7
y
+
F
\*
Ordini: imporre regole su come è possibile ordinare i nodi accelera determinate operazioni.
Albero di ricerca binaria: un albero di ricerca binaria è una struttura di dati utilizzata per archiviare le chiavi
insieme ai dati associati.I nodi sono ordinati in modo che per ogni nodo, tutti
Le chiavi nella sua sottostruttura sinistra sono più piccole della sua chiave e tutti quelli a destra
La sottostruttura è più grande.Gli elementi possono essere trovati in tale albero, usando la ricerca binaria, in O (altezza) anziché in tempo (n).Vedi le sezioni 4.1 e 10.2.

---
layout: 
title: Pagina 65
level: 3
---


Tipi di dati astratti
49
Cumuli: un heap richiede che la chiave di ciascun nodo sia più grande di quella di
entrambi i suoi figli.Ciò consente di trovare la chiave massima nel tempo di O (1).Tutto
Gli aggiornamenti possono essere eseguiti nel tempo (Log).I cumuli sono utili per un algoritmo di ordinamento noto come heap ordin e per l'implementazione di code prioritarie.
Vedere la Sezione 10.4.
Alberi bilanciati: se un albero binario è bilanciato, ci vuole meno tempo per attraversarlo, perché ha altezza al massimo log2 n.È troppo lavoro per mantenere perfettamente
albero equilibrato man mano che i nodi vengono aggiunti ed eliminati.Ci sono, tuttavia, un numero di
strutture di dati in grado di aggiungere ed eliminare in o (log2 n)
che l'albero rimane quasi equilibrato.Eccone due.
Alberi AVL: ogni nodo ha un fattore di equilibrio di −1, 0 o 1, definito come la differenza tra le altezze dei sottospere sinistra e destra.Man mano che vengono aggiunti i nodi
o cancellato, questa invariante viene mantenuta usando rotazioni come le seguenti (vedi
Esercizio 3.1.5):
[5,10]
10
5
Ruotare
5
10
.., 5]
[10, ..
[5,10]
.., 5]
[10, ..
Alberi rossi -neri: ogni nodo è rosso o nero.Se un nodo è rosso, allora entrambi
I suoi figli sono neri.Ogni percorso dalla radice a una foglia contiene lo stesso
Numero di nodi neri.Vedi Esercizio 3.1.6.
Albero di ricerca binaria equilibrata: immagazzinando gli elementi in un binario equilibrato
L'albero di ricerca, gli inserimenti, le eliminazioni e le ricerche possono essere effettuate in tempo (Log).
Sistema di set Union -Find: questa struttura di dati mantiene una serie di set disgiunti di
elementi.
Operazioni: (1) market (v), che crea un nuovo set contenente l'elemento specificato V;(2) Trova (V), che determina il nome dell'insieme contenente un elemento specificato (ogni set viene dato un nome distinto ma arbitrario);e (3) unione (u, v), che unisce i set contenenti gli elementi specifici U e V.

---
layout: 
title: Pagina 66
level: 3
---


Algoritmi iterativi e invarianti ad anello
50
Utilizzo: un'applicazione di questo è nell'algoritmo di albero minimo
Sezione 16.2.3.
Tempo di esecuzione: in media, per tutti gli scopi pratici, ciascuna di queste operazioni
può essere completato in un tempo costante.Più formalmente, il tempo totale
fare m di queste operazioni su N Elements è (Mα (N)), dove α è l'inverso
La funzione di Ackermann.Questa funzione è così lenta in crescita che anche se n è uguale a
Numero di atomi nell'universo, quindi α (n) ≤4.Vedere la sezione 9.3.
Implementazione: la struttura dei dati utilizzata è un albero radicato per ogni set, contenente
Un nodo per ciascun elemento nel set.La differenza è che ogni nodo indica
il suo genitore invece che per i suoi figli.Il nome del set è il contenuto del
nodo radice.Trova (w) viene realizzato tracciando l'albero da W alla radice u.
L'unione (u, v) viene realizzata facendo in modo che il nodo u punta al nodo v. Da allora in poi, trova (w) per un nodo w nell'albero di u tracepirà e troverà invece V.Ciò che rende
Questo veloce in media è che ogni volta che viene eseguita un'operazione di ricerca, tutti i nodi che sono
Incontrati durante il trovare vengono modificati per puntare direttamente alla radice dell'albero, collassando l'albero in un albero più corto.
F
w
G
e
D
C
UN
v
w
u
B
u
Trova (w) returns v
Unione (u, v)
v
UN
u
w
UN
B
D
e
F
G
C
C
G
F
e
D
B
v
Esercizio 3.1.1 Implementare le operazioni push e pop su uno stack usando un array come
descritto nella Sezione 3.1.
Esercizio 3.1.2 Implementare l'inserto e rimuovere le operazioni su una coda usando un
Array come descritto nella Sezione 3.1.
Esercizio 3.1.3 Quando si lavora con gli array, come nella Sezione 3.1, qual è la differenza
tra "posteriore = (posteriore + 1) mod max" e "posteriore = (mod posteriore max) + 1" e quando
Dovrebbe essere usato ognuno?
Figura: la riga superiore mostra tre famosi
Grafici: il grafico completo su quattro nodi, il
Cube e Peterson Graph.La riga inferiore
mostra gli stessi tre grafici con i loro nodi
disposto diversamente.

---
layout: 
title: Pagina 67
level: 3
---


Tipi di dati astratti
51
Esercizio 3.1.4 Per ciascuna delle tre coppie di grafici, numera i nodi in tale
in questo modo ⟨i, è un bordo in uno se e solo se è un vantaggio nell'altro.
Esercizio 3.1.5 (vedi soluzione nella parte cinque.) Dimostra che l'altezza di un albero AVL con n
I nodi sono (logn).
Esercizio 3.1.6 Dimostrare che l'altezza di un albero rosso -nero con n nodi è (logn).
3.2
Implementazione dell'elenco dei collegamenti
Come detto, un problema con l'implementazione dell'array dell'elenco ADT è che l'array
Deve essere assegnato una certa dimensione fissa della memoria quando viene inizializzata.Una soluzione a
Questo per implementare queste operazioni utilizzando un elenco collegato, che può essere ampliato in
dimensioni se necessario.Questa attuazione è particolarmente efficace quando le operazioni sono
limitato a quelli di uno stack o una coda.
Elenco Specificazione ADT: un elenco è costituito da una sequenza ordinata di elementi.A differenza di
Array, non ha posizioni vuote.Gli elementi possono essere inseriti, eliminati, letti, modificati e cercati.Ci sono compromessi nel tempo di esecuzione.Gli array possono accedere all'Ith
Elemento nel tempo (1), ma richiede (n) il tempo per inserire un elemento.Un elenco collegato è un
Implementazione alternativa in cui la memoria allocata può crescere e ridursi dinamicamente con le esigenze del programma.Gli elenchi collegati consentono inserimenti in (1) tempo, ma richiedono (n) tempo per accedere all'elemento ITH.I cumuli possono fare entrambe le cose in tempo (logn).
informazioni
collegamento
informazioni
collegamento
Primo
collegamento
informazioni
informazioni
collegamento
Invarianti nascosti: in un elenco collegato, ogni nodo contiene le informazioni per un elemento e un puntatore al successivo.La variabile prima indica il primo nodo e ultimo
fino all'ultimo.L'ultimo nodo ha la sua variabile puntatore che contiene il valore zero.Quando l'elenco
Non contiene nodi, prima e ultimo indicano anche zero.
Notazione: un puntatore, come il primo, è una variabile che viene utilizzata per archiviare l'indirizzo
di un blocco di memoria.Le informazioni archiviate nel campo delle informazioni di tale blocco sono
indicato da firs.info in java e prima informazioni in C. adotteremo la prima notazione.Allo stesso modo, il primo sindacale indica il campo puntatore del nodo.Essendo un puntatore stesso, filial.link.info indica le informazioni memorizzate nel secondo nodo dell'elenco collegato e prima.link.link.info nel terzo.
Aggiunta di un nodo alla parte anteriore: dato un elenco ADT e nuove informazioni da archiviare in un elemento, questa operazione è quella di inserire un elemento con queste informazioni nella parte anteriore dell'elenco.

---
layout: 
title: Pagina 68
level: 3
---


Algoritmi iterativi e invarianti ad anello
52
killnode
Primo
scorso
Primo
scorso
Primo
scorso
articolo
articolo
articolo
articolo
articolo
articolo
Primo
scorso
killnode
killnode
scorso
Primo
killnode
scorso
Primo
scorso
killnode
killnode
Primo
scorso
Primo
Primo
scorso
Primo
articolo
temp
scorso
articolo
temp
Primo
scorso
Primo
scorso
Primo
scorso
scorso
Primo
scorso
Primo
scorso
Primo
scorso
Primo
temp
articolo
articolo
temp
temp
articolo
articolo
scorso
Primo
temp
articolo
temp
Figura 3.2: aggiunta e rimozione di un nodo dalla parte anteriore di un elenco collegato.
Caso generale: abbiamo bisogno dei seguenti passaggi (con pseudocodice dato a destra)
Per un elenco collegato a grande e generale.Vedere la Figura 3.2.
r Assegnare spazio per il nuovo nodo.
Nuova temperatura
r memorizzare le informazioni per il nuovo elemento.
temp.info = info
r punta il nuovo nodo nel resto dell'elenco.
temp.link = prima
R Punto prima sul nuovo nodo.
primo = temp
Caso speciale: il caso speciale principale è un elenco vuoto.A volte siamo fortunati e
Il codice scritto per il caso generale funziona anche per tali casi speciali.Inserimento
Un nodo che inizia con il primo che l'ultimo puntando a zero, tutto funziona tranne
Per ultimo.Aggiungi quanto segue in fondo al codice.
R Punto dura il nuovo e unico nodo.
if (ultimo = nil) allora
ultimo = temp
finisci se
Ogni volta che aggiungi codice per gestire un caso speciale, assicurarsi di verificare che i casi gestiti precedentemente vengano gestiti correttamente.
Rimozione del nodo dal fronte: dato un elenco ADT, questa operazione è quella di rimuovere l'elemento nella parte anteriore dell'elenco e restituire le informazioni informazioni memorizzate al suo interno.
Caso generale:
r punta una variabile temporanea killnode a
puntare al nodo da rimuovere.
killnode = prima
r Sposta prima per indicare il secondo nodo.
primo = Finst.Link
r Salva il valore da restituire.
Info = killnode.info
R Dealloca la memoria per il primo nodo.
Killnode gratuito
r restituire il valore.
restituzione (articolo)

---
layout: 
title: Pagina 69
level: 3
---


Tipi di dati astratti
53
Casi speciali: se l'elenco è già vuoto, un nodo non può essere rimosso.L'unica
Altri casi speciali si verificano quando c'è un nodo indicato sia dal primo che da prima e dal primo
scorso.Alla fine del codice, punta per zero, che è corretto per un elenco vuoto.
Tuttavia, gli ultimi punti fermi al nodo che è stato eliminato.Questo può essere risolto da
Aggiunta di quanto segue in fondo al codice:
R l'elenco diventa vuoto.
if (primo = zero) allora
Ultimo = zero
finisci se
Si noti che il valore della prima e ultima modifica.Se il POP di routine trasmette questi parametri per valore, la routine deve essere scritta per consentire che ciò accada.
Test se vuoto: una routine che restituisce se l'elenco è vuoto
vero se primo = zero e falso altrimenti.Non sembra che questa routine faccia molto, ma
Serve due scopi.Nasconde questi dettagli di implementazione dall'utente e da
Chiamare questa routine invece di fare direttamente il test, il codice dell'utente diventa di più
leggibile.Vedi Esercizio 3.2.1.
Aggiunta di nodo alla fine: vedere l'esercizio 3.2.2.
Rimozione del nodo dalla fine: è facile accedere all'ultimo nodo ed eliminarlo, perché
L'ultimo è puntare su di esso.Tuttavia, al fine di mantenere questo invariante, l'ultimo deve essere puntato
al nodo che era stato il secondo a nodo.Ci vuole tempo (n) per scendere
L'elenco dal primo nodo per trovare questo nodo dal secondo a ultimo.Fortunatamente, né stack né
Le code hanno bisogno di questa operazione.Per un'implementazione più rapida, consultare l'esercizio 3.2.3.
Camminando lungo l'elenco collegato: ora supponiamo che gli elementi negli elenchi collegati
sono ordinati dalle informazioni sul campo.Quando viene assegnato un valore informativo, il nostro compito è quello di puntare
Il puntatore successiva al primo elemento nell'elenco con quel valore.Il puntatore prev è
per indicare l'elemento precedente nell'elenco.Questo deve essere salvato, perché se lo è
Necessario, non c'è un puntatore di schiena per eseguire il backup ad esso.Se un tale elemento non esiste, allora Prev e Next sono di sandwich la posizione in cui questo elemento andrebbe.Per
Esempio, se newelment aveva il valore 6 o il valore 8, il risultato della ricerca
sarebbe
= 6 o 8
prev
Prossimo
scorso
Primo
9
8
4
3
newelment
r camminando lungo l'elenco
ciclo continuo
r mantenendo i due suggerimenti
⟨Loop-inv⟩: prev e punto successivo a
nodi consecutivi prima o at
la nostra posizione desiderata.

---
layout: 
title: Pagina 70
level: 3
---


Algoritmi iterativi e invarianti ad anello
54
r fino a trovare la posizione desiderata
Esci quando successiva = zero
o Next.info ≥newlement
r indica prev dove il prossimo è puntato
Prev = Next
r e puntando accanto al nodo successivo.
Next = Next.Link
End Loop
Tempo di esecuzione: questo può richiedere tempo O (n), dove n è la lunghezza dell'elenco.
Inizializza la passeggiata: per stabilire inizialmente il loop invariante, la prev e il prossimo devono
sandwich la posizione prima del primo nodo.Lo facciamo come segue:
scorso
Primo
9
8
4
3
prev
Prossimo
r sandwich la posizione prima della prima
nodo.
prev = zero
Next = prima
Aggiunta di un nodo:
Nel mezzo: il caso generale da considerare per primo sta aggiungendo il nodo al
Medio dell'elenco.
3
4
8
9
Primo
scorso
Prossimo
prev
3
4
8
9
Primo
scorso
Prossimo
prev
6
r Assegnare spazio per il nuovo nodo.
Nuova temperatura
r memorizzare le informazioni per il nuovo elemento.
temp.info = articolo
r punta il nodo precedente al nuovo nodo.
prev.link = temp
r punta il nuovo nodo al nodo successivo.
temp.link = Next
All'inizio: se il nuovo nodo appartiene all'inizio dell'elenco (diciamo
valore 2), quindi prev.link = temp non funzionerebbe, perché Prev non punta a a
nodo.Sostituiremo questa linea con quanto segue:

---
layout: 
title: Pagina 71
level: 3
---


Tipi di dati astratti
55
scorso
Primo
9
8
4
3
prev
Prossimo
r Se il nuovo nodo deve essere il primo nodo, se prev = nil allora
r punto prima sul nuovo nodo
primo = temp
R altro
altro
r punta il nodo precedente al nuovo nodo.
prev.link = temp
finisci se
Alla fine: ora cosa succede se il nuovo nodo deve essere aggiunto alla fine (ad es. Valore 12)?
L'ultimo variabile non punterà più all'ultimo nodo.Aggiunta del seguente codice
In basso risolverà il problema:
3
4
8
9
Primo
scorso
Prossimo
prev
r Se il nuovo nodo sarà l'ultimo nodo, se prev = ultimo allora
R Punto ultimo sul nuovo nodo.
ultimo = temp
finisci se
In un elenco vuoto: un altro caso da considerare è quando l'elenco iniziale è vuoto.In questo
Caso, tutte le variabili, prima, ultima, prev e successiva, saranno zero.Il nuovo codice funziona
questo caso così com'è.
CODICE CONCETTA per l'aggiunta di un nodo: è necessario mettere insieme tutti questi pezzi
in una routine di inserimento.Vedi Esercizio 3.2.5.
Eliminazione di un nodo:
Dal centro: ancora una volta il caso generale da considerare per il primo sta eliminando il nodo
Dal centro dell'elenco.Dobbiamo mantenere l'elenco collegato prima di distruggere
il nodo.Altrimenti, abbandoneremo l'elenco.
3
4
8
9
Primo
scorso
Prossimo
prev
3
4
9
Primo
scorso
prev
Prossimo

---
layout: 
title: Pagina 72
level: 3
---


Algoritmi iterativi e invarianti ad anello
56
r bypassare il nodo eliminato.
prev.link = next.link
R Dealloca la memoria indicata da
Prossimo.
gratuito
Dall'inizio o dalla fine: come prima, devi considerare tutto il potenziale
casi speciali.Vedi Esercizio 3.2.6.
prev
Prossimo
Prossimo
prev
3
4
8
9
Primo
scorso
Prossimo
prev
scorso
Primo
9
8
4
3
prev
Prossimo
(C)
(D)
(B)
(UN)
3
4
8
9
Primo
scorso
scorso
Primo
9
8
4
3
Esercizio 3.2.1 Implementare test se un elenco collegato è vuoto.
Esercizio 3.2.2 Implementazione dell'aggiunta di un nodo alla fine di un elenco collegato.
Esercizio 3.2.3 Doppi puntatori: descrivere come questa operazione può essere eseguita in (1)
Tempo se ci sono puntatori in ciascun nodo sia al nodo precedente che a quello successivo.
Esercizio 3.2.4 (vedere la soluzione nella parte cinque.) Nel codice per camminare lungo il collegato
Elenco, quale effetto, se presente, avrebbe se l'ordine delle condizioni di uscita fosse cambiato
Per "uscire quando next.info ≥newelement o Next = nil"?
Esercizio 3.2.5 Implementa l'inserimento completo del codice che, quando viene fornito un valore informativo
newelment, inserisce un nuovo elemento in cui appartiene a un elenco collegato ordinato.Ciò implica solo mettere insieme i pezzi appena forniti.
Esercizio 3.2.6 Implementare il codice completo Elimina che, quando viene fornito un valore informativo
newelment, trova ed elimina il primo elemento con questo valore, se esiste.Ciò implica anche considerando i quattro casi speciali elencati per l'eliminazione di un nodo dall'inizio o dalla fine di un elenco collegato.
3.3
Unendo con una coda
La fusione consiste nella combinazione di due elenchi ordinati, A e B, in una completamente ordinata
Elenco, C. Qui A, B e C sono ciascuno implementato come code.Il ciclo invariante mantenuto è che i più piccoli degli elementi sono ordinati in C. (Questo è un classico invariante in più del loop.e B. Il prossimo elemento più piccolo sarà

---
layout: 
title: Pagina 73
level: 3
---


Tipi di dati astratti
57
Il primo elemento in un o il primo elemento in B. Progress viene effettuato rimuovendo il più piccolo
di questi due primi elementi e aggiungendolo al retro di C. in questo modo, l'algoritmo
Procede come due corsie di traffico che si fondono in uno.Ad ogni iterazione, la prima auto da
Una delle corsie in arrivo è scelta per spostarsi nella corsia unita.Questo aumenta k
da uno.Inizialmente, con k = 0, abbiamo semplicemente le due liste fornite.Ci fermiamo quando k = n.
A questo punto, tutti gli elementi verranno ordinati in C. La fusione è un passo chiave nella fusione
Algoritmo di ordinamento presentato nella sezione 9.1.
Algoritmo unione (elenco: a, b)
⟨Pre-Cond⟩: A e B sono due elenchi ordinati.
⟨Post-Cond⟩: C è l'elenco ordinato contenente gli elementi degli altri due.
inizio
ciclo continuo
⟨Loop-invariant⟩: il k più piccolo degli elementi è ordinato in C.
Gli elementi più grandi sono ancora nelle loro liste originali A e B.
Esci quando A e B sono entrambi vuoti
Se (il primo in a è più piccolo del primo in b o b è vuoto)
Elemento successivo = Rimuovi il primo da a
altro
Elemento successivo = Rimuovi il primo da B
finisci se
Aggiungi il prossimo elemento a c
End Loop
restituzione (c)
Algoritmo di fine
3.4
Analizzare con uno stack
Un uso importante dello stack è per l'analisi.
Specifiche:
Precondizioni: un'istanza di input è costituita da una stringa di parentesi.
Postconditions: l'output indica se le parentesi corrispondono.Inoltre, ogni staffa sinistra viene assegnato un numero intero 1, 2, 3 ,...e ogni staffa destra viene assegnato l'intero dalla sua staffa sinistra corrispondente.
Esempio:
Ingresso:
(
[
{
}
(
)
"
(
)
{
(
)
}
)
Produzione:
1
2
3
3
4
4
2
5
5
6
7
7
6
1

---
layout: 
title: Pagina 74
level: 3
---


Algoritmi iterativi e invarianti ad anello
58
L'anello invariante: alcuni prefiniti dell'istanza di input sono stati letti e il numero intero corretto assegnato a ciascuna di queste parentesi.(Pertanto, è un ciclo più di input
invariante.) Le staffe sinistro che sono state lette e non abbinate sono conservate insieme
Con i loro numeri interi in ordine di sinistra a destra in uno stack, con il più a destra in cima.IL
La variabile C indica che il numero intero successivo deve essere assegnato a una staffa sinistra.
Mantenere l'invariante del loop: se la lettura della staffa successiva è una staffa sinistra, allora esso
è assegnato l'intero c.Non essendo abbinato, viene spinto sullo stack.C è incrementato.Se la lettura della fascia successiva è una parentesi giusta, allora deve abbinare il più a destra
parentesi sinistra che è stata letto. Questo sarà sulla parte superiore dello stack.La staffa superiore
Sullo stack è scoppiato.Se corrisponde alla parentesi giusta, cioè abbiamo (), {} o [], allora il
La fascia destra è assegnata l'intero per questa staffa sinistra.In caso contrario, un messaggio di errore
è stampato.
Condizioni iniziali: inizialmente non è stato letto nulla e lo stack è vuoto.
Finale: se lo stack è vuoto dopo che l'ultima fascia è stata letta, la stringa ha
stato analizzato.
Codice:
analizza / i algoritmo
⟨Pre-Cond⟩: S è una stringa di parentesi.
⟨Post-Cond⟩: stampa una stringa di numeri interi che indicano come le parentesi
incontro.
inizio
i = 0, c = 1
ciclo continuo
⟨Loop-invariant⟩: pre ﬁ x s [1, i] è stato assegnato interi e
Le sue staffe di sinistra sono sullo stack.
uscita quando i = n
if (s [i + 1] è una staffa sinistra) allora
stampa (c)
push (⟨s [i + 1], c⟩)
c = c + 1
Elseif (s [i + 1] = staffa destra) quindi
if (stackempty ()) return ("Impossibile analizzare")
⟨Left, d⟩ = pop ()
if (a sinistra corrisponde s [i + 1]) quindi stampa (d)
Else Return ("Impossibile analizzare")

---
layout: 
title: Pagina 75
level: 3
---


Tipi di dati astratti
59
altro
return ("carattere di input non valido")
finisci se
i = i + 1
End Loop
if (stackempty ()) return ("analizzato") return else ("non può analizzare")
Algoritmo di fine
Analizzare solo "()": se devi analizzare solo un tipo di parentesi e lo desideri solo
Per sapere se le parentesi corrispondono o meno, non è necessario lo stack nel
Sopra l'algoritmo, solo un numero intero che immagazzina il numero di staffe sinistro nello stack.
Analisi con grammatiche senza contesto: per analizzare frasi più complesse vedi
Capitolo 12 e Sezione 19.8.

---
layout: 
title: Pagina 76
level: 3
---


60
4 Restringendo lo spazio di ricerca:
Ricerca binaria
In questo capitolo considereremo più algoritmi di ricerca binaria, che usano il
Restringendo il tipo di loop invariante.In questo caso, se la cosa è
Cercato è ovunque, quindi è nel sublist ristretto.Guardiamo prima gli alberi di ricerca binari generali, che sono spesso usati in algoritmi ricorsivi (vedi Sezione 10.2) e quindi guardiamo un altro esempio di un algoritmo che incorpora binario
ricerca.
4.1
Alberi di ricerca binari
La sezione 3.1 definisce un albero di ricerca binario per essere un dati sull'albero binario
Struttura in cui ciascun nodo memorizza un elemento (e alcuni dati associati).I nodi sono ordinati in modo che per ogni nodo tutto il
Gli elementi nella sua sottostruttura sinistra sono più piccoli dell'elemento di quel nodo
E tutti quelli nella sua sottostruttura destra sono più grandi.Mostrerò qui come
per cercare rapidamente un elemento con un dato albero.
14
25
21
8
2
5
Albero di ricerca binaria
1) Specificazioni: dato un albero di ricerca binario e una chiave, trovare un nodo il cui elemento
è questa chiave o segnalare che non esiste un tale nodo.
2) Passaggi di base: lo spazio di ricerca limitato sarà una sottostruttura.Proprio come in binario
Cerca, il nostro obiettivo è tagliare a metà le dimensioni di questo spazio di ricerca.
3) Misura del progresso: per l'esempio di ricerca binaria 1.4.3, la misura del progresso
era il numero di elementi nell'attuale sublist.Con alberi di ricerca binari questo
Il numero non è così prevedibile quando l'albero non è bilanciato.Quindi, la misura di
I progressi saranno il numero di bordi nel percorso dalla radice dell'intera sottocamera
alla radice della sottostruttura corrente.
4) Il ciclo invariante: il loop invariante afferma che se la chiave è contenuta da qualche parte nell'intero albero di ricerca binaria, è contenuto nella nostra attuale sottostruttura.

---
layout: 
title: Pagina 77
level: 3
---


Restringendo lo spazio di ricerca: ricerca binaria
61
5) Passaggi principali: nella ricerca binaria, abbiamo confrontato la chiave con l'elemento al centro dello spazio di ricerca corrente.Con un albero di ricerca binaria sbilanciato, non lo facciamo
Sappi quale nodo è nel mezzo esatto.Invece, confrontiamo la chiave con l'elemento alla radice della sottostruttura corrente.Se contiene la chiave, allora abbiamo finito.Se la
Il tasto è più piccolo di ciò, allora sappiamo che se la chiave è ovunque, allora è a sinistra
Sottomarino del nostro albero attuale, altrimenti sappiamo che è nella sottostruttura giusta.
6) Fai progressi: mentre la radice della nostra attuale sottostruttura si sposta verso la sua sinistra
o la sua sottostruttura giusta, la misura del progresso aumenta di uno.
7) Mantieni il loop invariante: ⟨loop-invariant ′⟩ & not ⟨exit-cond⟩ & codeloop ⇒
⟨Loop-invariant ′ ′⟩.L'anello precedente invariante dà che la ricerca è stata ridotta alla sottostruttura attuale.La proprietà degli alberi di ricerca binari è che tutti i
Elementi all'interno di questa sottostruttura che sono più piccoli della radice di questa sottostruttura sono in questo
La sottostruttura sinistra di Subtree e tutti quelli più grandi nella sua destra.Quindi, i gradini principali si restringono
Lo spazio di ricerca alla sottostruttura, che conterrebbe la chiave.
8) Stabilire il loop invariante: ⟨pre-Cond⟩ & CodePre-Loop⇒ ⟨loop-invariant⟩.
Inizialmente, si ottiene il ciclo invariante considerando l'intero albero degli elementi come
l'attuale sottostruttura.
9) Condizione di uscita: usciamo o quando viene trovata la chiave o quando la sottostruttura corrente
diventa vuoto.
10) finale: ⟨loop-invariante⟩ & ⟨exit-cond⟩ & codepost-loop ⇒⟨post-conf⟩.Dal
condizione di uscita, o abbiamo trovato la chiave, nel qual caso abbiamo finito, o abbiamo
ridotto lo spazio di ricerca a una sottostruttura vuota.L'anda invariante dice che se il
La chiave è contenuta nell'elenco originale, quindi la chiave è contenuta in questa sottotee vuota, che non lo è, e quindi l'algoritmo può riferire in modo sicuro che la chiave non si trova in
Elenco originale.
11) Termine e tempo di esecuzione: il numero di iterazioni di questo algoritmo
è al massimo l'altezza dell'albero di ricerca binaria, che (se l'albero è più o meno bilanciato)
è (logn).
12) Casi speciali: non ci sono casi speciali qui: qualsiasi input è uguale, maggiore o più piccolo della radice della sottostruttura corrente.
13) Dettagli di codifica e implementazione:
Algoritmo SearchBst (albero, keytofind)
⟨Pre-Cond⟩: l'albero è un albero binario i cui nodi contengono filetti e campi di dati.
KeyToFind è una chiave.

---
layout: 
title: Pagina 78
level: 3
---


Algoritmi iterativi e invarianti ad anello
62
⟨Post-Cond⟩: se esiste un nodo con questa chiave nell'albero, allora i dati associati
è restituito.
inizio
subtree = albero
ciclo continuo
⟨Loop-invariant⟩: se la chiave è contenuta nell'albero, allora la chiave è
contenuto nella sottostruttura.
if (subtree = vuoto) quindi
risultato ("chiave non nell'albero")
altrimenti se (keytofind <rootkey (subtree))
subtree = sinistra (subtree)
altrimenti if (keytofind = rootkey (subtree))
risultato (rootdata (subtree))
altrimenti if (keytofind> rootkey (subtree))
subtree = di Rightsub (subtree)
finisci se
End Loop
Algoritmo di fine
4.2
Sevens magici
Mia madre ha dato a mio figlio Joshua un libro di trucchi magici.
Il libro dice: “Questo trucco è davvero magico.Arriva bene
Ogni volta che lo fai, ma non c'è spiegazione del perché. "
A quanto pare, c'è un bug nel modo in cui spiegano il trucco.Il nostro compito è quello di risolvere il bug e contrastare
"Non c'è spiegazione del perché."L'unica magia è quella
di invarianti ad anello.L'algoritmo è una variante sul binario
ricerca.
1) Specifiche:
r Let C, un numero intero dispari, sia il numero di colonne.Il libro utilizza C = 3.
r Let R, un numero intero dispari, sia il numero di righe.Il libro utilizza r = 7.
r Sia n = c · r il numero di carte.Il libro utilizza n = 21.
r Sia T il numero di iterazioni.Il libro utilizza t = 2.
r Sia F L'indice finale della scheda selezionata.Il libro utilizza f = 11.
R chiedi a qualcuno di selezionare una delle carte N e poi di fluire il mazzo.

---
layout: 
title: Pagina 79
level: 3
---


Restringendo lo spazio di ricerca: ricerca binaria
63
r Ripeti T volte:
r distribuire le carte come segue.Metti le carte C di fila da sinistra a destra facciale.Mettere un
seconda riga in cima, ma si è spostata leggermente in modo da poter vedere cosa sia il
La prima e la seconda fila di carte sono.Ripeti per le righe R.Questo forma colonne c di r
carte ciascuna.
r Chiedi in quale colonna si trova la scheda selezionata.
r Impilare le carte in ogni colonna.Metti la colonna selezionata nel mezzo.(Questo
è perché c è strano.)
r Output la scheda F TH.
Il nostro compito è determinare per quali valori c, r, n, t e f questo trucco trova il selezionato
carta.
Versione più semplice: l'analisi di questo trucco risulta essere più difficile di quanto inizialmente pensassi.
Quindi, considereremo il seguente trucco più semplice.Invece di mettere il selezionato
Colonna al centro delle altre colonne, lo mettiamo davanti.
2) Passaggi di base: ad ogni iterazione otteniamo alcune informazioni su quale carta aveva
stato selezionato.Il trucco sembra essere simile alla ricerca binaria.Una differenza è che la ricerca binaria divide l'attuale sublist in due parti, mentre questo trucco divide l'intero
impilare le parti C.In entrambi gli algoritmi, ad ogni iterazione apprendiamo quale di queste pile il
L'elemento richiesto è in.
4) Loop Invariant: una buona supposizione per un ciclo invariante sarebbe quella usata da
Ricerca binaria.L'invariante del loop affermerà che alcuni sottoinsieme delle carte contiene
la scheda selezionata.In questa versione più semplice, la colonna contenente la scheda è continuamente
si spostò sulla parte anteriore dello stack.Quindi, indoviamo che si = {1, 2 ,..., si} indicizza il
Primi carte SI nel mazzo.Successivamente risolveremo una relazione di ricorrenza per determinarla
si = ⌈n/ci⌉.
7) Mantieni il loop invariante: ⟨loop-invariant ′⟩ & not ⟨exit-cond⟩ & codeloop ⇒
⟨Loop-invariant ′ ′⟩.Dal precedente loop invariante, la scheda selezionata è una delle prime
si−
1 nel mazzo.Quando le carte vengono disposte, le prime carte Si - 1 verranno diffuse
Le cime delle colonne C.Alcune colonne riceveranno ⌈si - 1/c⌉ di queste carte e alcune
otterrà ⌊si - 1/c⌋ di loro.Quando ci viene detto in quale colonna si trova la scheda selezionata, noi
saprà che la scheda selezionata è una delle prime ⌈SI - 1/C⌉card in questa colonna.In
Conclusione, Si =
Si - 1
C

=
n
ci - 1

C

=
n
ci

.

---
layout: 
title: Pagina 80
level: 3
---


Algoritmi iterativi e invarianti ad anello
64
8) Stabilire il loop invariante: Ancora una volta, come fatto nella ricerca binaria, inizialmente
Ottieni l'invariante in loop considerando l'intero stack di carte, dando s0 =
⌈N/c0⌉ = n.
9) Condizione di uscita: quando si sono verificati cicli sufficienti in modo che ST = 1, la ricerca
Lo spazio si è ristretto per contenere solo la prima carta.Quindi, l'algoritmo lo è
in grado di selezionare la scheda f = 1.
11) Tempo di esecuzione: dopo t = ⌈logc n⌉rounds, st = ⌈n/ct⌉ = 1.
Per un limite inferiore corrispondente sul numero di iterazioni necessarie, vedi Capitolo 7.
Il libro ha n = 21, c = 3 e t = 2. perché 21 = n ̸≤ct = 32 = 9, il trucco in
Il libro non funziona.Due round non sono sufficienti.Ci devono essere tre.
Trucco originale: considera di nuovo il trucco originale in cui viene inserita la colonna selezionata
nel mezzo.
4) Il ciclo invariante: poiché la colonna selezionata viene messa al centro, lasciaci
Indovina che SI sia composta dalle carte SI Middle.Più formalmente, lascia DI = (N -SI)/2.Nessuno dei due
La prima né le ultime schede Desterà la carta selezionata.Invece sarà uno di Si =
{DI + 1 ,..., DI + Si}.Si noti che sia N che SI devono essere strani.
8) Stabilire l'invariante del loop: per i = 0, abbiamo s0 = n, d0 = 0 e la scheda selezionata può essere qualsiasi scheda nel mazzo.
7) Mantieni il ciclo invariante: supponiamo che prima dell'ith ith, la selezionata
La carta non è una delle prime carte DI - 1, ma è una delle Si -1 centrali nel mazzo.Poi
Quando le carte vengono disposte, le prime carte DI - 1 saranno diffuse sulle cime del C
colonne.Alcune colonne riceveranno ⌈di - 1/c⌉ di queste carte e alcune otterranno ⌊di - 1/c⌋
di loro.In generale, tuttavia, possiamo dire che le prime ⌊di - 1/c⌋card di ciascuna colonna non sono la scheda selezionata.Usiamo il pavimento invece del soffitto qui, perché
Questo è il caso peggiore.Per simmetria, sappiamo anche che la scheda selezionata non è una
delle ultime ⌊di - 1/c⌋card in ciascuna colonna.Quando la persona punta in una colonna, apprendiamo che la scheda selezionata è da qualche parte in quella colonna.Tuttavia, da prima che sapessimo che la carta selezionata non è una delle prime o dell'ultimo ⌊di - 1/c⌋card in
questa colonna.Ci sono solo carte R nella colonna.Quindi, la carta selezionata deve
essere uno dei centrali r −2⌊di - 1/c⌋ne nella colonna.Definire Si è questo valore.
Il nuovo mazzo è formato impilando le colonne insieme a queste carte in
mezzo.
9) Condizione di uscita: quando si sono verificati cicli sufficienti in modo che st = 1, quindi il
La scheda selezionata sarà nel medio indicizzato da f = ⌈n
2 ⌉.

---
layout: 
title: Pagina 81
level: 3
---


Restringendo lo spazio di ricerca: ricerca binaria
65
Trucco nel libro: il libro ha n = 21, c = 3 e r = 7. Quindi
si = r −2⌊di - 1
C ⌋
DI = N -SI
2
Si = {di + 1 ,..., di + si}
s0 = n = 21
d0 = 21-21
2
= 0
S0 = {1, 2 ,..., 21}
S1 = 7 −2⌊0
3⌋ = 7
D1 = 21−7
2
= 7
S1 = {8, 9 ,..., 14}
S2 = 7 −2⌊7
3⌋ = 3
D2 = 21−3
2
= 9
S2 = {10, 11, 12}
S3 = 7 −2⌊9
3⌋ = 1
D3 = 21−1
2
= 10
S3 = {11}
Ancora una volta sono necessari tre e non due round.
11) Tempo di esecuzione: ignorare temporaneamente il pavimento nell'equazione per SI fa il
Analisi più facile.Abbiamo
si = r −2
di - 1
C

≈r −2di - 1
C
= n
C −2 (N −Si - 1)/2
C
= Si - 1
C .
Ancora una volta, questa relazione di ricorrenza dà che si = n/ci.Se includiamo il pavimento, le manipolazioni impegnative danno quel Si = 2⌊si - 1/2C −1
2⌋+ 1. Altri calcoli danno che si è
Sempre N/CI arrotondato fino al prossimo numero dispari.
Esercizio 4.2.1 Dai codice per il trucco originale di Magic Sevens.
Esercizio 4.2.2 Supponiamo che s e t siano array ordinati, ciascuno contenente n elementi.Trovare
il nth più piccolo dei 2n numeri.
4.3
Test del chip VLSI
Quello che segue è uno strano problema con strane regole.Tuttavia, non è più strano di
I problemi che dovrai risolvere nel mondo.Lo useremo come esempio di
Come sviluppare uno strano ciclo invariante con cui l'algoritmo e la sua correttezza
diventare trasparente.
Specifica: il nostro capo non ha presumibilmente identici patatine VLSI che sono potenzialmente
in grado di mettersi alla prova a vicenda.La sua maschera di prova ospita due patatine alla volta.IL
Il risultato è che sono gli stessi (cioè entrambi sono buoni o entrambi cattivi) o quello
Sono diversi (che è almeno uno è cattivo).Il professore ci assume per progettare un
Algoritmo per distinguere buone chip da quelli cattivi.
Impossibile?Alcuni problemi computazionali hanno algoritmi a tempo esponenziale, ma
Nessun algoritmi di tempo polinomiale.Perché siamo limitati in ciò che siamo in grado di fare, questo
Il problema potrebbe non avere affatto un algoritmo.Spesso è difficile da sapere.Una buona cosa per
Fai con un nuovo problema è alternare tra autore e critico.L'autore fa il suo
Meglio progettare un algoritmo per il problema.Il critico fa del suo meglio per dimostrare che il
L'algoritmo dell'autore non funziona o, ancora meglio, dimostra che nessun algoritmo funziona.

---
layout: 
title: Pagina 82
level: 3
---


Algoritmi iterativi e invarianti ad anello
66
Supponiamo che al professore abbia un buon chip e un brutto chip.
Il singolo test che ha gli dice che questi chip sono diversi, ma non glielo dice
quale è quale.Non esiste un algoritmo che utilizza solo questo singolo test che realizza
l'obiettivo.Il professore potrebbe non essere contento dei nostri risultati, ma non sarà in grado di farlo
biasimici.
Sebbene abbiamo dimostrato che non esiste un algoritmo che distingue questi due
Chips, forse possiamo trovare un algoritmo che può essere di qualche uso per il professore.
Una struttura di dati: è utile avere una buona struttura di dati con cui archiviare il
informazioni che sono state raccolte.Qui possiamo avere un grafico con un nodo per ciascuno
patata fritta.Dopo aver testato una coppia di chip, mettiamo un bordo solido tra il corrispondente
nodi se secondo quanto riferito sono uguali e un bordo punteggiato se sono diversi.
L'algoritmo della forza bruta: un modo per capire meglio un problema è inizialmente fingere di avere tempo ed energia illimitati.Con questo, cosa possono fare compiti
fai?Con i test (N2) possiamo testare ogni coppia di chip.Partiamo dal presupposto che il
Il test è tensitivo, il che significa che se il chip A test è uguale a B, che test è
Lo stesso di C, quindi A testerà per essere uguale a c.Detto questo, possiamo concluderlo
I test divieteranno i chip in serie di chip che sono uguali.(Nella teoria dei grafici
Chiamiamo questi set cricche, come in una cricca di amici in cui tutti nel gruppo sono
Amici con tutti gli altri nel gruppo.) Tuttavia, non è disponibile alcun test per determinare quale di questi set contenga i buoni chip.
Cambia il problema: quando rimani bloccato, una cosa utile da fare è tornare al tuo
boss o all'applicazione a portata di mano e vedere se puoi cambiare il problema per farlo
Più facile.Ci sono tre modi per farlo.
Più strumenti: un'opzione è consentire agli strumenti più potenti dell'algoritmo.Un test che
Ti ho detto se un chip fosse buono avrebbe risolto il problema.D'altra parte, se il professore avesse avuto un tale test, saresti senza lavoro.
Modificare le preconoscenze: è possibile modificare i preliminari per richiedere ulteriori informazioni sull'istanza di input o per non consentire particolarmente difficile
istanze.Hai bisogno di un modo per distinguere tra i buoni chip e il
Varie forme di cattive patatine.Forse puoi convincere il professore a assicurartelo
Più della metà delle patatine sono buone.Con questo, puoi risolvere il problema.Test
Tutte le coppie di patatine e la divisione dei chip nei set di chip equivalenti.IL
Il più grande di questi set sarà i buoni patatine.
Cambia i postcondizioni: un'altra opzione è quella di modificare i postcondizioni
non richiede così tanto nell'output.Invece di dover distinguere completamente tra chip buoni e cattivi, un compito più semplice sarebbe trovare un singolo buono
patata fritta.

---
layout: 
title: Pagina 83
level: 3
---


Restringendo lo spazio di ricerca: ricerca binaria
67
Un algoritmo più veloce: una volta che avremo il nostro algoritmo di forza bruta, vorremmo tentare di trovare un algoritmo più veloce.Cerchiamo di trovare un singolo buon chip tra
n chips, supponendo che più di n/2 dei chip siano buoni, usando un algoritmo iterativo.Speriamo che sia più veloce del tempo (N2).
Progettazione dell'invariante in loop: nella progettazione di un algoritmo iterativo per questo problema, il passo più creativo è la progettazione dell'invariante in loop.
Inizia con piccoli passaggi: quali passaggi di base potremmo seguire per fare una sorta di
progresso?Certamente il primo passo è testare due chip.Ci sono due casi.
Diverso: supponiamo che determiniamo che i due chip sono diversi.Uno
Il modo per fare progressi è restringere l'istanza di input mantenendo ciò che sappiamo al riguardo.Quello che sappiamo è che più della metà delle patatine
sono buoni.Poiché sappiamo che almeno uno dei due patatine testate è male, possiamo buttarli entrambi.Sappiamo che non vanno male facendo questo, perché manteniamo l'invariante invariante che oltre la metà del
Le patatine sono buone.Da questo sappiamo che c'è ancora almeno un buon chip
rimanendo, che possiamo restituire come risposta.
Lo stesso: se i due chip testano allo stesso modo, non possiamo buttarli via, perché potrebbero essere entrambi buoni.Tuttavia, anche questo sembra che stiamo facendo
progressi, perché, come nell'algoritmo della forza bruta, stiamo costruendo una serie di
patatine che sono uguali.
Immagine dal mezzo: dal nostro unico passo, abbiamo visto due forme di progresso.
Innanzitutto, abbiamo visto che alcune patatine saranno state messe da parte.Lascia che S denota il sottoinsieme
contenente tutti i chip che non abbiamo messo da parte.Secondo, abbiamo visto che eravamo
Costruire set di chip che sappiamo essere uguali.Potrebbe scoprire che noi
dovrà mantenere una serie di questi set.Per iniziare, tuttavia, cominciamo
L'immagine più semplice e costruisci solo uno di questi set.
Il loop invariante: manteniamo due set.Il set s contiene i chip che noi
non hanno messo da parte.Sosteniamo che oltre la metà delle patatine in S è buona.
Il set C è un sottoinsieme di S. sosteniamo che tutte le patatine in C sono uguali, anche se non sappiamo se sono tutti buoni o cattivi.
Tipo di loop invariante: questo è uno strano ciclo invariante, ma ha un numero di
aspetti familiari.
Più dell'input: consideriamo i chip uno alla volta in ordine.
Più dell'output: il set C è la nostra prima ipotesi a ciò che è stato emesso bene
I chip saranno (ma questo potrebbe cambiare).
Stringere lo spazio di ricerca: il set ristretto s contiene almeno un bene
patata fritta.

---
layout: 
title: Pagina 84
level: 3
---


Algoritmi iterativi e invarianti ad anello
68
Analisi del caso: controlliamo diversi casi per se i chip sono gli stessi
o diverso.
Lavoro svolto: i set s e c tengono traccia del lavoro svolto in modo da non aver bisogno di
essere rifatto.
Mantenimento dell'invariante in loop: ⟨Loop-Invariant ′⟩ & Not⟨Exit-Cond⟩ & Codeloop ⇒
⟨Loop-invariant ′ ′⟩.Supponiamo che tutto ciò che sappiamo sia che l'invariante in loop sia vero.È
L'unica cosa che sappiamo fare, dobbiamo testare due patatine.Testare due da C
non è utile, perché sappiamo già che sono uguali.Testare due che sono
non in c è pericoloso, perché se apprendiamo che sono gli stessi, allora dovremo farlo
Inizia una seconda serie di chip simili, ma in precedenza abbiamo deciso di mantenerne solo uno.IL
Rimanendo la possibilità è scegliere qualsiasi chip da C e qualsiasi da S - C e testarli.
Indichiamo questi patatine da c e s.
Lo stesso: se la conclusione è che i chip sono uguali, quindi aggiungi i chip a C. noi
non sono cambiati S, quindi il suo ciclo invariante vale ancora.Dal nostro test, lo sappiamo
s ha la stessa caratteristica di c.Dall'anello invariante, sappiamo che C è quello
Come tutti gli altri chip in C. Quindi, sappiamo che s è uguale a tutti gli altri
Segue i patatine in C e l'invariante loop.
Diverso: se la conclusione è che almeno uno è cattivo, quindi elimina sia C che S
Da C e S. ora S ha perso due patatine, almeno una delle quali è cattiva.Quindi, noi
hanno mantenuto il fatto che oltre la metà delle patatine in s è buona.Inoltre, c
è diventato solo più piccolo, e quindi abbiamo mantenuto il fatto che i suoi chip
sono tutti uguali.
Ad ogni modo, manteniamo il ciclo invariante mentre ne facciamo un po '(ma non corretto)
progresso.
Gestisci tutti i casi: possiamo testare un solo chip da C e uno da S - C se entrambi lo sono
non vuoto.Dobbiamo considerare i casi in cui non lo sono.
S è vuoto: se s è vuoto, allora siamo nei guai, perché non abbiamo più chips
per tornare come risposta.Dobbiamo fermarci prima di questo.
S - c è vuoto: se s - c è vuoto, allora sappiamo che tutti i chip in s = c sono i
Stesso.Perché più della metà di loro deve essere buona, sappiamo che tutti loro
sono buoni.Quindi, abbiamo finito.
C è vuoto: se C è vuoto, prendi qualsiasi chip da S e aggiungilo a C.
cambiato S, quindi il suo ciclo invariante vale ancora.Il singolo chip in C è uguale a
si.
La misura del progresso: la misura non può essere | s |, perché ciò non diminuisce quando i chip sono uguali.Invece, lascia che la misura sia | s - c |.In due dei nostri

---
layout: 
title: Pagina 85
level: 3
---


Restringendo lo spazio di ricerca: ricerca binaria
69
Casi, rimuoviamo un chip da S -C e lo aggiungiamo a C. In un altro caso, rimuoviamo un chip
da S - C e uno da C. Pertanto, in tutti i casi questa misura diminuisce di 1.
Codice iniziale: ⟨pre-Cond⟩ & CodePre-Loop ⇒⟨loop-invariante⟩.Il codice iniziale imposta S su
Sii tutte le patatine e C per essere vuote.Più della metà delle patatine in s sono buone secondo
al presupposto.Perché non ci sono chip in C, tutti i patatine che ci sono sono i
Stesso.
Loop in uscita: ⟨Loop-invariante⟩ & ⟨Exit-Cond⟩ & Codepost-Loop ⇒ ⇒ Post-Cond⟩).| S −c | =
0 è una buona condizione di arresto, ma non la prima.Fermati quando | c |> | S |/2 e restituisci qualsiasi
CHIP DA C. Secondo l'invariante in loop, i chip in C sono tutti buoni o tutti
Cattivo.Le patatine in C costituiscono più della metà delle patatine, quindi se erano tutti cattivi, di più
Anche la metà delle patatine in S sarebbe cattiva.Questo contraddice l'invariante in loop.
Quindi, i chip in C sono tutti buoni.
Tempo di esecuzione: inizialmente, la misura del progresso | s - c |è n.Abbiamo dimostrato che diminuisce di almeno 1 ogni iterazione.Quindi, ci sono al massimo N passi prima che S - C sia
vuoto.A questo punto siamo garantiti per uscire dal ciclo, perché | S - C |= 0 assicura
noi che la condizione di uscita | c |= | S |> | S |/2 è soddisfatto.S deve contenere almeno un chip, perché dal ciclo invariante più della metà di loro è buona.
Ulteriori osservazioni: C può fluire avanti e indietro tra essere tutto cattivo e essere tutto bene molte volte.Supponiamo che sia tutto male.Se S da S - C sembra essere cattivo, allora
C diventa più grande.Se S da S - C sembra essere buono, allora C si riduce.Se C diventa mai vuoto durante questo processo, allora un nuovo chip viene aggiunto a C. Questo chip potrebbe essere
bene o male.Il processo si ripete.
Estensione dell'algoritmo: l'algoritmo trova un buon chip.Questo buon chip lo farà
Dicci quale degli altri chips sono buoni in o (n) tempo.
Algoritmo randomizzato: il capitolo 21 fornisce un algoritmo randomizzato molto più semplice per questo problema.
4.4
Esercizi
Esercizio 4.4.1 (vedi soluzione nella parte cinque.) Cerca una matrice ordinata: l'input è costituito
di un numero reale x e una matrice A [1..n, 1..m] di numeri reali nm in modo tale che ogni riga
A [i, 1..m] è ordinato e ogni colonna A [1..n, J] è ordinata.L'obiettivo è quello di trovare la massima voce dell'array a [i, j] che è inferiore o uguale a x o riferire che tutti gli elementi di a
sono più grandi di x.Progetta e analizza un algoritmo iterativo per questo problema che esamina il minor numero possibile di voci di matrice.Perché credi che un semplice binario
La ricerca risolve il problema.Esercizio 7.0.7 chiede un limite inferiore e l'esercizio 9.1.3 per
Un algoritmo ricorsivo.

---
layout: 
title: Pagina 86
level: 3
---


Algoritmi iterativi e invarianti ad anello
70
Esercizio 4.4.2 Supponiamo che un treno avrebbe dovuto iniziare dalla stazione A, pausa alle stazioni
B, c, d ,..., Y e finisce alla stazione Z. Tuttavia, non è arrivato a Z. Supponiamo nel tuo
fabbrica Il pezzo di attrezzatura o il processo etichettato a fa funzionare la parte B, che a sua volta
fa c, d ,...e z lavoro.Tuttavia, Z non funziona.Vuoi scoprire perché.
Quale algoritmo usi?Pensa ad altre applicazioni di questa tecnica.
Esercizio 4.4.3 La seguente domanda non riguarda il restringimento dello spazio di ricerca.Se
Qualunque cosa, si tratta di raddoppiare le dimensioni dello spazio di ricerca.Ma ha ancora una ricerca binaria
Tatto.Questa domanda trova la lunghezza dmin (u, v) del percorso più breve tra qualsiasi coppia di
nodi in un grafico diretto (o non indirizzato).L'ingresso fornisce la lunghezza d (u, v) ≥0
di ogni bordo ⟨u, contro il grafico completo.Non è necessario che d (u, v) = d (v, u) e
Queste lunghezze possono essere ∞.La distanza lungo un percorso è la somma dei valori d (u, v) lungo
i suoi bordi.Lascia che DI (U, V) indica la lunghezza del percorso più breve da U a V con al massimo
2i bordi.Fai passaggi 7, 8, 10 e 11, dimostrando che l'invariante in loop è stabilita e
mantenuto, dimostrando che viene stabilito e delimitante all'uscita della postcondizionamento
il tempo di esecuzione.Come suggerimento, traccia l'algoritmo su un grafico costituito da un singolo percorso, vale a dire, per j ∈ [1, n −1], d (uj, uj+1) = 1 e tutti gli altri bordi hanno d (u, v)= ∞.
Algoritmo Alg (D)
⟨Pre-Cond⟩: d (u, v) ∈ [0, ∞] è la lunghezza del bordo ⟨u, contro il grafico completo.
⟨Post-Cond⟩: restituito è la lunghezza dmin (u, v) del percorso più breve da u a v per ciascuno
coppia di nodi.
inizio
Per ogni bordo ⟨u, v⟩, d (u, v) = d (u, v)
Loop log2 (n) volte
⟨Loop-invariant⟩: dopo iterazioni, dmin (u, v) ≤d (u, v) ≤di (u, v)
Per ogni bordo ⟨u, v⟩ (iterativamente o in parallelo)
% Di (u, v) = min (di - 1 (u, v), minw [di - 1 (u, w) + di - 1 (w, v)])
Loop sui nodi w
if (d (u, v) ≥d (u, w) + d (w, v))
D (u, v) = d (u, w) + d (w, v)
finisci se
End Loop
End Loop
End Loop
restituzione (d)
Algoritmo di fine
Si può trovare di più su questo nell'esercizio 19.6.2.

---
layout: 
title: Pagina 87
level: 3
---


71
5 Algoritmi di smistamento iterativo
L'ordinamento è un classico problema computazionale.Durante i primi decenni di computer, quasi tutto il tempo del computer era dedicato all'ordinamento.Molti algoritmi di smistamento hanno
stato sviluppato.È utile conoscerli, perché l'ordinamento deve essere
fatto in molte situazioni diverse.Alcuni dipendono dalla complessità del tempo basso, altri
Piccolo memoria, altri sulla semplicità.In tutto il libro, consideriamo una serie di
Algoritmi di smistamento perché sono semplici ma forniscono una ricca selezione di esempi
per dimostrare diverse tecniche algoritmiche.Abbiamo già esaminato la selezione, l'inserimento e l'ordinamento della bolla nella Sezione 1.4.In questo capitolo iniziamo con un semplice
Versione del bucket Ordina e poi guarda il conteggio dell'ordinamento.Radix Ord, che è un altro
è considerato un tipo sorprendente.Infine, il conteggio e l'ordinamento radix sono combinati per dare
RADIX CONTENGE TORNO.
Si dice che la maggior parte degli algoritmi di smistamento sia basato sul confronto, perché l'unico modo
L'accesso ai valori di input è confrontandoli coppie, cioè ai ≤a j.Il conteggio di Radix manipola gli elementi in altri modi.Un'altra cosa strana in questo
L'algoritmo è che i suoi invarianti ad anello sono piuttosto inaspettati.
Nella sezione 9.1, consideriamo un tipo di tipo e un tipo rapido, che è un ricorsivo e
Versione randomizzata di Ordine del secchio.Guardiamo l'ordinamento dell'heap nella Sezione 10.4.
5.1
Ordina del secchio a mano
Specifiche: come professore, spesso devo ordinare un grande stack di documenti degli studenti
per cognome.L'algoritmo che utilizzo è una versione iterativa di Quick Ord e Bucket
ordinare.Vedere la sezione 9.1.
Passaggi di base:
Partizionamento in cinque secchi: i computer sono bravi a utilizzare un singolo confronto
per determinare se un elemento è maggiore del valore per pivot o meno.Gli umani, d'altra parte, tendono ad essere bravi a determinare rapidamente quale di cinque secchi
un elemento appartiene. Prima dilazione i documenti basati su quale dei seguenti

---
layout: 
title: Pagina 88
level: 3
---


Algoritmi iterativi e invarianti ad anello
72
Interva la prima lettera del nome è all'interno: [A - E], [F - K], [L - O], [P - T] o [U - Z].
Quindi parto il secchio [a - e] nei subbucket [a], [b], [c], [d] e [e].
Quindi parto il secchio [a] in base alla seconda lettera del nome.Questo funziona
per questa applicazione perché l'elenco da ordinare è costituito da nomi i cui primi
Le lettere sono abbastanza prevedibilmente distribuite attraverso l'alfabeto.
Uno stack di secchi: una dif ﬁ cy con questo algoritmo è tenere traccia di tutti i
secchi.Ad esempio, dopo la seconda partizione, avremo nove secchi: [a], [b], [c], [d], [e], [f - k], [l - o], [p - t] e [u - z].Dopo il terzo, ne avremo 13.
Su un computer, la ricorsione dell'algoritmo è implementata con uno stack di
cornici in pila.Di conseguenza, quando ordino i documenti dello studente, ho una pila di
secchi.
Il ciclo invariante: uso il seguente loop invariante per tenere traccia di quello che sono
facendo.I documenti sono divisi tra una pila di documenti già ordinati e una pila di
pile di documenti parzialmente ordinati.Vengono i documenti nella pila ordinata (inizialmente vuota)
Prima di tutti i documenti parzialmente ordinati.All'interno dello stack parzialmente ordinato di pile, il
I documenti all'interno di ogni pila sono fuori servizio.Tuttavia, ogni carta in una pila appartiene prima
Ogni carta in una pila successiva.Ad esempio, ad un certo punto dell'algoritmo, i documenti
A partire da [A - C] verrà risolto e le pile nel mio stack saranno costituite da [D], [E], [F - K], [L - O], [P - T] e [U–Z].
Mantenere invariante loop: faccio progressi mantenendo questo loop invariante come
segue.Prendo la pila superiore dallo stack, qui il [d].Se contiene solo una mezza dozzina
o così documenti, li ordino usando l'inserimento.Questi vengono quindi aggiunti alla parte superiore di
La pila ordinata, [a - c], dando [a - d].D'altra parte, se la pila [d] si tolse il
Lo stack è più grande di questo, lo diviso in cinque pile, [DA - DE], [df - dk], [dl --do], [dp–
Dt] e [du-dz], che spingo di nuovo sullo stack.Ad ogni modo, il mio loop invariante è
mantenuto.
Condizione di uscita: quando l'ultimo secchio è stato rimosso dallo stack, i documenti
sono ordinati.
Esercizio 5.1.1 Prova a ordinare un mazzo di carte usando questo algoritmo.
Esercizio 5.1.2 Dai codice per questo algoritmo.
5.2
Conteggio dell'ordinamento (un tipo stabile)
L'algoritmo di ordinamento di conteggio è utile solo nel caso speciale in cui gli elementi a
essere ordinato hanno pochissimi valori possibili.
Specifiche:
Precondizioni: l'input è un elenco di N valori A0 ,..., an -1, ciascuno all'interno dell'intervallo
0 ,..., k −1.

---
layout: 
title: Pagina 89
level: 3
---


Algoritmi di smistamento iterativo
73
PostConditions: l'output è un elenco costituito dagli stessi valori N in ordine non aressante.Il tipo è stabile, il che significa che se due elementi hanno lo stesso
Valuta, quindi devono apparire nello stesso ordine nell'output dell'ingresso.
(Questo è importante quando vengono trasportati dati extra con ciascun elemento.)
Passaggi di base:
Dove va un elemento: considera qualsiasi elemento dell'input.Contando, lo faremo
Determina dove questo elemento appartiene all'output, e quindi lo mettiamo semplicemente
Là.Dove appartiene è determinato dal numero di elementi che devono apparire prima di esso.Per semplificare l'argomento, indicizziamo le posizioni con [0, n −1].
In questo modo, l'elemento nella posizione indicizzata da 0 non ha elementi prima di esso e
l'elemento in posizione
C ha
C elementi prima di esso.
Supponiamo che l'elemento AI abbia il valore v. Ogni elemento che ha un rigoroso
un valore più piccolo deve andare prima.Indichiamo questo conteggio con
cv, cioè,
cv =
| {j |a j <v} |.Gli unici altri elementi che vanno prima dell'IA sono elementi con esattamente
lo stesso valore.Poiché l'ordinamento deve essere stabile, il numero di questi che vanno prima è lo stesso del numero che appare prima nell'ingresso.Se questo numero
capita di essere Qai, quindi l'elemento AI appartiene alla posizione
Cv + Qai.In particolare, il
Il primo elemento nell'ingresso con il valore V va in posizione
CV + 0.
Esempio:
Ingresso:
1 0 1 0 2 0 0 1 2 0
Produzione:
0 0 0 0 0 0 1 1 1 2 2
Indice:
0 1 2 3 4 5 6 7 8 9
Il primo elemento ad apparire nell'ingresso con il valore 0 va nella posizione 0, perché ci sono
C0 = 0 elementi con valori più piccoli.Il prossimo elemento di questo tipo
va nella posizione 1, il prossimo in 2 e così via.
Il primo elemento ad apparire nell'ingresso con il valore 1 va nella posizione
5, perché ci sono
C1 = 5 elementi con valori più piccoli.Il prossimo elemento del genere va nella posizione 6 e il successivo in 7.
Allo stesso modo, il primo elemento con il valore 2 va in posizione
C2 = 8.
Calcolo
CV: potremmo calcolare
cv facendo un passaggio attraverso l'input, contando il numero di elementi che hanno valori più piccoli di v. facendo questo separatamente per ogni valore v ∈ [0..k −1], tuttavia, richiederebbe il tempo O (kn), che è
troppo.
Invece, contiamo per la prima volta quante volte ogni valore si verifica nell'input.Per
ogni v ∈ [0..k −1], let cv = | {i |ai = v} |.Questo conteggio può essere calcolato con uno
passare attraverso l'input.Per ogni elemento, se l'elemento ha il valore V, incremento
il contatore cv.Ciò richiede solo operazioni di aggiunta e di indicizzazione di O (N).
Dati i valori CV, potremmo calcolare
cv = v - 1
V ′ = 0 cv.Calcolo di uno di questi

CV richiederebbe aggiunte di O (k) e il calcolo di tutti prenderebbe O (K2)
aggiunte, che è troppo.

---
layout: 
title: Pagina 90
level: 3
---


Algoritmi iterativi e invarianti ad anello
74
In alternativa, notare che
c0 = 0 e
cv =
CV - 1 + CV - 1.Certo, dobbiamo averlo
calcolato i valori precedenti prima di calcolare il successivo.Ora calcolando uno
tale
CV prende le aggiunte O (1) e il calcolo di tutti assume solo aggiunte O (k).
Mettere in atto: il ciclo principale nell'algoritmo considera gli elementi di input uno
in un momento nell'ordine A0 ,..., an -1 che appaiono nell'input e li posiziona
Nell'array di output a cui appartengono.
Il ciclo invariante:
1. Gli elementi di input che sono già stati considerati sono stati messi nel loro
Posizioni corrette nell'output.
2. Per ogni v ∈ [0..k −1],
CV fornisce l'indice nell'array di output dove il successivo
L'elemento di input con il valore V va.
Stabilire l'invariante del loop: calcola i conteggi
CV come descritto sopra.Questo
stabilisce il ciclo invariante prima che vengano considerati qualsiasi elemento di input, perché questo

Il valore CV fornisce la posizione in cui va il primo elemento con il valore V.
Passaggio principale: prendi l'elemento di input successivo.Se ha il valore V, posizionarlo nella posizione di output indicizzata da
CV.Quindi incremento
CV.
Mantieni il loop invariante: ⟨loop-invariant ′⟩ & no
⟨Exit-Cond⟩ & Codeloop
⇒
⟨Loop-invariant ′ ′⟩.Dal ciclo invariante, sappiamo che se il prossimo elemento di input ha
Valore V, quindi appartiene alla posizione di output indicizzata da
CV.Quindi, viene messo
Nel posto corretto.L'elemento di input successivo con il valore V andrà immediatamente
Dopo questa corrente nell'output, cioè nella posizione
CV + 1. Quindi, incrementazione
CV
Mantiene la seconda parte dell'invariante in loop.
Condizione di uscita: una volta considerati tutti gli elementi di input, il primo loop
Invariant stabilisce che l'elenco è stato risolto.
Codice:
∀v ∈ [0..k −1], cv = 0
Loop i = 0 a n −1
+ + Ca [i]

C0 = 0
Loop v = 1 a k −1

cv =
CV - 1 + CV - 1
Loop i = 0 a n −1
B [
ca [i]] = a [i]
+ +
Ca [i]

---
layout: 
title: Pagina 91
level: 3
---


Algoritmi di smistamento iterativo
75
Tempo di esecuzione: il tempo totale è O (n + K) Operazioni di aggiunta e indicizzazione.Se la
L'ingresso può contenere solo K = O (n) Valori possibili, quindi questo algoritmo funziona in lineare
tempo.Non funziona bene se il numero di possibili valori è molto più elevato.
5.3
Radix Ord
L'ordinamento di Radix è un algoritmo utile che risale ai giorni delle macchine per il disordinazione delle carte, ora presente solo nei musei del computer.
Specifiche:
Precondizioni: l'input è un elenco di valori N.Ogni valore è un numero intero con cifre D.Ogni cifra è un valore da 0 a k −1, cioè il valore è visto come un numero intero
base k.
PostConditions: l'output è un elenco costituito dagli stessi valori N in ordine non aressante.
Passaggi di base: per alcune digiti ∈ [1..d], ordina l'input in base alla cifra, ignorando le altre cifre.Usa un tipo stabile, come il conteggio dell'ordinamento.
Esempi: vecchie schede di punch al computer sono state organizzate in d = 80 colonne e
In ogni colonna un foro potrebbe essere dato un pugno in uno di K = 12 posti.Un assorbimento di carte
La macchina potrebbe esaminare meccanicamente ogni carta in un mazzo e distribuire la carta
in uno dei 12 bidoni, a seconda di quale buco era stato pulito in un specificato
colonna.
Un "valore" potrebbe consistere in un anno, un mese e un giorno.Potresti quindi ordinare il
elementi entro l'anno, entro il mese o di giorno.
Ordine in cui considerare le cifre: è più naturale ordinare rispetto a
La cifra più significativa.Il tipo finale, dopo tutto, ha tutti gli elementi con a
0 come prima cifra all'inizio, seguita da quelle con 1.
Se l'operatore della macchina per il calcio della carta ordinata prima della cifera più significativa, otterrebbe 12 pile.Ognuna di queste pile dovrebbe quindi essere risolta
separatamente, secondo le cifre rimanenti.Ordinando la prima pila secondo
La seconda cifra produrrebbe altre 12 pile.L'ordinamento del primo di quelle pile in base alla terza cifra produrrebbe altre 12 pile.L'intero processo lo farebbe
Sii un incubo.
L'ordinamento rispetto alla cifra meno significativa sembra sciocco al primo posto.Ordinamento
⟨79, 94, 25⟩gives ⟨94, 25, 79⟩, che è completamente sbagliato.Anche così, questo è ciò che
L'algoritmo lo fa.
L'algoritmo: loop attraverso le cifre da basso a alto ordine.Per ciascuno, usa un file
ordinamento stabile per ordinare gli elementi in base alla cifra corrente, ignorando l'altro
cifre.

---
layout: 
title: Pagina 92
level: 3
---


Algoritmi iterativi e invarianti ad anello
76
Esempio:
Ordinato per primo
3 cifre
Considerando
4a cifra
Stabilmente ordinato
entro la 4a cifra
184
3184
1195
192
5192
1243
195
1195
1311
243
1243
3184
271
3271
3271
311
1311
5192
Il risultato è ordinato per le prime quattro cifre.
Loop invariant: dopo l'ordinamento rispetto a (wrt) le prime cifre di basso ordine, le
Gli elementi sono ordinati WRT il valore formato da queste cifre.
Stabilire l'invariante del loop: l'invariante in loop è inizialmente banalmente vero, perché inizialmente non sono state considerate cifre.
Mantieni il loop invariante: ⟨loop-invariant ′⟩ & no
⟨Exit-Cond⟩ & Codeloop
⇒
⟨Loop-invariant ′ ′⟩.Supponiamo che gli elementi siano ordinati WRT il valore formato
le cifre i −1 più basse.Per gli elementi da ordinare wrt il valore formato da
Le cifre più basse, tutti gli elementi con uno 0 nella cifra devono essere prima, seguiti da
quelli con un 1 e così via.Questo può essere realizzato ordinando gli elementi wrt
con cifre mentre ignori le altre cifre.Inoltre, il blocco di elementi con uno 0 in
Le cifre devono essere ordinate WRT le cifre di Lowesti −1.Dal ciclo invariante, erano
In questo ordine, e poiché l'ordinamento wrt la sua cifra era stabile, questi elementi lo faranno
rimanere nello stesso ordine relativo.Lo stesso vale per il blocco di elementi con a
1 o 2 o...Nella cifra.
Fine: ⟨loop-invariante⟩ & ⟨exit-cond⟩ & codepost-loop ⇒post −cond⟩.Quando i = D, sono ordinati WRT il valore formato da tutte le cifre D e quindi sono ordinati.
5.4
RADIX CONTENGE TORNO
Ora combinerò il radix e il tipo di conteggio.Si dice che l'algoritmo risultante
In tempo lineare (N), mentre si dice che si uniscono, rapido e un heap è in esecuzione in (n logn)
tempo.Questo rende il conteggio di Radix sembra essere più veloce, ma questo è confuso e fuorviante.Il conteggio di Radix richiede operazioni di bit (n), dove n è il numero totale
di bit nell'istanza di input.Unisci, rapido e heap Ordine richiedono (n log n) confronti, dove n è il numero di numeri nell'elenco.Supponendo che i numeri n da ordinare siano distinti, ciascuno ha bisogno (log n) bit da rappresentare, per un totale
di n = (n log n) bit.Quindi, unire, rapidamente e un heap è anche tempo lineare
che richiedono operazioni (n) bit, dove n è il numero totale di bit nell'input
esempio.

---
layout: 
title: Pagina 93
level: 3
---


Algoritmi di smistamento iterativo
77
In pratica, l'algoritmo di conteggio di Radix può essere un po 'più veloce degli altri algoritmi.Tuttavia, l'ordinamento rapido e heap ha il vantaggio di essere fatto "in atto"
In memoria, mentre l'ordinamento del conteggio di Radix richiede una serie ausiliaria di memoria
Trasferisci i dati a.
Specifiche:
Precondizioni: l'input è un elenco di valori N.Ogni valore è un numero intero a L-Bit.
PostConditions: l'output è un elenco costituito dagli stessi valori N in ordine non aressante.
L'algoritmo: l'algoritmo è usare RADIX Ordina con il conteggio dell'ordinamento per ordinare ciascuno
cifra.Per fare ciò, dobbiamo visualizzare ogni valore L-Bit come un numero intero con le cifre, dove
Ogni cifra è un valore da 0 a k −1.Questo viene fatto dividendo i bit L in blocchi D
di l
d bit ciascuno e trattando ciascuno di questi blocchi come una cifra tra 0 e k −1, dove
K = 2L/d.Qui D è un parametro da impostare in seguito.
Esempio: considera di ordinare i numeri 30, 41, 28, 40, 31, 26, 47, 45. Qui N = 8
e l = 6. Imposta d = 2 e dividiamo i blocchi l = 6 in d = 2 di l
d = 3 bit ciascuno.
Tratta ciascuno di questi blocchi come una cifra tra 0 e k −1, dove k = 23 = 8. Ad esempio, 30 = 0111102 fornisce i blocchi 0112 = 3 e 1102 = 6.
Per tutti i numeri:
30 = 368 = 011 1102
41 = 518 = 101 0012
28 = 348 = 011 1002
40 = 508 = 101 0002
31 = 378 = 011 1112
26 = 328 = 011 0102
47 = 578 = 101 1112
45 = 558 = 101 1012
Smistamento stabile wrt il
cifre per la prima volta:
40 = 508 = 101 0002
41 = 518 = 101 0012
26 = 328 = 011 0102
28 = 348 = 011 1002
45 = 558 = 101 1012
30 = 368 = 011 1102
31 = 378 = 011 1112
47 = 578 = 101 1112
Ordinamento stabile wrt il secondo
cifra:
26 = 328 = 011 0102
28 = 348 = 011 1002
30 = 368 = 011 1102
31 = 378 = 011 1112
40 = 508 = 101 0002
41 = 518 = 101 0012
45 = 558 = 101 1012
47 = 578 = 101 1112
Questo è ordinato.
Tempo di esecuzione: usando l'ordinamento del conteggio da ordinare rispetto a una delle cifre D
prende (n + k) operazioni.Quindi, l'intero algoritmo prende operazioni (d · (n + k)).Abbiamo d =
l
log k, dando t = (
l
Log K · (n + k)) operazioni.
Il parametro k (come l) non è dettato dalle specifiche del problema, ma
può essere scelto liberamente dall'algoritmo.Esercizio 23.1.4 imposta k = o (n) per ridurre al minimo il tempo di esecuzione a t = (
l
Log n n) Operazioni.
Formalmente, la complessità del tempo misura il numero di operazioni di bit eseguite
in funzione del numero di bit per rappresentare l'input.Quando lo diciamo

---
layout: 
title: Pagina 94
level: 3
---


Algoritmi iterativi e invarianti ad anello
78
Conteggio Ordina (n + k) operazioni, una singola operazione deve essere in grado di aggiungerne due
Valori con grandezza (N) o per indicizzare in array di dimensioni n (o k).Ognuno di questi
prende (log n) operazioni bit.Quindi, il tempo totale per ordinare è t = (
l
log n n) operazioni × log n (operazioni bit)/operazione = (l · n) operazioni bit.L'input, costituito da valori di n-bit N, richiede n = l · n bit per rappresentarlo.Quindi, la corsa
Il tempo (l · n) = (n) è lineare nella dimensione dell'input.
Un esempio è quando si ordinano i valori N nell'intervallo da 0 a Nr.Ogni valore richiede l = log nr = r log n bit per rappresentarlo, per un totale di n = n log (nr) = r n bit.
Le nostre impostazioni sarebbero quindi k = n, d =
l
log n = r e t = (d · n) = (r n) = (n).

---
layout: 
title: Pagina 95
level: 3
---


79
6 Algoritmo GCD di Euclid
Gli algoritmi iterativi più input estendono una soluzione per un'istanza di input più piccola
in uno più grande.Nel capitolo 9 vedremo che anche gli algoritmi ricorsivi lo fanno.IL
Di seguito è riportato un algoritmo straordinario che lo fa.Trova il più grande divisore comune
(GCD) di due numeri interi.Ad esempio, GCD (18, 12) = 6. è stato fatto prima da Euclid, un
Greco antico.Senza l'uso di invarianti ad anello, non saresti mai in grado di capire cosa fa l'algoritmo;Con il loro aiuto, è facile.
Specifiche: un'istanza di input è costituita da due numeri interi positivi, a e b.IL
L'output è GCD (A, B).
The Loop Invariant: come molti invarianti ad anello, progettando questa creatività richiesta.L'algoritmo mantiene due variabili xey i cui valori cambiano con ciascuno
L'iterazione del loop sotto l'invariante che il loro GCD, GCD (X, Y) non cambia, ma rimane uguale al GCD di uscita richiesto (A, B).
Tipo di loop invariante: questo è uno strano loop invariante.L'algoritmo è più
come ricorsione.Una soluzione a un'istanza minore del problema fornisce la soluzione
all'originale.
Stabilire l'invariante del loop: il modo più semplice per stabilire l'invariante invariante che GCD (X, Y) = GCD (A, B) è impostando X su A e Y a B.
Misura del progresso: viene fatto progressi rendendo più piccolo x o y.
Fine: usciremo quando x o y è abbastanza piccolo da poter calcolare il loro GCD
facilmente.Con il ciclo invariante, questa sarà la risposta richiesta.
Un'iterazione media su un'istanza generale: consideriamo prima una situazione generale in cui X è più grande di Y ed entrambi sono positivi.

---
layout: 
title: Pagina 96
level: 3
---


Algoritmi iterativi e invarianti ad anello
80
Passaggi principali: il nostro obiettivo è quello di rendere più piccolo X o Y senza cambiare il loro GCD.UN
Fatto utile è che GCD (X, Y) = GCD (X −y, Y), ad esempio GCD (52, 10) = GCD (42, 10) =
2, perché qualsiasi valore che divide x e y divide anche x −y e allo stesso modo qualsiasi
Valore che divide x −y e y divide anche x.Quindi, sostituire x con x −y lo farebbe
Fai progressi mantenendo l'invariante del loop.
Tempo di esecuzione esponenziale?Una buona idea quando si considera un loop invariante e le iterazioni è quella di saltare avanti nella progettazione dell'algoritmo e stimare il suo tempo di esecuzione.Un loop che esegue solo x = x −y iterirà a
B volte.
Tuttavia, anche se B = 1, questa è solo una iterazioni.Sembra che sia tempo lineare.
Tuttavia, dovresti esprimere il tempo di esecuzione di un algoritmo come funzione
di dimensioni input.Vedere la sezione 23.1.Il numero di bit necessari per rappresentare l'istanza ⟨a, b⟩is n = loga + logb.Espresso in questi termini, il tempo di esecuzione è
Tempo (n) = (a) = (2n).Questo è tempo esponenziale.Se a = 1.000.000.000.000.000
e b = 1, non vorrei aspettarlo.
Passi principali più veloci: una cosa da provare di fronte al tempo di esecuzione esponenziale è
Per cercare un modo per accelerare i passaggi principali.Invece di sottrarre uno y da
X ogni iterazione, perché non accelerare il processo sottraendo un multiplo di y tutti
subito?Potremmo impostare xnew = x −d · y per un valore intero di d.Il nostro obiettivo è quello di
Rendi XNew il più piccolo possibile senza renderlo negativo.Chiaramente, D dovrebbe essere
⌊X
y ⌋.Questo dà xnew = x −⌊x
y ⌋ · y = x mod y, che è all'interno dell'intervallo [0..y −1]
ed è il resto quando si dividono y in x.Ad esempio, 52 Mod 10 = 2.
Mantenimento dell'invariante del ciclo: il passaggio xnew = x mod y mantiene il loop
invariante perché gcd (x, y) = gcd (x mod y, y), ad esempio GCD (52, 10) = GCD (2, 10) = 2.
Fare progressi: il passaggio xnew = x mod y fa progressi rendendo x più piccolo
Solo se x mod y è più piccolo di x.Questo è vero solo se x è maggiore o uguale a
y.Supponiamo che inizialmente questo sia vero perché a è maggiore di b.Dopo un'iterazione, xnew = x mod y diventa più piccolo di y.Quindi la prossima iterazione non farà nulla.UN
La soluzione è quindi scambiare xey.
Nuovi passaggi principali: combinare xnew = x mod y con uno swap fornisce i passaggi principali di
xnew = y e ynew = x mod y.
Mantenimento dell'invariante in loop: questo mantiene il nostro loop invariante originale perché GCD (x, y) = GCD (y, x mod y), ad esempio GCD (52, 10) = GCD (10, 2) = 2.
Mantiene il nuovo ciclo invariante che 0 ≤y ≤x.
Fare progressi: perché ynew = x mod y ∈ [0..y −1] è più piccolo di y, facciamo
progressi rendendo Y più piccolo.
Casi speciali: Impostazione x = a e y = b non stabilisce l'invariante del loop, che
dice che x è almeno y se a è più piccolo di b.Una soluzione ovvia è inizialmente testare

---
layout: 
title: Pagina 97
level: 3
---


Algoritmo GCD di Euclid
81
Per questo e per scambiare xey se necessario.Tuttavia, come consigliato nella Sezione 1.2, lo è
A volte fruttuoso per provare a rintracciare ciò che l'algoritmo che hai già progettato farebbe dato un tale input.Supponiamo che a = 10 e b = 52. la prima iterazione
imposterebbe xnew = 52 e ynew = 10 mod 52. quest'ultimo valore è un numero all'interno del
intervallo [0..51] che è il resto quando si dividono 10 per 52. Chiaramente questo è 10. Quindi, il codice scambia automaticamente i valori impostando xnew = 52 e ynew = 10. Pertanto, non è necessario un nuovo codice.Allo stesso modo, IFA e B sono negativi, l'iterazione iniziale
Renderà Y positivo e il prossimo renderà positivo sia xey.
Condizione di uscita: stiamo facendo progressi rendendo Y più piccolo.Dovremmo fermarci quando
Y è abbastanza piccolo da poter calcolare facilmente il GCD.Proviamo piccoli valori di Y.
Usando GCD (x, 1) = 1, il GCD è facile da calcolare quando y = 1;Tuttavia, non lo faremo mai
Ottieni questo a meno che GCD (A, B) = 1. Che ne dici di GCD (x, 0)?Questo risulta essere x, perché
X si divide uniformemente in X e 0. Proviamo una condizione di uscita di y = 0.
Terminazione: sappiamo che il programma alla fine si fermerà come segue: ynew =
x mod y ∈ [0..y −1] garantisce che ogni passaggio y diventa rigorosamente più piccolo e non vada
negativo.Quindi, alla fine Y deve essere zero.
Ending: formalmente dimostriamo che ⟨loop-invariante⟩ & ⟨exit-Cond⟩ & codepost-loop ⇒
⟨Post-Cond⟩.Vediamo che ⟨loop-invariant⟩gives gcd (x, y) = gcd (a, b) e ⟨exitcond ⟩gives y = 0. quindi, gcd (a, b) = gcd (x, 0) = x.Il codice finale restituirà il
valore di x.Ciò stabilisce che viene restituito il ⟨Post-Cond⟩ che GCD (A, B).
Codice:
Algoritmo GCD (A, B)
⟨Pre-Cond⟩: a e b sono numeri interi.
⟨Post-Cond⟩: restituisce GCD (a, b).
inizio
int x, y
x = a
y = b
ciclo continuo
⟨Loop-Invariant⟩: GCD (X, Y) = GCD (A, B).
if (y = 0) uscita
xnew = y, ynew = x mod y
x = xnew
y = ynew
End Loop
restituzione (x)
Algoritmo di fine

---
layout: 
title: Pagina 98
level: 3
---


Algoritmi iterativi e invarianti ad anello
82
Esempio: le seguenti traccia l'algoritmo fornite due istanze di input, ⟨A, B⟩ =
⟨22, 33⟩and ⟨A, B⟩ = ⟨1.000.000.005, 999.999.999⟩.
Iterazione
Valore di x
Valore di y
1 °
22
32
2 °
32
22
3 °
22
10
4 °
10
2
5 °
2
0
GCD (22, 32) = 2.
Iterazione
Valore di x
Valore di y
1 °
1.000.000.005
999.999.999
2 °
999.999.999
6
3 °
6
3
4 °
3
0
GCD (1.000.000.005, 999.999.999) = 3
Tempo di esecuzione: affinché il tempo di esecuzione sia lineare nella dimensione dell'input, il numero di bit (log y) per rappresentare Y deve diminuire di almeno uno in ogni iterazione.Questo
significa che il valore di Y deve diminuire di almeno un fattore due.Considera l'esempio di x = 19 e y = 10. quindi ynew diventa 19 mod 10 = 9, che è solo una diminuzione
di uno.Tuttavia, il prossimo valore di Y sarà 10 Mod 9 = 1, che è un calo enorme.
Saremo in grado di dimostrare che ogni due iterazioni, Y scende di un fattore 2, vale a dire che yk+2 <yk/2.Ci sono due casi.Nel primo caso, yk+1 ≤yk/2.Allora siamo
Fatto, perché, come indicato sopra, yk+2 <yk+1.Nel secondo caso, yk + 1 ∈ [yk/2 + 1, yk −1].La svolgimento dell'algoritmo fornisce quell'ia+2 = xk+1 mod yk+1 = yk mod yk+1.Uno
L'algoritmo per il calcolo di yk mod yk+1 è sottrarre continuamente yk+1 da yk fino al
L'importo è inferiore a YK+1.Poiché YK è più di YK+1, questo YK+1 viene sottratto almeno
una volta.Ne consegue che yk mod yk+1 ≤yk −yk+1.Nel caso, yk+1> yk/2.In conclusione, yk+2 = yk mod yk+1 ≤yk −yk+1 <yk/2.
Dimostriamo che il numero di volte in cui il ciclo iterato è O (log (min (a, b))) =
O (n), come segue.Dopo la prima o la seconda iterazione, y è min (a, b).Ogni iterazione y
scende di almeno un fattore 2. Quindi, dopo k iterazioni, YK è al massimo min (a, b)/2k e dopo O (log (min (a, b))) iterazioni che è al massimo.
L'algoritmo itera un numero lineare O (n) di volte.Ogni iterazione deve fare un file
Operazione mod.Il povero euclide ha dovuto calcolarli a mano, il che deve essere ottenuto
molto noioso.Un computer può essere in grado di fare mod in un'unica operazione;comunque, il
Il numero di operazioni di bit necessarie per due input N-bit è O (n logn).Quindi, il tempo
La complessità di questo algoritmo GCD è O (N2 Log).
Lower Bound: We will prove a lower bound, not of the minimum time for any algorithm to ﬁnd the GCD, but of this particular algorithm, by ﬁnding a family of input values ​​⟨a, b⟩for which the program loops (log(min (a, b))) volte.Svolgersi
Il codice fornisce yk+2 = xk+1 mod yk+1 = yk mod yk+1.Come affermato, YK Mod YK+1 viene calcolato sottraendo YK+1 da YK un numero di volte.Vogliamo che gli Y si riducano
il più lentamente possibile.Quindi, diciamo che viene sottratto solo una volta.Questo da
yk+2 = yk −yk+1 o yk = yk+1+yk+2.Questa è la definizione dei numeri di fibonacci,

---
layout: 
title: Pagina 99
level: 3
---


Algoritmo GCD di Euclid
83
Solo all'indietro, cioè Fib (0) = 0, Fib (1) = 1 e Fib (N) = Fib (N - 1) + FIB (N - 2).
(Vedi Esercizio 27.2.1.) Sull'input A = Fib (n + 1) e B = FIB (N), il programma iterate
volte.Questo è (log (min (a, b))), perché fib (n) = 2 (n).
Esercizio 6.0.1
Converge algoritmo (xorigeno)
⟨Pre-Cond⟩: xorigeno ∈ [0 ,..., 1].
⟨Post-Cond⟩: questo algoritmo restituisce il valore convergente ???
o corre per sempre
inizio
X = xoriginale
ciclo continuo
⟨Loop-invariant⟩: x ∈ [0 ,..., 1]
Esci quando (x = f (x))
x = f (x)
End Loop
restituzione (x)
Algoritmo di fine
Questa è la funzione F usata.
1.0
0.8
0.6
0.4
0.2
1.0
0.8
0.6
0.4
0.2
X
1.2
–0.2
0.0
F (x)
1.
Dimostrare che l'algoritmo stabilisce correttamente l'invariante loop.
2.
Dimostra che viene mantenuto l'invariante in loop.
3.
Compila il resto della postcondizionamento dando il più specifico possibile quale valore
viene restituito da questo algoritmo quando converge.Dimostrare che se l'algoritmo
si ferma, quindi questa postcondizionamento viene soddisfatta.
4.
Cambia l'algoritmo in modo che abbia anche un input intero n e si fermi dopo le n iterazioni.Qual è il tempo di esecuzione (complessità del tempo) di questo algoritmo come funzione
delle dimensioni dell'input?
5.
Cambia l'algoritmo in modo che si fermi dopo un miliardo di iterazioni.Qual è la corsa
Tempo (complessità del tempo) di questo algoritmo in funzione della dimensione dell'input?
Esercizio 6.0.2 (vedi soluzione nella quinta parte.) Gli antichi egizi e gli etiopi avevano
Matematica avanzata.Semplicemente dimezzando e raddoppiando, potrebbero moltiplicare due
numeri correttamente.Supponiamo che volessero comprare 15 pecore a 13 dollari etiopi ciascuno.Qui
è il modo in cui hanno affidato il prodotto.Metti 13 in una colonna sinistra, 15 a destra.Dimezzare
il valore sinistro;Ottieni 6 1
2. Ignora il 1
2. Raddoppia il valore giusto.Ripeti (mantenendo tutto
valori intermedi) fino a quando il valore sinistro è 1. quello che hai è
13
15
6
30
3
60
1
120

---
layout: 
title: Pagina 100
level: 3
---


Algoritmi iterativi e invarianti ad anello
84
Anche i numeri nella colonna di sinistra sono malvagi e, secondo la storia, devono essere distrutti, insieme ai loro partner di colpevolezza.Quindi gratta il 6 e il suo partner 30. Ora aggiungi il
Colonna a destra, dando 15 + 60 + 120 = 195, che è la risposta corretta.
1.
Scrivi pseudocodi che, dati due numeri interi positivi xey, segue questa procedura
e produce il valore risultante.Parte del ciclo invariante è che la variabile ℓ
detiene il valore sinistro corrente, r il valore destro corrente e s la somma di tutti i precedenti
Valori giusti che saranno inclusi nella risposta finale.Rompere l'algoritmo all'interno
il ciclo in due passaggi.Nel primo passaggio, se è dispari, diminuisce di uno.Nel secondo
Il passaggio ℓ (ora pari) è diviso per due.Questi passaggi devono aggiornare R e S secondo necessità.
2.
Dai un ciclo significativo invariante relativo ai valori attuali di ℓ, r, s, x e y.
(Suggerimento: guarda il loop GCD invariante.) Oltre a questo invariante è vero
Ogni volta che il calcolo è in cima al ciclo, sarà anche vero ogni volta
Il calcolo è tra il primo e il secondo passaggio di ciascuna iterazione.Dimostrare
Che il tuo algoritmo stabilisce e mantiene l'invariante invariante come indicato.
3.
Disegna immagini per dare una spiegazione geometrica per i passaggi.
4.
Qual è la condizione di uscita etiope?Come potresti migliorare su questo?Come faccio
la condizione di uscita, il loop invariante e forse un codice extra stabilisce il
Postcondition?
5.
Supponiamo che le istanze di input xey siano numeri n-bit.Quanti
Le operazioni di bit vengono utilizzate dal tuo algoritmo, in funzione di N?(Aggiunta di due n′-bit
I numeri richiedono tempo O (n ′).) Supponiamo che gli etiopi siano contati con i ciottoli.Come
Molte operazioni di ciottoli hanno richiesto il loro algoritmo?Come si confrontano questi tempi?
Come si confrontano questi tempi con l'algoritmo del liceo per la moltiplicazione?Come
Si confrontano con la distribuzione di un rettangolo di ciottoli X by y e quindi contano
loro?
6.
Questo algoritmo sembra molto strano.Confrontalo con l'utilizzo dell'algoritmo della scuola superiore per moltiplicare nel binario.

---
layout: 
title: Pagina 101
level: 3
---


85
7 Il ciclo invariante per limiti inferiori
Complessità del tempo: la complessità temporale di un problema computazionale P è il tempo minimo necessario da un algoritmo per risolverlo:
∃a, ∀i,
A (i) = p (i) e tempo (a, i) ≤t
Upper (| i |)

∀a, ∃i,
A (i) ̸ = p (i) o tempo (a, i) ≥tlower (| i |)

Notazione asintotica: quando vogliamo limitare il tempo di esecuzione di un algoritmo
Mentre ignoriamo le costanti moltiplicative, utilizziamo la seguente notazione.
Nome
Notazione standard
La mia notazione
Senso
Theta
f (n) = (g (n))
f (n) ∈ (g (n))
f (n) ≈c · g (n)
Bigoh
f (n) = o (g (n))
f (n) ≤o (g (n))
f (n) ≤c · g (n)
Omega
f (n) = (g (n))
f (n) ≥ (g (n))
f (n) ≥c · g (n)
Vedi il capitolo 25.
Un limite superiore è un algoritmo: un limite superiore per p si ottiene costruendo un algoritmo A che produce la risposta corretta, vale a dire A (i) = P (i), all'interno
Il tempo limitato, cioè tempo (a, i) ≤t
Upper (| i |), su ogni istanza di input I.
Un limite inferiore è un algoritmo: abbastanza divertente, un limite inferiore, dimostrandolo
Non esiste un algoritmo più veloce per il problema p, si ottiene anche costruendo un
Algoritmo, ma è un algoritmo per un problema diverso.L'input a questo problema è
Un algoritmo che richiede di risolvere P nel tempo richiesto.L'output, come prova che questo
è falso, è un'istanza di input i su cui l'algoritmo a base di uno dei due non dà il
Risposta corretta, vale a dire, a (i) ̸ = p (i) o usa troppo tempo, vale a dire tempo (a, i) ≥
Tlower (| i |).
Leggi l'appendice: per capirlo meglio potresti dover leggere due discussioni nell'Appendice (parte quarta): Capitolo 22 su come pensare alle dichiarazioni con

---
layout: 
title: Pagina 102
level: 3
---


Algoritmi iterativi e invarianti ad anello
86
Quantiumi esistenziali e universali come gioco tra due giocatori e la sezione 23.2
complessità del tempo.
Argomento circolare: dimostrare limiti inferiori possono portare al seguente argomento circolare.Dato un algoritmo arbitrario a, dobbiamo trovare un'istanza di input per la quale
A dà la risposta sbagliata.Il problema è che non si sa per quale istanza di input l'algoritmo darà la risposta sbagliata fino a quando non sai cosa l'algoritmo
fa.Ma non sai cosa fa l'algoritmo fino a quando non gli dai un'istanza di input
e eseguilo.Questo paradosso viene evitato percorrendo il calcolo su uno
Passaggio temporale alla volta, ad ogni passaggio restringendo lo spazio di ricerca per I. Questo rende il tuo algoritmo per risolvere il problema limitato inferiore un algoritmo iterativo.In quanto tale, ha bisogno
Un loop invariante.
L'argomento invariante del loop:
Conoscenza: in ogni fase temporale, le azioni intraprese dall'algoritmo dipendono dal
Conoscenza che ha già raccolto.Ad esempio, se l'ingresso è ⟨x1 ,..., xn⟩
e durante la prima fase del tempo un test se x5 <x6, allora può basare ciò che fa
Durante la seconda fase di tempo su se x5 <x6, ma non lo sa ancora
qualsiasi altra cosa sull'istanza di input.Definiamo la conoscenza, o dichiaramo di esserlo
determinato dai valori delle sue variabili (ad eccezione delle variabili che conservano l'istanza di input) e su quale riga di codice.
L'anello invariante: l'invariante in loop sarà un classico tipo di spazio restrittivo.Dichiara che abbiamo una serie di istanze di input su quale algoritmo
La conoscenza e le azioni di A per le sue prime fasi di tempo T sono identiche.
Stabilire l'invariante del loop: inizialmente il set è un ampio set di istanze
su cui vogliamo concentrarci.L'anello invariante è banalmente stabilito per T = 0, perché inizialmente l'algoritmo non sa nulla e non ha fatto nulla.
Mantenimento dell'invariante in loop: l'invariante invariante viene mantenuto come segue.Supponiamo che sia vero al momento t −1.Anche se non sappiamo quale istanza di input
Io da S alla fine sarà dato all'algoritmo A, sappiamo che ciò che impara
Durante le sue prime fasi temporali T -1 sono indipendenti da questa scelta.A, sapendo cosa
ha imparato durante questi primi passaggi T -1, ma non è consapevole che non sia stato dato
Un'istanza di input specifica, indicherà quindi quale azione farà durante il passo
T.Ciò che impara al tempo t da questa azione dipenderà da quale istanza i ∈
è dato a A., quindi partiamo in base a ciò che impara e si restringe
a una di queste parti.Questo mantiene l'invariante in loop, cioè di avere una serie di
istanze di input su cui l'algoritmo A le conoscenze e le azioni per il suo primo t
I passaggi temporali sono identici.
Misura del progresso: la misura del progresso per il nostro algoritmo limitato inferiore è
Questo non diventa troppo più piccolo.

---
layout: 
title: Pagina 103
level: 3
---


Il ciclo invariante per limiti inferiori
87
Condizione di uscita: la condizione di uscita è quindi t = tlower (| i |).
Fine: dall'invariante del loop e dalla condizione di uscita, otteniamo la postconditazione trovando due istanze di input i e i ′ in s per le quali il problema computazionale p richiede output diversi: p (i) ̸ = p (i ′).Se, su istanza I, l'algoritmo A o non dà la risposta corretta, in modo che a (i) ̸ = p (i) o usi
Troppo tempo, quindi quel tempo (a, i) ≥Tlower (| i |), quindi la postconditazione viene soddisfatta.
Altrimenti, rivolgiamo la nostra attenzione all'istanza I ′.Dal ciclo invariante e il
condizione di uscita, il calcolo di a è identico alle due istanze I e i ′ per
I primi passi temporali (| i |), perché sia ​​io che io sono in S., quindi le loro uscite
Deve essere identico: a (i) = a (i ′).Dalla nostra scelta di istanze, p (i) ̸ = p (i ′).Perché
A (i) = p (i), ne consegue che a (i ′) ̸ = p (i ′).Ancora una volta abbiamo trovato un'istanza su
che A non dà la risposta corretta e la postcondizionamento viene soddisfatta.
Esempio 7.1
Ordinamento
Abbiamo visto un numero di algoritmi che possono ordinare N numeri usando O (n log n) confronti tra gli elementi, come unione, rapido e heap.Lo dimostreremo
Nessun algoritmo può ordinare più velocemente.
Teoria dell'informazione: la tecnica dei limiti inferiore appena descritta non considera la quantità di lavoro che deve essere svolta per risolvere il problema, ma il
quantità di informazioni che devono essere trasferite dall'input all'output.
Il problema con questi limiti inferiori è che non sono più grandi che lineari
Rispetto alla dimensione del bit dell'input e dell'output.
n = (n log n): al primo posto può apparire che si tratta di un limite inferiore superlineare.
Tuttavia, n è il numero di elementi nell'elenco.Supponendo che i N numeri
da ordinare sono distinti, ogni bisogno (log n) bit da rappresentare, per un totale di
n = (n log n) bit.Quindi, il limite inferiore non lo dice in realtà più di
(n) Le operazioni di bit sono richieste quando n è il numero totale di bit nell'input
esempio.
Definizione dell'operazione binaria: prima di poter dimostrare che non esiste algoritmo
Questo rapidamente, dobbiamo prima essere molto chiari su cosa sia un algoritmo e
Qual è il tempo di esecuzione.Questo è indicato come un modello di calcolo.Per questo
Ordinando il limite inferiore, saremo molto generosi.Permetteremo all'algoritmo
eseguire qualsiasi operazione binaria.Questa operazione può utilizzare qualsiasi informazione su
l'input o su ciò che è già stato calcolato dall'algoritmo, ma il
Il risultato dell'operazione è limitato a una risposta sì - no.Ad esempio, come è fatto in
Unisci ordinamento, potrebbe chiedere se l'elemento ITH è inferiore all'elemento JTH.Per
un esempio più sconosciuto, potrebbe chiedere con un'operazione se il numero di dispari
Gli elementi sono strani.

---
layout: 
title: Pagina 104
level: 3
---


Algoritmi iterativi e invarianti ad anello
88
Definizione del problema di ordinamento P: il problema di ordinamento standard, dato n elementi, è quello di produrre gli stessi n elementi in ordine ordinato.Per semplificare la nostra vita, definiremo il problema P per ordinare i puntatori agli elementi invece di selezionare
gli elementi stessi.Nota questo viene spesso fatto quando gli elementi sono troppo grandi
Per muoversi facilmente.Ad esempio, se l'input è i = ⟨19, 5, 81⟩pointers a questi elementi sono ⟨1, 2, 3⟩, l'output sarà ⟨2, 1, 3⟩, perché il primo elemento nel
Ordine ordinato ⟨5, 19, 81⟩ era secondo in I, il secondo era il primo e il terzo elemento era il terzo.Allo stesso modo, l'output per i ′ = ⟨19, 81, 5⟩ sarà ⟨3, 1, 2⟩.Che cosa
semplifica la nostra vita in questa versione del problema di smistamento è che le istanze
I = ⟨19, 5, 81⟩ e i ′ = ⟨19, 81, 5⟩ hanno uscite diverse, mentre nello standard
Definizione del problema, entrambi avrebbero l'output ⟨5, 19, 81⟩.Questo cambiamento è
ragionevole perché qualsiasi algoritmo di ordinamento deve imparare l'ordine in cui gli elementi dovrebbero essere in.
L'insieme iniziale di istanze: a causa del modo in cui abbiamo modificato il problema di smistamento, la natura degli elementi ordinati non ha importanza, solo la loro iniziale
ordine.Quindi, possiamo anche supporre che stiamo ordinando i numeri 1 a N. Let
Il set iniziale delle istanze di input considerato consiste in ogni permutazione
di questi numeri.
P (i) ̸ = p (i ′): notare che ogni coppia di istanze i, i ′ ∈s ha uscite diverse per
Il problema di ordinamento p, cioè p (i) ̸ = p (i ′).Questo è buono perché la nostra ricerca dovrebbe terminare trovando due istanze di input i e i ′ in s per le quali questo è il
caso.
La misura del progresso: la nostra misura del progresso, mentre cerchiamo un'istanza
I su cui l'algoritmo a non funziona, sarà il numero | s |di istanze ancora
essere considerato.Inizialmente, perché S è costituito da tutte le permutazioni di n elementi, | s |= N!.Dimostreremo che ogni iterazione, S non diminuisce di più di
un fattore di 2. Quindi, dopo le iterazioni, | s |≥N!/2t.Impostando tlower (| i |) essere
log2 (n!) −1, sappiamo che alla fine abbiamo almeno due istanze di input rimanenti per essere la nostra I e I ′.
Matematica: in N!= 1 × 2 × 3 × · · · × N, n
2 dei fattori sono almeno n
2 e tutte le n del
I fattori sono al massimo N. Quindi, n!è nell'intervallo [n/2n/2, nn].Quindi, Log n!è in
la gamma [n
2 log n
2, n log n].
Mantenimento dell'invariante in loop: supponiamo che il loop invariante sia vero al momento
t −1 e che s è l'insieme di istanze di input su cui l'algoritmo di A conoscenza
e le azioni per le sue prime fasi di tempo T -1 sono identiche.Dato questo, l'azione è una volontà
Eseguire durante il tempo il passaggio T è fisso.Il modello di calcolo impone che il
Il risultato delle azioni di A è limitato a una risposta sì - no.Quindi partiremo
Due set in base al fatto che questa risposta in questa istanza I è sì o no.Chiamiamo semplicemente
stretto s giù alla parte di s che è più grande dei due.Limitando l'algoritmo
Per imparare solo questa risposta mantiene l'invariante loop.Chiaramente, più grande
Delle due parti ha dimensioni almeno mezzo.

---
layout: 
title: Pagina 105
level: 3
---


Il ciclo invariante per limiti inferiori
89
Il limite inferiore: questo completa il limite inferiore che qualsiasi algoritmo richiede
Almeno (n log n) operazioni binarie per risolvere correttamente il problema di ordinamento.
Esempio 7.2
Indice di ritorno della ricerca binaria
Considera il problema della ricerca di un elenco ordinato di N elementi in cui si afferma l'output
L'indice della chiave nell'elenco.La ricerca binaria risolve il problema con i confronti log2 (n).Ora dimostreremo un limite inferiore corrispondente.
Il set iniziale di istanze: per seguire la stessa tecnica che abbiamo fatto per l'ordinamento, noi
Hai bisogno di una serie di istanze di input legale ognuna delle quali ha un output unico.Ora, tuttavia, ora ci sono solo n possibili output.Lascia che l'insieme iniziale di istanze sia s = {ij |j ∈
[1, n]}, dove ij è l'istanza di input che cerca il tasto 5 all'interno dell'elenco che ha il
Primi elementi J −1 Zero, l'elemento JTH 5 e gli ultimi N -J Elements 10.
La misura del progresso: inizialmente, | s |= N. Come prima, S non diminuisce di più
di un fattore 2 ad ogni iterazione.Quindi, dopo le iterazioni, | s |≥N/2T.IMPOSTANDO
Tlower (| i |) per essere log2 (n) −1, sappiamo che alla fine abbiamo almeno due istanze di input che rimangono per essere la nostra I e I ′.
Il limite inferiore: il resto del limite inferiore è lo stesso, dimostrando che qualsiasi algoritmo
Richiede almeno (log n) operazioni binarie per risolvere correttamente il problema della ricerca
un elenco ordinato.
Devi guardare i dati inferiori dei dati: i seguenti limiti inferiori
non appartengono realmente agli algoritmi iterativi di questo libro, perché in questi casi
Non troviamo le istanze I e i ′ iterativamente.Tuttavia, l'idea di base è la stessa.
Questi limiti inferiori affermano che almeno n ′ ≤n sono richieste operazioni su un input di
Dimensione N, perché devi guardare almeno N ′ dei valori di input.
Esempio 7.3
Parità
L'esempio più semplice è per il problema della parità di calcolo.L'input è costituito da n
Bit e l'output afferma semplicemente se il numero di quelli è uniforme o dispari.
L'approccio teorico dell'informazione non funziona: il
Informazioni-teoriche
Approccio fornito sopra consente al modello di calcolo di addebitare solo un passo temporale
Per qualsiasi operazione sì - no sull'istanza di input, perché conta solo i bit di
informazioni apprese.Tuttavia, questo non funziona per il problema della parità.Se ce ne sono sì, no
È consentito l'operazione sull'istanza di input, quindi l'algoritmo può semplicemente chiedere
la parità.Questo risolve il problema in un passo temporale.
Leggere l'input: supponiamo, d'altra parte, il modello di cariche di calcolo
Un passo temporale per leggere un singolo bit di input.(Potremmo anche dare qualsiasi ulteriore
Operazioni gratuitamente.) Chiaramente, un algoritmo non può conoscere la parità dell'input fino a quando non ha letto tutti i bit.Ciò dimostra il limite inferiore che qualsiasi algoritmo risolve
Il problema richiede almeno n.Vedremo, tuttavia, che c'è un bug in questo
discussione.

---
layout: 
title: Pagina 106
level: 3
---


Algoritmi iterativi e invarianti ad anello
90
Esempio 7.4
Multiplexer
Il problema computazionale multiplexer ha due input: una stringa n-bit x e a
log2 (n) -bit indice i, che ha l'intervallo da 1 a n.L'output è semplicemente il po 'di x.
Come abbiamo fatto per la parità, potremmo dare un limite inferiore di N per questo problema come segue: se il
L'algoritmo non legga un po 'di x, quindi darà la risposta sbagliata quando
Questo bit è l'output richiesto.Questo argomento è chiaramente sbagliato, perché il seguente
è un algoritmo corretto che ha tempo di esecuzione log2 (n) + 1: si legge e quindi impara il
Rispondi leggendo il po 'di x.
Algoritmi dinamici: dimostrare un limite inferiore in base a quanti bit devono essere
Leggi è un po 'più difficile, perché un algoritmo è autorizzato a cambiare che si legge
in base a ciò che ha letto prima.Data ogni singola istanza, l'algoritmo potrebbe leggere
Solo n -1 dei bit, ma quale bit non viene letto dipende dall'istanza di input.
Correzione di un'istanza e capovolgere un po ': prima di poter sapere cosa l'algoritmo
A fa, dobbiamo dargli un'istanza di input specifica I. Dobbiamo sceglierne una.Quindi determiniamo l'insieme J ⊆ [1, n] di bit di questo istanza che sono critici, significato per ciascuno
j ∈J, se fogli solo il po 'di io ma lasci il resto dell'istanza da solo, allora
La risposta al problema di calcolo su questa istanza cambia.Otteniamo quindi un
Logo inferiore di N ′ = | J |nel tempo necessario per risolvere il problema come segue.Corriamo
L'algoritmo su I e vedi quali frammenti di questo istanza si legge.Se legge n ′ = | j |Bit, allora abbiamo finito.Altrimenti, c'è un po 'di j ∈J che l'algoritmo non legge
in questo caso.Poiché l'algoritmo non lo legge, possiamo far scorrere questo bit di istanza senza influire sulla risposta che l'algoritmo dà.Non ci è permesso cambiare
uno qualsiasi dei bit che l'algoritmo legge, perché non solo può cambiare il
Rispondi che dà, può anche cambiare quali bit legge.Ci siamo assicurati, tuttavia, che il flusso di questo singolo bit cambi la risposta alla domanda di calcolo.Quindi, su una delle due istanze di input, l'algoritmo deve dare il male
risposta.
Esempio 7.3 ′
Parità
Ora otteniamo un limite inferiore formale di N per il problema della parità, come segue.Lascia che io sia
l'istanza all-zero.Sia J = [1, N] l'insieme di tutti i bit dell'input.Per ogni j ∈j, cambiando il pezzo di Jth di I cambia la risposta da parità anche a una parità dispari.Quindi, se l'algoritmo non legge il bit JTH quando viene dato l'istanza I, dà il errore
Rispondi su istanza I o sull'istanza con questo bit.
Esempio 7.4 ′
Multiplexer
Abbiamo ottenuto un algoritmo log2 (n) + 1-time per risolvere il problema multiplexer.
Ora otteniamo un limite inferiore corrispondente.Lascia che io sia l'istanza con x = 100.000, cioè,

---
layout: 
title: Pagina 107
level: 3
---


Il ciclo invariante per limiti inferiori
91
uno nel suo primo bit e zero nel resto, e con j = 1. Sia j consistere nei bit log2 (n) di
J e il primo pezzo di x.L'output del multiplexer su i è uno, perché questo è il jth
un po 'di x.Ma se fogli un po 'di j, allora viene indicizzato un po' di x e la risposta
cambia a zero.Se fluttua il primo po 'di x dall'essere uno, allora anche la risposta
i cambiamenti.Quindi, se l'algoritmo non legge uno di questi bit quando viene dato l'istanza I, dà la risposta sbagliata sull'istanza o lo fa sull'istanza con questo bit
flopped.
Esempio 7.2 ′
Ricerca binaria che ritorna sì o no:
Nell'esempio 7.2 abbiamo dimostrato un limite inferiore log2 (n) per la ricerca di un elenco ordinato di N elementi.Dobbiamo fare di nuovo lo stesso.La differenza ora è che se la chiave è nell'elenco, il problema restituisce solo l'output sì e, in caso contrario, no.
L'approccio:
L'approccio teorico dell'informazione non funziona: ancora una volta
IL
L'approccio teorico dell'informazione non funziona, perché se qualche operazione sì, non su
È consentita l'istanza di input, quindi l'algoritmo può semplicemente chiedere se la chiave è in
L'elenco, risolvendo il problema in un passo temporale.
Il set-j -of-biets-to-flip-approccio non funziona: il
iniziale
esempio
IO
deve essere costituito dalla chiave per cercare e qualche elenco ordinato.Detto questo, non ci sono molti elementi J che possono essere modificati per cambiare l'output
del problema di ricerca.
Qualche combinazione: invece, useremo una combinazione dei due limiti inferiori
approcci.
Il set iniziale di istanze: come abbiamo fatto quando abbiamo dimostrato il limite inferiore per questo problema nell'esempio 7.2, consideriamo l'istanza di input IJ, che è cercare la chiave 5
All'interno dell'elenco con i primi elementi j −1 zero, l'elemento JTH 5 e l'ultimo n −j
Elements 10. A differenza di prima, tuttavia, queste istanze hanno tutte le stesse uscite: sì.
Come nell'approccio set-j -of-bits-to-flop, lascia I ′
J essere la stessa istanza, tranne per il fatto che l'elemento JTH viene cambiato da 5 a 6 in modo che ij e io ′
j hanno risposte opposte.Considerando
Questi, lascia che l'insieme iniziale di istanze sia s = {ij |j ∈ [1, n]} ∪ {i ′
J |j ∈ [1, n]}.
Il ciclo standard invariante: come prima, l'invariante loop afferma che abbiamo un set
S di istanze di input su cui l'algoritmo di conoscenza e azioni di A per il suo primo tempo
I passaggi sono identici.
Un altro loop invariante: abbiamo ulteriori invarianti ad anello che affermano che la corrente
Struttura di S è S = {ij |j ∈ [j1, j2]} ∪ {i ′
J |j ∈ [j1, j2]}, dove [j1, j2] è un sottointervallo di
L'elenco ordinato delle dimensioni.Inoltre, | [J1, J2] |≥N/2T.

---
layout: 
title: Pagina 108
level: 3
---


Algoritmi iterativi e invarianti ad anello
92
Mantenimento dell'invariante in loop: manteniamo il loop invariante come segue.Assumere
che l'invariante in loop è vero per il tempo t −1.Sia m L'indice dell'elemento letto a
tempo t dall'algoritmo su tutte le istanze di input in S.
M ̸∈ [J1, J2]: se l'algoritmo legge un elemento M prima della nostra sottorangia [J1, J2], quindi per tutti i casi in S, questo elemento MTH è zero.Allo stesso modo, se M è dopo, allora
Questo elemento è definitivamente 10. In entrambi i casi, l'algoritmo non apprende nulla che abbia
non è già stato fisso.L'anello invariante viene mantenuto banalmente senza cambiare
nulla.
M ∈ [J1, JMID]: Sia [J1, JMID] e [JMID + 1, J2] a metà la nostra sottorangia.Se m
è nella prima metà [J1, JMID], quindi impostiamo il nostro nuovo sottointervallo per essere il secondo
metà [JMID + 1, J2].Questo restringe il nostro set di istanze fino a s = {ij |j ∈ [jmid +
1, j2]} ∪ {i ′
J |j ∈ [jmid + 1, j2]}.Per tutti i casi in questa nuova s, l'elemento MTH è
zero.L'algoritmo legge e apprende il valore zero e procede.L'anello invariante viene mantenuto.
m ∈ [JMID + 1, J2]: se m è nella seconda metà [JMID + 1, J2], allora abbiamo impostato il nostro nuovo
Subterval per essere la prima metà, e per tutti i casi nella nuova S, l'elemento MTH
è 10.
Fine: la condizione di uscita è quindi t = tlower (| i |) = log2 (n).Dal loop invariante, quando usciamo dal nostro sottointervallo [J1, J2], la sua dimensione è almeno n/2t = 1. Sia j = j1 = j2.Il nostro set
S contiene ancora le due istanze ij e i ′
J.Con la definizione di questi casi, il primo
richiede la risposta p (ij) = sì e la seconda p (i ′
j) = no.Dall'invariante del loop, il calcolo di A è identico a queste istanze per le prime fasi temporali di tlower (| i |), e quindi le loro uscite devono essere identiche: a (ij) = a (i ′
J).Quindi, il calcolo deve
Dai una risposta sbagliata su almeno uno di loro.
Il limite inferiore: il resto del limite inferiore è lo stesso, dimostrando che qualsiasi algoritmo
Richiede almeno (log n) operazioni binarie per risolvere correttamente il problema della ricerca
un elenco ordinato.
Attuale stato dell'arte nel dimostrare limiti inferiori: i limiti inferiori sono difficili da
Dimostrare, perché devi considerare ogni algoritmo, non importa quanto strano o complesso.Dopotutto, ci sono esempi di algoritmi che iniziano a fare molto strano
le cose e poi alla fine producono magicamente l'output richiesto.
Teoria dell'informazione: la tecnica qui utilizzata per dimostrare limiti inferiori non lo fa
Considera la quantità di lavoro che deve essere svolto per risolvere il problema, ma il
quantità di informazioni che devono essere trasferite dall'input all'output.
Il problema con questi limiti inferiori è che non sono più grandi che lineari
Rispetto alla dimensione del bit dell'input e dell'output.

---
layout: 
title: Pagina 109
level: 3
---


Il ciclo invariante per limiti inferiori
93
Modello limitato: un metodo comune per dimostrare limiti inferiori è considerare
Solo algoritmi che hanno una struttura limitata.La mia tesi di dottorato si è rivelata più bassa
I limiti ai compromessi tra il tempo e lo spazio necessari per verificare la connettività (s −t) di un grafico in un modello che consente solo ai ciottoli di scivolare lungo i bordi
e salta tra loro.
Modello generale: la comunità della teoria è in grado di dimostrare il primo
limiti inferiori non lineari su un modello generale di calcolo.Questo è piuttosto eccitante per quelli di noi nel campo.
Esercizio 7.0.1 Come cambierebbe il limite inferiore se una singola operazione, anziché
Essere solo una domanda sì - no, potrebbe essere una domanda con le risposte diverse?
Qui R è un parametro fisso.
Esercizio 7.0.2 (Vedi soluzione nella quinta parte.) Ricorda il trucco della scheda Magic Sevens introdotta nella Sezione 4.2.Qualcuno seleziona una delle n carte e il mago deve determinare
Cosa è facendo domande.Ogni round, il mago riorganizza le carte in file
e chiede in quale delle righe si trovano la carta. Dare un argomento teorico di informazione a
Dimostrare un limite inferiore sul numero di round, t, che sono necessari.
Esercizio 7.0.3 (vedi soluzione nella parte quinta.) Supponiamo di avere n oggetti che sono
Completamente identico tranne che è leggermente più pesante.Il problema p è trovare il
oggetto più pesante.Hai una scala.Una singola operazione consiste nel posizionare due disgiunzioni
Set degli oggetti i due lati della scala.Se un lato è più pesante, la scala si ribalta.
Dare limiti superiore e inferiore per questo problema.
Esercizio 7.0.4 Complessità della comunicazione: considera il seguente problema: Alice
ha qualche oggetto dagli oggetti M {i1 ,..., Im}, e lei deve comunicare quale
Oggetto che deve bob inviando una serie di bit.La stringa inviata sarà un identificatore per
l'oggetto.L'obiettivo è assegnare a ciascun oggetto un identificatore univoco in modo che il più lungo
ha il minor numero possibile di bit.
Esercizio 7.0.5 Stare e dimostrare un limite inferiore quando invece di bit Alice può inviare
Lettere bob da un alfabeto fisso.
Esercizio 7.0.6 (vedi soluzione nella parte cinque.) Il problema computazionale fornito n
Bit determina se almeno uno dei bit è uno.Questo è lo stesso del gioco
mostra il problema menzionato nel capitolo 21, che richiede la ricerca di quale delle porte N
nasconde un premio.Il modo in cui ciò differisce dal problema della parità è che l'algoritmo può
Fermati non appena finisce un premio.Dai un limite inferiore stretto per questo problema.Nella parte inferiore
Continua al problema della parità, quali istanze iniziali lavoro?Quali funzionano per il
E problema?
Esercizio 7.0.7 Cerca una matrice ordinata: l'input è costituito da un numero reale X e A
Matrix A [1..n, 1..M] di numeri reali nm in modo tale che ogni riga A [i, 1..n] sia ordinata e ciascuno

---
layout: 
title: Pagina 110
level: 3
---


Algoritmi iterativi e invarianti ad anello
94
La colonna A [1..n, J] è ordinata.L'obiettivo è trovare la massima voce dell'array a [i, j] che è
Meno o uguale a X o riferiscono che tutti gli elementi di A sono più grandi di x.
1.
Esercizio 4.4.1 fornisce un algoritmo iterativo che accede a t (n, n) = m + n −1 =
Voci 2n −1 quando n = m.Dimostrare un limite inferiore corrispondente di t (n, n) = 2n −1 per
questo caso.(Inizia con un limite inferiore di N se vuoi.)
2.
L'esercizio 9.1.3 fornisce un algoritmo ricorsivo che accede a t (n, m) = n log2 (m
n) elementi quando m ≫n.Dimostrare un limite inferiore corrispondente.
Esercizio 7.0.8 Considera il problema di determinare l'elemento più piccolo in un massimo
mucchio.Gli elementi più piccoli di un mucchio massimo devono essere uno dei ⌈n/2⌉leaves.(Altrimenti, ci deve essere un non alle maggiore che è più piccolo di uno dei suoi discendenti, il che significa
L'albero non è un mucchio massimo.) Pertanto, è sufficiente cercare tutte le foglie.Dimostrare un limite inferiore
È necessario cercare tutte le foglie.

---
layout: 
title: Pagina 111
level: 3
---


SECONDA PARTE
Ricorsione

---
layout: 
title: Pagina 112
level: 3
---


---
layout: 
title: Pagina 113
level: 3
---


97
8 astrazioni, tecniche e teoria
Gli algoritmi iterativi iniziano dall'inizio e fanno un passo alla volta verso il
destinazione finale.Un'altra tecnica usata in molti algoritmi è tagliare il compito dato
In una serie di pezzi disgiunti, risolvi ciascuno di questi separatamente, quindi combina
Queste risposte in una risposta per l'attività originale.Questa è la divisione e il conquista
metodo.Quando le sottotetti sono diverse, porta a diverse subroutine.Quando essi
sono istanze del problema originale, porta a algoritmi ricorsivi.
Le persone spesso trovano gli algoritmi ricorsivi molto difficili.Per capirli, lo è
Importante per avere una buona comprensione della teoria e delle tecniche presentate in questo capitolo.
8.1
Pensando alla ricorsione
Esistono diversi modi per visualizzare un algoritmo ricorsivo.Sebbene l'algoritmo risultante sia lo stesso, avere i diversi paradigmi a tua disposizione può essere utile.

---
layout: 
title: Pagina 114
level: 3
---


Ricorsione
98
Codice: il codice è utile per l'implementazione di un algoritmo su un computer.È preciso e
succinto.Tuttavia, il codice è soggetto a bug, dipende dalla lingua e spesso manca
livelli più elevati di intuizione.
Stack of Stack Frame: gli algoritmi ricorsivi vengono eseguiti usando uno stack di stack
cornici.Vedere la Sezione 8.6.Sebbene ciò debba essere compreso, rintracciare tale esecuzione è doloroso.
Frame di albero di stack: questo è un modo utile di visualizzare l'intero calcolo a
una volta.È particolarmente utile quando si calcola il tempo di esecuzione dell'algoritmo.
Tuttavia, la struttura dell'albero di calcolo può essere molto complessa e difficile
capire tutto in una volta.
Amici, su una forte induzione: il
più semplice
Il metodo è quello di concentrarsi su un passo alla volta.
Supponiamo che qualcuno ti dia un'istanza
del problema computazionale.Lo risolvi come
segue.Se è sufficientemente piccolo, risolvilo da solo.Altrimenti, hai un certo numero di amici
per aiutarti.Costruisci per ogni amico un
istanza dello stesso problema computazionale
Questo è più piccolo del tuo.Ci riferiamo a questi
come sottoinstabilità.I tuoi amici ti forniscono magicamente le soluzioni a questi.Voi
Quindi combina questi subsoluzioni in una soluzione per l'istanza originale.
Mi riferisco a questo come il livello di astrazione degli amici.Se preferisci, puoi chiamarlo il
forte livello di induzione di astrazione e usa la parola "ricorsione" anziché "amico".
Ad ogni modo, la chiave è che ti preoccupi solo del tuo compito.Non preoccuparti
su come i tuoi amici risolvono le sottoinstanze che hai assegnato loro.Allo stesso modo, fai
Non preoccuparti di chiunque ti abbia dato la tua istanza e cosa fa con la tua risposta.
Lascia queste cose a lui.Fidati dei tuoi amici.
Usalo: consiglio vivamente di usare questo metodo quando progetto, comprensione e descrizione di un algoritmo ricorsivo.
Fede nel metodo: come con il metodo invariante del loop, non vuoi esserlo
Ripensare il problema se dovresti rubare ogni volta che entri
un negozio.È meglio avere alcuni principi generali con cui lavorare.Fate
non voglio ripensare il problema se credi o meno nella ricorsione
Ogni volta che consideri un algoritmo duro.Comprendere l'algoritmo stesso lo farà
Sii abbastanza duro.Durante leggi questo capitolo dovresti essere una volta per tutte
per capire e credere come i seguenti passaggi siano sufficienti alla descrizione
Un algoritmo ricorsivo.In questo modo può essere difficile.Richiede un modo completamente nuovo di
Guardando gli algoritmi.Tuttavia, almeno per ora, adotta questo come qualcosa che tu
credere in.

---
layout: 
title: Pagina 115
level: 3
---


Astrazioni, tecniche e teoria
99
8.2
In attesa di avanti vs.
Argomento circolare?La ricorsione comporta la progettazione di un algoritmo utilizzandolo come se lo fosse
esiste già.All'inizio questo sembra paradossale.Supponiamo, ad esempio, la chiave per
La casa in cui vuoi entrare è nella stessa casa.Se potessi entrare, potresti
Ottieni la chiave.Quindi potresti aprire la porta, in modo da poter entrare. Questa è una circolare
discussione.Non è un programma ricorsivo legale perché la sottoinstabilità non è più piccola.
Un problema e una fila di istanze:
Considera una fila di case.Ogni casa è più grande
che il prossimo.Il tuo compito è entrare nel più grande
uno.Sei bloccato da tutte le case.Il tasto
ad ogni casa è bloccato nella casa della successiva
taglia più piccola.Il problema ricorsivo consiste in
entrare in qualsiasi casa specifica.Ogni casa in
La riga è un'istanza separata di questo problema.
Per entrare in casa mia
Devo ottenere la chiave da una casa più piccola
L'algoritmo: la casa più piccola è abbastanza piccola da poter usare la forza bruta per
Entra. Ad esempio, si potrebbe semplicemente sollevare dal tetto.Una volta in questa casa, possiamo ottenere
La chiave per la casa successiva, che viene quindi facilmente aperta.All'interno di questa casa, possiamo ottenere
La chiave per la casa dopo, e così via.Alla fine, siamo nella casa più grande come
necessario.
Concentrati su un passo: sebbene questo algoritmo sia abbastanza semplice da capire, di più
Algoritmi complessi sono più difficili da capire tutti in una volta.Invece ci concentriamo su uno
passo alla volta.Qui, un passo consiste nell'apertura della casa i.Chiediamo a un amico di aprire
House I −1, di cui prendiamo la chiave con cui apriamo la casa i.Noi non
preoccuparti di come aprire la casa i −1.
Lavorando in avanti rispetto all'indietro: un algoritmo iterativo funziona in avanti.Lo sa
sulla casa I −1.Usa un loop invariante per dimostrare che questa casa è stata aperta.
Cerca questa casa e apprende che la chiave al suo interno è quella per la casa i.Per colpa di
Questo, decide quella casa che sarei bravo a cui andare dopo.
Un algoritmo di ricorsione funziona all'indietro.Sa di casa io.Vuole ottenere
è aperto.Determina che la chiave per la casa i è contenuta nella casa I −1.Quindi, l'apertura della casa I −1 è un sottotitolo che deve essere realizzato.
Ci sono due vantaggi degli algoritmi ricorsivi rispetto a quelli iterativi.Il primo
è che a volte è più facile lavorare all'indietro che in avanti.Il secondo è quello a
L'algoritmo ricorsivo è consentito avere più di una sottovalutazione da risolvere.Questo forma
Un albero di case da aprire invece di una fila di case.
Non rintracciare: quando si progetta un algoritmo ricorsivo è allettante di tracciare il
intero calcolo.“Devo aprire la casa n, quindi devo aprire la casa n -1 ,....IL
House più piccola che strappio il tetto.Ottengo la chiave per la casa 1 e la apro.Ottengo la chiave

---
layout: 
title: Pagina 116
level: 3
---


Ricorsione
100
per la casa 2 e aprilo....Ottengo la chiave per la casa n e la apro. "Tale spiegazione
è complicato e inutile.
Risolvere solo la tua istanza: una qualità importante di qualsiasi leader è sapere come farlo
delegare.Il tuo compito è aprire la casa i.Delegare a un amico il compito di aprire la casa
I −1.Fidati di lui e lascia la responsabilità a lui.
8.3
Con un piccolo aiuto dai tuoi amici
Di seguito sono riportati i passaggi da seguire quando si sviluppa un algoritmo ricorsivo all'interno
il livello di astrazione degli amici.
Specifiche: scrivere attentamente le specifiche per il problema.
Precondizioni: i precondizioni indicano qualsiasi ipotesi che deve essere vera
l'istanza di input per l'algoritmo di funzionare correttamente.
Postconditions: i postcondizioni sono dichiarazioni sull'output che deve
essere vero quando l'algoritmo ritorna.
Questo passaggio è ancora più importante per gli algoritmi ricorsivi che per altri algoritmi, perché deve esserci un accordo stretto tra ciò che ci si aspetta da te in termini
di pre e postcondizioni e cosa ci si aspetta dai tuoi amici.
Dimensione: escogitare una misura della dimensione di ogni istanza.Questa misura può essere qualsiasi cosa
ti piace e corrisponde alla misura del progresso all'interno del livello invariante
di astrazione.
Input generale: considera un'istanza ampia e generale del problema.
Magia: supponiamo che per magia un amico sia in grado di fornire la soluzione a qualsiasi istanza del tuo problema fintanto che l'istanza è strettamente più piccola della corrente
istanza (secondo la tua misura delle dimensioni).Più in particolare, se l'istanza
che dai all'amico incontra le condizioni preliminari dichiarate, quindi la sua soluzione lo farà
Incontra i postcondizioni dichiarate.Tuttavia, non aspettarti che il tuo amico realizzi più di questo.(In realtà, l'amico è semplicemente un'immagine speculare di te stesso.)
Substanze: dall'istanza originale, costruiscono una o più sottoinstanze, che sono istanze più piccole dello stesso problema.Assicurati che i precondizioni
sono soddisfatti per questi casi più piccoli.Non fare riferimento a questi come "sottoproblemi".IL
Il problema non cambia, solo l'istanza di input per il problema.
Sovvenuti: chiedi al tuo amico di (ricorsivamente) di fornire soluzioni per ciascuno di questi
sotterranei.Ci riferiamo a questi come subsoluzioni anche se non è la soluzione, ma l'istanza è più piccola.
Soluzione: combinare queste subsoluzioni in una soluzione per l'istanza originale.

---
layout: 
title: Pagina 117
level: 3
---


Astrazioni, tecniche e teoria
101
Generalizzare il problema: a volte una sottoinstabilità che desideri il tuo amico
Risolvere non è un'istanza legale secondo i precondizioni.In tal caso, inizia
Oltre, riesaminando le condizioni preliminari per consentire tali istanze.Nota, tuttavia, che ora anche tu devi essere in grado di gestire questi istanze extra.Allo stesso modo, la soluzione
fornito dal tuo amico potrebbe non fornire informazioni sufficienti sulla sottoinstabilità
per poter risolvere il problema originale.In tal caso, ricominciare da capo
Il postconditivo aumentando la quantità di informazioni fornite dal tuo amico.
Ancora una volta, ora devi anche fornire queste informazioni extra.Vedere la Sezione 10.3.
Pre e postcondizioni naturali: d'altra parte, hai più generalizzato
Il problema è ancora un problema naturale.Non tentare di passarle molte informazioni extra sulla tua istanza.Per la prima chiamata (o frame stack) del calcolo per passare un valore attraverso la catena di chiamate ricorsive è un tipo di "trucco" globale.Fa anche sembrare che tu stia micromanaging ai tuoi amici.
Allo stesso modo, una cornice dello stack (amico) non dovrebbe sapere quale livello di ricorsione
è acceso.
Sia i pre e i postcondizioni fungono da invarianti loop: The Loop Invariant
In un algoritmo iterativo afferma ciò che viene mantenuto man mano che il controllo viene passato
dall'iterazione all'iterazione.Fornisce un'immagine di ciò in cui vuoi essere vero
al centro di questo calcolo.Con la ricorsione, tuttavia, ci sono due direzioni.Il preliminare afferma ciò che vuoi essere vero a metà dell'albero di ricorsione.La postconditazione afferma ciò che vuoi essere vero a metà del backup del
albero di ricorsione.
Minimizzare il numero di casi: è necessario assicurarsi che l'algoritmo tu
Sviluppa opere per ogni istanza di input valida.Per raggiungere questo obiettivo, l'algoritmo lo farà spesso
richiedono molti pezzi di codice separati per gestire input di diversi tipi.Idealmente, il
L'algoritmo sviluppato ha il maggior numero possibile di questi casi.Un modo per aiutarti a ridurre al minimo il numero di casi necessari è i seguenti.Inizialmente, considera un'istanza
è il più grande e il più generale possibile.Se ci sono diversi tipi di istanze, scegli uno il cui tipo è il più generale possibile.Progettare un algoritmo che
Funziona per questo istanza.Successivamente, se c'è un altro tipo di istanza che hai
Non ancora considerato, considera un'istanza generale di questo tipo.Prima di progettare un algoritmo separato per questa nuova istanza, prova a eseguire il tuo algoritmo esistente su di esso.Voi
Potrebbe essere sorpreso di scoprire che funzioni.Se, d'altra parte, non funziona per questo
istanza, quindi ripetere i passaggi precedenti per sviluppare un algoritmo separato per questo caso.
Potrebbe essere necessario ripetere questo processo più volte.
Ad esempio, supponiamo che l'input sia costituito da un albero binario.Potresti ben trovare
che l'algoritmo progettato per un albero con un bambino a sinistra e anche un bambino a destra
funziona per un albero con un bambino scomparso e persino per un bambino composto da un solo
nodo.L'unico caso rimanente potrebbe essere l'albero vuoto.
Casi di base: quando tutte le rimanenti istanze irrisolte sono sufficientemente piccole, risolvono
loro in modo bruto.

---
layout: 
title: Pagina 118
level: 3
---


Ricorsione
102
Tempo di esecuzione: utilizzare una relazione di ricorrenza o un albero di cornici dello stack per stimare il
tempo di esecuzione.
Un collegamento alle tecniche per gli algoritmi iterativi: le tecniche che spesso
sorgere in algoritmi iterativi nascono anche in algoritmi ricorsivi, anche se a volte dentro
una forma leggermente diversa.
Più dell'input: quando l'input include N oggetti, questa tecnica per gli algoritmi iterativi si estende (per i = 1
,..., n −1) una soluzione per gli oggetti I −1
in una soluzione per il primo i.Questa stessa tecnica può essere utilizzata anche per ricorsivi
Algoritmi.Il tuo amico ti fornisce una soluzione per gli oggetti N −1 nel tuo
istanza, quindi lo estendi a una soluzione a tutta la tua istanza.Questo algoritmo iterativo e questo algoritmo ricorsivo sarebbero due implementazioni di
lo stesso algoritmo.La ricorsione è più interessante quando un amico può fornirti una soluzione per il primo ⌊n
2 ⌋Objects In tua istanza, un altro amico può
fornire una soluzione per il prossimo ⌈n
2 ⌉Objects e li combini in una soluzione
per l'intero.
Più output: questa tecnica per gli algoritmi iterativi costruisce l'output
Un pezzo alla volta.Ancora una volta un algoritmo ricorsivo potrebbe far costruire un amico tutto tranne
l'ultimo pezzo e ti fai aggiungere l'ultimo pezzo.Tuttavia, è meglio averne uno
amico costruisce la prima metà dell'output, un'altra seconda metà, e ti combini
loro in qualche modo.
Restringendo lo spazio di ricerca: alcuni algoritmi iterativi si restringono ripetutamente il
Cerca spazio in cui cercare qualcosa.Invece, un algoritmo ricorsivo può
Dividi lo spazio di ricerca a metà e fai una ricerca di un amico ogni metà.
Analisi del caso: invece di provare se stessi ciascuno dei casi, si potrebbe dare un caso
a ogni amico.
Lavoro svolto: il lavoro non si accumula in algoritmi ricorsivi come negli algoritmi iterativi.Facciamo ogni amico a fare un po 'di lavoro, e poi facciamo un po'
lavoro, noi stessi per combinare queste soluzione.
8.4
Le torri di Hanoi
Le torri di Hanoi sono un classico puzzle per il quale è l'unico modo possibile per risolverlo
pensare in modo ricorsivo.
Specifica: il puzzle è costituito da tre poli e una pila di n dischi di diverso
dimensioni.
Precondizionismo: tutti i dischi sono al primo posto dei tre poli.

---
layout: 
title: Pagina 119
level: 3
---


Astrazioni, tecniche e teoria
103
Figura 8.1: Il problema delle torri di Hanoi.
Postcondition: l'obiettivo è spostare lo stack sull'ultimo palo.Vedere il primo e
Le ultime parti della Figura 8.1.
È consentito prendere solo un disco dalla parte superiore dello stack su un palo e un posto
In cima allo stack su un altro palo.Un'altra regola è che non è possibile inserire alcun disco
In cima a un disco più piccolo.
Perso con il primo passaggio: il primo passo deve essere quello di spostare il disco più piccolo.Ma è da
Non è chiaro se spostarlo al centro o all'ultimo polo.
Dividi: salta nel mezzo del calcolo.Una cosa che è chiara è che a
Un certo punto, devi spostare il disco più grande dal primo polo fino all'ultimo.In modo da
Fallo, non ci possono essere altri dischi sul primo o sull'ultimo palo.Quindi, tutto il
Altri dischi devono essere impilati sul polo medio.Vedere la seconda e la terza parte
della Figura 8.1.Questo punto nel calcolo divide il problema in due sottoproblemi
che deve essere risolto.Il primo è come spostare tutti i dischi tranne i più grandi del
prima polo al centro.Vedi la prima e la seconda parte della Figura 8.1.Il secondo è come
per spostare questi stessi dischi dal polo medio all'ultimo.Vedere il terzo e il quarto
parti della Figura 8.1.
Conquista: insieme questi passaggi risolvono l'intero problema.A partire da tutti i dischi
Il primo polo, in qualche modo si muove tutto tranne il più grande al secondo polo.Quindi, in un solo passaggio, sposta il più grande dal primo al terzo palo.Finalmente, in qualche modo muovi tutti tranne il
più grande dal secondo al terzo palo.
Magia: per fare una chiara separazione tra il compito di risolvere l'intero problema e quella di risolvere ciascuno dei sottoproblemi, mi piace dire che delegiamo a uno
amico il compito di risolvere uno dei sottoproblemi e delegare a un altro amico il
altro.
Specificazione più generale: il sottoproblema di spostare tutto tranne il più grande disco
Dalla prima al polo medio è molto simile alle torri originali del problema di Hanoi.
Tuttavia, è un'istanza di un problema leggermente più generale, perché non tutti i
I dischi vengono spostati.Per includerlo come istanza del nostro problema, generalizziamo il
problema come segue.
Precondizionismo: l'ingresso specifica il numero n di dischi da spostare e il
Ruoli dei tre poli.Questi tre ruoli per i poli sono polesource, poledestinazione e polesca.La preliminare richiede che i dischi N più piccoli siano attualmente attivi
poloSource.Non gli importa dove siano i dischi più grandi.

---
layout: 
title: Pagina 120
level: 3
---


Ricorsione
104
Postcondition: l'obiettivo è spostare questi più piccoli dischi N alla poledestinazione.Palo
PoleSpare è disponibile per essere utilizzato temporaneamente.I dischi più grandi non vengono spostati.
Subinstance: il nostro compito è spostare tutti i dischi dal primo polo all'ultimo.Questo
è specificato dando n = n, polesource = prima, poledestintion = ultimo e poleSpare =
mezzo.Faremo un amico a spostare tutto tranne il disco più grande dal primo al
polo medio.Questo è specificato dando n = n −1, poleSource = first, poledestination =
Middle e PoleSpare = Last.Da soli, spostiamo il disco più grande dal primo a
l'ultimo disco.Infine, avremo un altro amico per spostare tutto tranne il disco più grande da
dal centro all'ultimo palo.Questo è specificato dando n = n −1, polesource = medio, poledestinazione = ultimo e poleSpare = prima.
Codice:
Algoritmo TowersOfHhanoi (N, fonte, destinazione, ricambio)
⟨Pre-Cond⟩: i n più piccoli dischi sono su POLESOURCE.
⟨Post-Cond⟩: vengono spostati in poledestinazione.
inizio
if (n ≤0)
Niente da fare
altro
Towersofhanoi (n −1, fonte, riserva, destinazione)
Sposta l'ennesimo disco da POLESOURCE alla poledestinazione.
Towersofhanoi (n −1, ricambio, destinazione, fonte)
finisci se
Algoritmo di fine
Tempo di esecuzione: Sia t (n) il momento di spostare n dischi.Chiaramente, t (1) = 1 e t (n) =
2 · t (n −1) + 1. Risoluzione di questo dà t (n) = 2n −1.
8.5
Elenco di controllo per algoritmi ricorsivi
Scrivere un algoritmo ricorsivo è sorprendentemente difficile quando si inizia prima e
Sorprendentemente facile quando lo ottieni.Questa sezione contiene un elenco di cose a cui pensare
Per assicurarti di non commettere errori comuni.
0) La struttura del codice: il codice non deve essere molto più complesso di
il seguente.
Algoritmo Alg (A, B, C)
⟨Pre-Cond⟩: ecco a una tupla, b un numero intero e c un albero binario.
⟨Post-Cond⟩: Output X, Y e Z, che sono oggetti utili.

---
layout: 
title: Pagina 121
level: 3
---


Astrazioni, tecniche e teoria
105
inizio
if (⟨a, b, c⟩is a istanza sufficientemente piccola) return (⟨0, 0, 0⟩)
⟨Asub1, bsub1, csub1⟩ = una parte di ⟨a, b, c⟩
⟨Xsub1, ysub1, zsub1⟩ = alg (⟨asub1, bsub1, csub1⟩)
⟨Asub2, bsub2, csub2⟩ = una parte diversa di ⟨a, b, c⟩
⟨Xsub2, ysub2, zsub2⟩ = alg (⟨asub2, bsub2, csub2⟩)
⟨X, y, z⟩ = combina ⟨xsub1, ysub1, zsub1⟩and ⟨xsub2, ysub2, zsub2⟩
return (⟨x, y, z⟩)
Algoritmo di fine
1) Specificazioni: è necessario definire chiaramente cosa dovrebbe fare l'algoritmo.
2) Variabili: si comprende molto su un algoritmo comprendendo il suo
variabili.Come in qualsiasi algoritmo, si desidera che le variabili siano ben documentate e che abbiano
nomi significativi.È anche importante verificare attentamente di dare valori di variabili del tipo corretto, ad esempio k è un intero, g è un grafico e così via.Inoltre, con
programmi ricorsivi ci sono variabili che svolgono ruoli specifici e dovrebbero essere utilizzati in
modi specifici.Questa può essere una fonte di molte confusioni ed errori.Quindi, ho delineato
Questi attentamente qui.
2.1.) Il tuo input: la tua missione, se vuoi accettarlo, viene ricevuta tramite il tuo
Input.La prima riga del codice, Algoritmo Alg (A, B, C), specifica sia il nome
Alg della routine e i nomi dei suoi input.Qui ⟨a, b, è l'istanza di input per cui è necessario trovare una soluzione.A volte uso Alg (⟨a, b, c⟩) perché sottolinea il punto di vista che stiamo ricevendo un'istanza, anche se
Tale istanza potrebbe essere composta da una tupla di cose.I tuoi precondizioni devono
Specificare chiaramente ciò che ciascuno di questi componenti A, B e C sono e qualsiasi restrizione sui loro valori.Devi essere in grado di gestire qualsiasi istanza che li soddisfi
condizioni.
2.2.) L'output: è necessario restituire una soluzione ⟨x, y, z⟩to la tua istanza ⟨a, b, c⟩
tramite una dichiarazione di restituzione di ritorno (⟨x, y, z⟩).Le tue postcondizioni devono chiaramente
Specifica cosa sono ciascuno dei componenti x, y e z della tua soluzione e loro
Relazione richiesta con l'istanza di input ⟨a, b, c⟩.
2.2.1.) Ogni percorso: dato qualsiasi istanza che incontra il presupposto, è necessario
Restituisci una soluzione corretta.Quindi, se il tuo codice ha istruzioni If o Loop, allora
Ogni percorso tramite il codice deve terminare con un'istruzione di ritorno.
2.2.2.) Tipo di output: ogni istruzione di ritorno deve restituire una soluzione ⟨x, y, z⟩
del tipo giusto.L'unica eccezione parziale a questo è: se il postcondizionismo lascia aprire la possibilità che non esista una soluzione, allora alcuni

---
layout: 
title: Pagina 122
level: 3
---


Ricorsione
106
I percorsi attraverso il codice possono terminare con il rendimento dell'istruzione ("nessuna soluzione
esiste ”).
2.3.) Input del tuo amico: per ottenere aiuto dagli amici, è necessario creare una subinstance ⟨ASUB, BSUB, CSUB⟩ per ogni amico.Lo passi ad un amico ricorrendo
Alg (⟨asub, bsub, csub⟩).Per essere in grado di dare una sottoinstabilità a un amico, deve incontrarsi
i precondizioni del tuo problema.Non ricorrere con Alg (asub, bsub).
2.4.) Output del tuo amico: puoi fidarti che ogni amico ti darà una corretta
Soluzione ⟨xsub, ysub, zsub⟩to la subinstance ⟨asub, bsub, csub⟩ che le dai.
Assicurati di salvare il suo risultato in variabili del tipo corretto, usando il codice ⟨xsub, ysub, zsub⟩ = alg (⟨asub, bsub, csub⟩).Al contrario, il codice ALG (⟨asub, bsub, csub⟩) come a
La linea di per sé è offensiva alla tua amica, perché l'hai fatta fare tutto questo lavoro
E poi hai lasciato cadere il suo risultato nella spazzatura.
2.5.) Raramente hanno bisogno di nuovi input o output: ho parlato della necessità di generalizzare
Il problema aggiungendo nuovi input e/o output.Questo, tuttavia, è necessario lontano
meno spesso di quanto la gente pensi.Cerca di risolvere il problema usando l'analogia dell'amico senza variabili extra.Aggiungili solo se assolutamente necessario.Se aggiungi
Input o output extra, specificano chiaramente nelle pre e postcondizioni
sono per.Non hanno input o output che non sono spiegati.
2.6.) Nessuna variabile globale o effetti globali: quando ti ricordi con la linea
⟨Xsub, ysub, zsub⟩ = alg (⟨asub, bsub, csub⟩), l'unica cosa che dovrebbe accadere è quella
Il tuo amico fa tornare indietro una soluzione corretta ⟨xsub, ysub, zsub⟩to la subinstance
⟨Asub, bsub, csub⟩ che le hai dato.Se il codice ha una variabile locale N, allora il tuo
La variabile N è completamente diversa da quella del tuo amico.(Sono conservati in diversi
cornici in pila.Vedere la Sezione 8.6.) Se si imposta la tua variabile da N a 5 e poi si ricutrui, la variabile del tuo amico N non avrà questo valore.Se vuoi che abbia un 5, tu
deve trasmetterlo come parte della sua subinstance ⟨asub, 5, csub⟩.Allo stesso modo, se il tuo amico
Imposta la sua variabile da N a 6 e poi ritorna, la tua variabile N non avrà questo valore, ma avrà comunque il valore 5. Se vuoi che ti dia un 6, deve restituirlo come
parte della sua soluzione ⟨xsub, 6, zsub⟩.
Spesso sospetto che le persone intendono un parametro negli argomenti del loro algoritmo per passare un valore e approvare un valore.Anche se so che ci sono linguaggi di programmazione che lo consentono, ti consiglio vivamente di non farlo.IL
Codice ⟨xsub, ysub, zsub⟩ = alg (⟨asub, bsub, csub⟩) non modifica i valori di asub, bsub o csub.
Ho visto un sacco di codice che loop n volte ricorsi Alg (⟨asub, bsub, csub⟩)
La stessa identica sotterranea ⟨ASUB, BSUB, CSUB⟩.Una definizione di follia sta ripetendo la stessa cosa più e più volte e aspettarsi di ottenere un risultato diverso.Tuo
L'amico sulla stessa sottoinstabilità ti darà la stessa soluzione.Non sprecare
il suo tempo.

---
layout: 
title: Pagina 123
level: 3
---


Astrazioni, tecniche e teoria
107
È allettante utilizzare una variabile globale a cui tutti hanno accesso.Tuttavia, questa è una forma molto negativa, principalmente perché è molto incline a errori e effetti collaterali
che non ti aspettavi.
Allo stesso modo, non puoi avere rendimenti globali.Ad esempio, supponiamo che il tuo amico
L'amico dell'amico trova qualcosa che stai cercando.Deve essere
passato amico all'amico, perché le cose restituite dai tuoi amici non ottengono
Restituito al tuo capo a meno che tu non faccia il ritorno.
2.7.) Poche variabili locali: un algoritmo iterativo è costituito da un grande ciclo con un set
delle variabili locali che detengono lo stato attuale.Ogni iterazione queste variabili vengono aggiornate.Perché pensare in modo iterativo arriva in modo più naturale alle persone, vogliono
Per fare questo con algoritmi ricorsivi.Non.Generalmente non è necessario un ciclo
In un algoritmo ricorsivo a meno che tu non abbia bisogno di un aiuto immediato di molti amici
e ti fai passare attraverso di loro, creando sottoinstanze per ciascuno e considerando
le loro subsoluzioni.In effetti, nonostante il nome "variabile", raramente c'è un bisogno
Per modificare il valore di una variabile una volta impostato inizialmente.Ad esempio, le variabili
⟨A, B, C⟩ -STORING IL TUO istanza è sacro.Questa è l'istanza che devi risolvere.
Perché mai cambiarlo?È necessario costruire una soluzione ⟨x, y, z⟩.Crea e ritorna
Esso.Perché mai cambiarlo?Allo stesso modo per quello che dai ⟨asub, bsub, csub⟩ e ricevi
⟨Xsub, ysub, zsub⟩from ogni amico.Altre variabili locali sono raramente necessarie.Se tu
Ne ho bisogno, assicurati di documentare a cosa servono.
3) Attività da completare: la tua missione, data un'istanza arbitraria ⟨a, b, c⟩meeting
Le condizioni preliminari sono costruire e restituire una soluzione ⟨x, y, Z⟩ che soddisfa la postcondizionamento.I seguenti sono gli unici passaggi che dovresti seguire verso questo
obiettivo.
3.1.) Accetta la tua missione: immagina di avere un ⟨a, b, c⟩meeting the precondizioni.Conosci la gamma di cose che potrebbe essere la tua istanza.Ad esempio, se l'istanza di input è un albero binario, assicurati che il tuo programma funzioni per un
albero generale con grandi sobbolli sinistra e destra, un albero con grande sinistra e vuoto a destra, a
albero con vuoto a sinistra e grande a destra e l'albero vuoto.Sappi anche ciò che è necessario
del tuo output.
3.2.) Costruire la sottoinstabilità: per ogni amico, costrutto dalla tua istanza
⟨A, B, C⟩A Subinstance ⟨asub, bsub, csub⟩ per dare a questo amico.A volte questo richiede un blocco di codice.A volte succede proprio sul posto.Ad esempio, se la tua istanza è ⟨⟨A1, A2 ,..., an⟩, b, c⟩, potresti costruire la subinstance
⟨⟨A1, A2 ,..., an -1⟩, b −5, sinistra (c)⟩ per il tuo amico spogliando l'ultimo oggetto
la tupla A, sottraendo 5 dall'intero B, e prendendo la sottostruttura sinistra del
albero c.Questa subinstance può essere costruita e passata al tuo amico in quello
linea
⟨Xsub, ysub, zsub⟩ = alg (⟨⟨a1, a2,.., An -1⟩, b −5, sinistra (c)⟩)

---
layout: 
title: Pagina 124
level: 3
---


Ricorsione
108
3.2.1.) Subinstance valida: assicurarsi che la subinstance ⟨ASUB, BSUB, CSUB⟩THTHT
Dai che il tuo amico incontra i presupposti.
3.2.2.) Subina più piccola: assicurarsi che la subinstance ⟨ASUB, BSUB, CSUB⟩
che dai al tuo amico è in qualche modo più piccolo della tua sottoinstance
⟨A, B, C⟩.
3.3.) Fidati del tuo amico: concentrati solo sulla tua missione.Fidati del tuo amico per darti
una soluzione corretta ⟨xsub, ysub, zsub⟩to istanza ⟨asub, bsub, csub⟩ che dai
suo.Non preoccuparti di come ottiene la sua risposta.Non tracciare l'intero
calcolo.Non parlare degli amici dei tuoi amici.Non posso sottolineare
abbastanza.Di volta in volta, vedo che gli studenti non si fidano.Non fa no
Fine dei guai fino a quando non vedono finalmente la luce e lasciano andare.
3.4.) Costruisci la tua soluzione: utilizzando le soluzioni ⟨xsub, ysub, zsub⟩
I tuoi amici per la tua sottoinstabilità ⟨Asub, Bsub, Csub⟩, il tuo prossimo compito è costruire una soluzione ⟨x, y, z⟩ per la tua sottoinstallazione ⟨a, b, c⟩.Questo generalmente richiede
un blocco di codice, ma a volte può essere contenuto in una singola riga.Ad esempio, se l'unico output è un singolo intero x, allora la riga di codice
restituire (ALG (ASUB1, BSUB1, CSUB1) + ALG (ASUB2, BSUB2, CSUB2)) combina le soluzioni degli amici XSUB1 e XSUB2 per dare la soluzione x = XSUB1 + XSUB2 e la restituisce.
3.5.) Casi di base: considera quale istanza venga risolto dal programma.Per coloro
Ciò non no, aggiungi più casi per risolverli in modo ricorsivo o aggiungere casi di base
Per risolverli in modo bruto.Se l'istanza di input è sufficientemente piccola
Secondo la tua definizione delle dimensioni, allora devi risolverlo da solo come base
caso.
Questo è tutto ciò che devi fare.Non fare di più.
Esercizio 8.5.1
Ora sei il professore.Quale dei passaggi precedenti per sviluppare a
Algoritmo ricorsivo Gli studenti non hanno fatto correttamente nel seguente codice?Come?
Come lo faresti?Vedere l'esercizio 10.3.1 per il codice corretto per questo problema.
Algoritmo più piccolo (albero, k, num, v)
⟨Pre-Cond⟩: L'albero è un albero di ricerca binario e K> 0 è un numero intero.
⟨Post-Cond⟩: emette l'elemento più piccolo KTH s.
inizio
if (k = 0) return (0)
if (v = k) return (elemento)
n = 0
Più piccolo (sinistra (albero))
+ + n

---
layout: 
title: Pagina 125
level: 3
---


Astrazioni, tecniche e teoria
109
if (n = k)
return (root (albero))
finisci se
PIÙ PIÙ PIERE (di Rightsub (albero))
finisci se
Algoritmo di fine
Algoritmo più piccolo (albero, k, num, v)
⟨Pre-Cond⟩: L'albero è un albero di ricerca binario e K> 0 è un numero intero.
⟨Post-Cond⟩: emette l'elemento più piccolo KTH s.
inizio
n = 0
mentre (n <k)
Più piccolo (sinistra (albero))
+ + n
PIÙ PIÙ PIERE (di Rightsub (albero))
terminare mentre
restituzione (elemento)
Algoritmo di fine
Esercizio 8.5.2 (vedi soluzione nella quinta parte.) Nel livello degli amici di astrarre la ricorsione, puoi dare al tuo amico qualsiasi istanza legale più piccola del tuo secondo alcuni
Misura fintanto che risolvi da solo ogni istanza che sia sufficientemente piccolo.Per
Quale di questi algoritmi è stato fatto?In tal caso, qual è la tua misura delle dimensioni di
l'istanza?Sull'istanza di input ⟨n, M⟩, lega la profondità a cui l'algoritmo
ricorre in funzione di n e m o dimostrare che esiste almeno un percorso lungo il
albero di ricorsione che è in fini.
Algoritmo RA (N, M)
⟨Pre-Cond⟩: N&M INTS.
⟨Post-Cond⟩: saluta
inizio
if (n ≤0)
Stampa ("ciao")
altro
RA (n −1, 2m)
finisci se
Algoritmo di fine
Algoritmo RB (N, M)
⟨Pre-Cond⟩: N&M INTS.
⟨Post-Cond⟩: saluta
inizio
if (n ≤0)
Stampa ("ciao")
altro
RB (n −1, m)
RB (N, M −1)
finisci se
Algoritmo di fine

---
layout: 
title: Pagina 126
level: 3
---


Ricorsione
110
Algoritmo RC (N, M)
⟨Pre-Cond⟩: N&M INTS.
⟨Post-Cond⟩: saluta
inizio
(d) Sostituire le linee ricorsive con
if (n ≤0 o m ≤0)
Stampa ("ciao")
RD (N −1, M + 2)
altro
Re (n + 6, m −3)
Rc (n −1, m)
RC (N, M −1)
(e) Sostituire le linee ricorsive con
finisci se
Re (n −4, m + 2)
Re (n + 6, m −3)
Algoritmo di fine
8.6
Il telaio dello stack
Tree of Stack Frame: tracciare l'intero calcolo di un algoritmo ricorsivo, una riga di codice alla volta, può diventare incredibilmente complesso.Ecco perché il livello di amici di
L'astrazione, che considera un frame stack alla volta, è il modo migliore per comprendere, spiegare e progettare un algoritmo ricorsivo.Tuttavia, è anche utile avere qualche immagine dell'intero calcolo.Per questo, il livello di astrazione dell'albero di stack
è meglio.
La cosa chiave da capire è la differenza tra una routine particolare e a
Esecuzione particolare di una routine su una particolare istanza di input.Una singola routine può
In un momento in tempo hanno molte esecuzioni in corso.Ogni esecuzione di questi viene definita un frame dello stack.Puoi pensare a ciascuno come il compito dato a un amico separato.
Anche se ogni amico può eseguire esattamente la stessa routine, ogni esecuzione
può attualmente essere su una diversa riga di codice e avere valori diversi per il locale
variabili.
Se ogni routine effettua una serie di chiamate di subroutine (ricorsive o meno), allora il
I frame in pila che vengono eseguiti formano un albero.Nell'esempio della Figura 8.2, istanza a
è chiamato primo.Esegue per un po 'e ad un certo punto chiama ricorsivamente B. quando B
Restituisce, A poi esegue per un po 'più a lungo prima di chiamare H. Quando H ritorna, A esegui per un po' prima di completare.Abbiamo saltato i dettagli dell'esecuzione
di B. torniamo a quando l'istanza A chiama B. Quindi B chiama C, che chiama D. D completa;Quindi C chiama E. Dopo E, C si completa.Quindi B chiama F, che chiama G. Quindi G
Completa, F completi, B si completa e A continua a chiamare H. Diventa complicato.
Stack of Stack Frame: l'algoritmo è effettivamente implementato su un computer da
Una pila di cornici dello stack.Ciò che viene archiviato nella memoria del computer in un dato punto
Il tempo è solo un singolo percorso lungo l'albero.L'albero rappresenta ciò che accade dappertutto
tempo.Nella Figura 8.2, quando l'istanza G è attiva, A, B, F e G sono nello stack.C, d e e
E sono stati rimossi dalla memoria come hanno completato.H, io, J e K hanno

---
layout: 
title: Pagina 127
level: 3
---


Astrazioni, tecniche e teoria
111
K
H
G
F
B
UN
J
IO
E
D
C
Figura 8.2: albero dei cornici dello stack.
non è stato ancora iniziato.Anche se parliamo di molti frame di stack separati che eseguono
Il computer, il computer non è una macchina parallela.Solo il telaio dello stack superiore G è
essere eseguito attivamente.Gli altri casi sono in attesa, in attesa del ritorno di a
La subita della subroutine è stata fatta.
Memoria: ecco come viene gestita la memoria per l'esecuzione simultanea di molti
istanze della stessa routine.La routine stessa è descritta solo una volta, da un blocco di
Codice che appare nella memoria statica.Questo codice dichiara una serie di variabili.Dall'altra
mano, ogni istanza di questa routine che è attualmente eseguita potrebbe essere archiviata
valori diversi in queste variabili e quindi devono avere una propria copia separata di
queste variabili.I requisiti di memoria di ciascuna di questi casi sono archiviati
un telaio di stack separato.Questi frame sono impilati l'uno sull'altro all'interno dello stack
memoria.
Usando un frame dello stack: ricorda che uno stack è una struttura di dati in cui una nuova
viene spinto l'elemento in alto o l'ultimo elemento da aggiungere
OFF (Sezione 3.1).Indichiamo il frame stack superiore di A. quando l'esecuzione di
A fa una chiamata di subroutine a una routine con alcuni valori di input, un frame stack è
creato per questa nuova istanza.Questo frame indicato B viene spinto sullo stack dopo che per A. Oltre a una copia separata delle variabili locali per la routine, contiene un puntatore alla riga di codice successiva che A deve eseguire quando B ritorna.
Quando B ritorna, il suo telaio dello stack viene visualizzato e A continua ad eseguire sulla linea di
Codice che era stato indicato all'interno di B. quando un completamento, è anche messo fuori
pila.
Esempio sciocco: questo esempio dimostra quanto sia difficile tracciare il pieno
Albero del telaio da stack, ma quanto è facile determinare l'output usando il metodo Friends (Strong Induction):
Algoritmo Fun (N)
⟨Pre-Cond⟩: n è un numero intero.
⟨Post-Cond⟩: emette una stringa sciocca.
inizio
if (n> 0) allora

---
layout: 
title: Pagina 128
level: 3
---


Ricorsione
112
if (n = 1) allora
Metti "X"
altrimenti se (n = 2) quindi
Metti "Y"
altro
Metti "A"
Divertimento (n −1)
Metti "B"
Divertimento (n −2)
Metti "C"
finisci se
finisci se
Algoritmo di fine
Esercizio 8.6.1 Tentativo di tracciare l'albero delle cornici dello stack per l'esempio sciocco
Divertimento (5).
Esercizio 8.6.2 (vedi soluzione nella quinta parte.) Ora prova il seguente approccio più semplice.
Qual è l'output di Fun (1)?Qual è l'output di Fun (2)?Fidati delle risposte a tutti
domande precedenti;Non ricalcolarli.(Supponiamo che un amico di fiducia ti abbia dato la risposta.) Ora, qual è l'output di Fun (3)?Ripeti questo approccio per n = 4, 5 e 6.
8.7
Prova correttezza con una forte induzione
Sia che tu dia le tue sotterranee agli amici o ti ricordi, questo livello di
L'astrazione considera solo l'algoritmo per il telaio dello stack superiore.Ora dobbiamo dimostrare
che questo suffitta a produrre un algoritmo che risolve con successo il problema per
Ogni istanza di input.Quando si dimostra, è allettante parlare di frame dello stack.
Questo telaio dello stack chiama questo, che chiama quello, fino a quando non si colpisce il caso di base.Poi
Le soluzioni tornano in superficie.Queste prove tendono a avere poco senso.
Invece, usiamo una forte induzione per dimostrare formalmente che il livello di astrazione degli amici
lavori.
Forte induzione: una forte induzione è simile all'induzione, tranne che anziché
Supponendo che solo s (n −1) per dimostrare s (n), è necessario assumere tutto s (0), s (1), s (2) ,..., S (n −1).
Una dichiarazione per ogni n: per ogni valore di n ≥0, Sia (n) rappresentare un booleano
dichiarazione.Per alcuni valori di n questa affermazione può essere vera, e per altri esso
può essere falso.
Obiettivo: il nostro obiettivo è dimostrare che è vero per ogni valore di n, vale a dire che ∀n ≥
0, s (n).

---
layout: 
title: Pagina 129
level: 3
---


Astrazioni, tecniche e teoria
113
Schema di prova: prova con una forte induzione su n.
Ipotesi di induzione: per ciascuna n ≥0, s (n) sia l'affermazione che....(Esso
è importante affermarlo chiaramente.)
Caso base: dimostrare che la dichiarazione S (0) è vera.
Fase di induzione: per ciascun n ≥0, provare s (0), s (1), s (2) ,..., S (n −1) ⇒s (n).
Conclusione: a titolo di induzione, possiamo concludere che ∀n ≥0, s (n).
Vedi Esercizi 8.7.1 e 8.7.2.
Dimostrando l'algoritmo ricorsivo opere:
Ipotesi di induzione: per ogni n ≥0, Sia S (n) essere l'affermazione “il ricorsivo
L'algoritmo funziona per ogni istanza di dimensioni n. "
Obiettivo: il nostro obiettivo è dimostrare che ∀n ≥0, s (n), cioè che l'algoritmo ricorsivo
Funziona per ogni istanza.
Schema di prova: la prova è una forte induzione su n.
Caso base: dimostrare s (0) implica dimostrare che l'algoritmo funziona per il
Casi di base di dimensioni n = 0.
Fase di induzione: l'istruzione S (0), S (1), S (2) ,..., S (n −1) ⇒s (n) è dimostrato come segue.Prima supponiamo che l'algoritmo funzioni per ogni istanza di
dimensioni rigorosamente più piccole di n, e quindi dimostrare che funziona per ogni istanza
di dimensioni n.Questo rispecchia esattamente quello che facciamo a livello di astrazione degli amici.Per dimostrare che l'algoritmo funziona per ogni istanza di dimensioni n, considera
Un'istanza arbitraria di dimensioni n.L'algoritmo costruisce la sottoinstabilità che
sono strettamente più piccoli.Con la nostra ipotesi di induzione sappiamo che il nostro algoritmo
funziona per questi.Quindi, le chiamate ricorsive restituiscono le soluzioni corrette.SU
Il livello di astrazione degli amici, abbiamo dimostrato che l'algoritmo costruisce il
soluzioni corrette alla nostra istanza dalle soluzioni corrette alle sottoinstanze.Quindi, l'algoritmo funziona per questa istanza arbitraria di dimensioni n.IL
S (n) segue.
Conclusione: a titolo di forte induzione, possiamo concludere che ∀n ≥0, s (n), cioè l'algoritmo ricorsivo funziona per ogni istanza.
Esercizio 8.7.1 Dare il processo di induzione forte come abbiamo fatto per un'induzione regolare.
Esercizio 8.7.2 (vedere la soluzione nella parte cinque.) Come dichiarazione formale, il caso di base può
essere eliminato in una forte induzione perché è incluso nella fase di induzione formale.
Com'è?(In pratica, i casi di base sono ancora dimostrati separatamente.)

---
layout: 
title: Pagina 130
level: 3
---


114
9 Alcuni semplici esempi di
Algoritmi ricorsivi
Ora darò alcuni semplici esempi di algoritmi ricorsivi.Anche se hai visto
loro prima, studiali di nuovo, mantenendo le tecniche e la teoria dal capitolo 8 in
mente.Per ogni esempio, cerca i passaggi chiave del paradigma degli amici.Quali sono le
Sottopertori dati all'amico?Qual è la dimensione di un'istanza?Diventa più piccolo?
Come vengono combinate le soluzioni dell'amico per dare la tua soluzione?Cosa fa l'albero di
Le cornici dello stack sembrano?Qual è la complessità temporale dell'algoritmo?
9.1
Ordinamento e selezione di algoritmi
Gli algoritmi classici di divisione e conquista sono l'ordinamento di unione e rapido.Entrambi
avere la seguente struttura di base.
Algoritmo di smistamento ricorsivo generale:
r Prendi l'elenco fornito di oggetti da ordinare (numeri, stringhe, record degli studenti, ecc.).
r ha diviso l'elenco in due sublisti.
r Ricorsivamente Avere gli amici ordinano ciascuno dei due sublisti.
r combina i due sublisti ordinati in un elenco completamente ordinato.
Questo processo porta a quattro diversi algoritmi, a seconda dei seguenti fattori
(Vedi Esercizio 9.1.1):
Dimensioni: dividi l'elenco in due sublisti ciascuno di dimensioni n
2 o una delle dimensioni n −1
E una delle dimensioni uno?
Lavoro: fai un minimo sforzo per dividere l'elenco ma fai molto sforzo in
ricombinare i sublisti o fare molti sforzi per dividere l'elenco ma fare un minimo sforzo per ricombinare i sublisti?

---
layout: 
title: Pagina 131
level: 3
---


Alcuni semplici esempi di algoritmi ricorsivi
115
Esempio 9.1.1
Unisci Ordine (lavoro minimo per dividere a metà)
Questo è il classico algoritmo ricorsivo.
Livello di astrazione dell'amico: dare ricorsivamente a un amico la prima metà dell'input a
Ordina e un altro amico la seconda metà da ordinare.Quindi combina questi due sublisti ordinati
in un elenco completamente ordinato.Questo processo di combinazione viene definito fusione.UN
L'algoritmo a tempo lineare semplice può essere trovato nella Sezione 3.3.
Dimensione: la dimensione di un'istanza è il numero di elementi nell'elenco.Se questo è almeno due, i sublisti sono più piccoli dell'intero elenco.Quindi, è valido per ricorrere a loro
Con la rassicurazione che i tuoi amici faranno correttamente le loro parti.D'altra parte, se l'elenco contiene solo un elemento, quindi per impostazione predefinita è già ordinato e niente
deve essere fatto.
Generalizzare il problema: se si presume che l'input sia ricevuto in un array indicizzato
Da 1 a N, quindi la seconda metà dell'elenco non è un'istanza valida, perché non lo è
indicizzato da 1. Pertanto, ridimensioniamo le condizioni preliminari del problema di smistamento da richiedere
come input sia un array a che un subrange [i, j].La postcondizionalità è che lo specificato
Sublist deve essere ordinato sul posto.
Tempo di esecuzione: Sia t (n) il tempo totale richiesto per ordinare un elenco di N elementi.Questo
Il tempo totale consiste nel tempo per due sottoinstanze della metà della dimensione da ordinare, più (n) tempo per unire i due sublisti insieme.Questo dà la relazione di ricorrenza t (n) = 2t (n/2) + (n).Vedi il capitolo 27 per imparare a risolvere le relazioni di ricorrenza come queste.In questo esempio, loga
logb = log 2
log 2 = 1 e f (n) = (n1), quindi c = 1. perché
loga
logb = c, la tecnica conclude che il tempo è dominato da tutti i livelli e t (n) =
(f (n) logn) = (n logn).
Frame di albero di stack: quello che segue è un albero di cornici dello stack per un esempio di cemento:
Out: 100 21 97 53 25 105 8 45
In: 100 21 97 53 25 105 8 45



Fuori: 21 100 40 53 97 9 25 105 99 8 45 10
In: 100 21 40 97 53 9 25 105 99 8 45 10



Out: 21 40 100 Out: 9 53 97 Out: 25 99 105 Out: 8 10 45
In: 100 21 40 in: 97 53 9 in: 25 105 99 in: 8 45 10



Out: 9 21 40 53 97 100 Out: 8 10 25 45 99 105
In: 100 21 40 97 53 9 in: 25 105 99 8 45 10


In: 100 21 40 97 53 9 25 105 99 8 45 10

Out: 8 9 10 21 25 40 45 53 97 99 100 105

---
layout: 
title: Pagina 132
level: 3
---


Ricorsione
116
Esempio 9.1.2
Ordine rapida (lavoro minimo per ricombinare le metà)
Quello che segue è uno degli algoritmi di smistamento più veloce.Da qui il nome.
Livello di astrazione dell'amico: l'algoritmo si divide l'elenco in due sublisti dove
Tutti gli elementi che sono inferiori o uguali a un elemento di perno scelto sono a sinistra
dell'elemento pivot e tutti gli elementi che sono maggiori di quanto non siano a destra di
Esso.(Non ci sono requisiti sull'ordine degli elementi nei sublisti.) Successivamente, avere ricorsivamente un amico ordinare quegli elementi davanti al perno e quelli che lo dopo.Infine, (senza sforzo) metti insieme i sublisti, formando una lista completamente ordinata.
Il primo passo nell'algoritmo è scegliere uno degli elementi per essere il perno
elemento.Di seguito viene discusso il modo in cui questo deve essere fatto.
Frame di albero di stack: quello che segue è un albero di cornici dello stack per un input specifico:
Fuori: 45
In: 40 45



Fuori: 8 40 45 99 105
In: 8 9 40 45 53 99 100 105



Out: 8 9 Out: 21 Out: 40 45 53 Out: 99 100 105
In: 9 8 10 in: 21 in: 40 53 45 97 in: 100 105 99



Out: 8 9 10 21 Out: 40 45 53 97 99 100 105
In: 21 9 8 10 25 in: 100 40 97 53 105 99 45



Out: 8 9 10 21 25 40 45 53 97 99 100 105
In: 100 21 40 97 53 9 25 105 99 8 45 10
Tempo di esecuzione: il tempo di calcolo dipende dalla scelta dell'elemento pivot.
Mediana: se siamo fortunati e l'elemento pivot è vicino ad avere il valore mediano, l'elenco verrà diviso in due sublisti di dimensioni circa N/2.Lo vedremo
Il partizionamento dell'array in base all'elemento pivot può essere eseguito in tempo (N).In
Questo caso, il tempismo è t (n) = 2t (n/2) + (n) = (n logn).
Divisione ragionevole: il tempismo di cui sopra è piuttosto robusto rispetto alla scelta di
il perno.Ad esempio, supponiamo che il perno partiti sempre l'elenco in uno
Sublist di un ﬁ fenza della dimensione originale e uno dei quattro pesanti della dimensione originale.IL
Il tempo totale è quindi il tempo di partizione più il tempo per ordinare i sublisti di questi
dimensioni.Questo dà t (n) = t (1
5n) + t (4
5n) + (n).Perché 1
5 + 4
5 = 1, questo valuta
a t (n) = (n logn).(Vedi capitolo 27.)
Caso peggiore: d'altra parte, supponiamo che il perno divini sempre l'elenco in
una delle dimensioni n −1 e una delle dimensioni 1. In questo caso, t (n) = t (n −1) + t (1) + (n), che valuta a t (n) = (n2).Questo è lo scenario peggiore.
Ritorneremo a Sorved Sord dopo aver considerato il seguente problema correlato.

---
layout: 
title: Pagina 133
level: 3
---


Alcuni semplici esempi di algoritmi ricorsivi
117
Esempio 9.1.3
Trovare l'elemento più piccolo KTH
Dato un elenco non orientato e un numero intero K, questo esempio trova l'elemento più piccolo KTH
Dall'elenco.Non è chiaro al primo posto che esiste un algoritmo per farlo che è un altro
Più veloce dell'ordinamento dell'intero elenco.Tuttavia, può essere fatto in tempo lineare usando il perno della subroutine.
Livello di astrazione dell'amico: l'algoritmo è così per la ricerca binaria.Ignorando l'input K, procede proprio come un po 'rapido.Un elemento per pivot viene scelto in modo casuale e l'elenco lo è
diviso in due sublisti, il primo contenente tutti gli elementi che sono tutti meno o uguali a
L'elemento pivot e il secondo quelli che sono maggiori di esso.Lascia che sia il numero di
elementi nel primo sublist.Se ℓ≥k, allora sappiamo che l'elemento più piccolo KTH da
L'intero elenco è anche l'elemento più piccolo KTH dal primo sublist.Quindi, possiamo dare
Questo primo sublist e questo k a un amico e gli chiede di trovarlo.D'altra parte, se ℓ <k, allora sappiamo che l'elemento più piccolo KTH dall'intero elenco è il più piccolo
Elemento dal secondo sublist.Quindi, dando il secondo sublist e k −ℓto a
Amico, può trovarlo.
Frame di albero di stack: quello che segue è un albero di cornici dello stack per il nostro input.
Out = 45
Dimensione sinistra = 4> = k
A destra: 100 105 99
A sinistra: 40 97 53 45
Pivot = 97
k = 7–5 = 2
Ordinato: 40 45 53 97 99 100 105)
In: 100 40 97 53 105 99 45

Out = 45
Dimensione sinistra = 2> = k
A destra: 97 53
A sinistra: 40 45
Pivot = 45
k = 2
Ordinato: 40 45 53 97)
In: 40 97 53 45
Out = 45
Dimensione sinistra = 1 <k
A destra: 45
A sinistra: 40
Pivot = 40
k = 2
Ordinato: 40 45)
In: 40 45
k = 2–1 = 1 out: 45
Ordinato: 45)
In: 45
Out = 45
Dimensione sinistra = 5 <k
A destra: 100 40 97 53 105 99 45
A sinistra: 21 9 25 8 10
Pivot = 25
k = 7
Ordinato: 8 9 10 21 25 40 45 53 97 99 100 105)
In: 100 21 40 97 53 9 25 105 99 8 45 10

---
layout: 
title: Pagina 134
level: 3
---


Ricorsione
118
Esempio 9.1.3
Trovare l'elemento più piccolo KTH (cont.)
Tempo di esecuzione: ancora una volta, il tempo di calcolo dipende dalla scelta dell'elemento pivot.
Mediana: se siamo fortunati e l'elemento per pivot è vicino al valore mediano, allora
L'elenco verrà diviso in due sublisti di dimensioni circa N/2.Perché la routine
Ricorsi solo su una delle metà, il tempismo è t (n) = t (n/2) + (n) = (n).
Divisione ragionevole: se il perno divide sempre l'elenco in modo che la metà più grande sia a
la maggior parte 4
5n, quindi il tempo totale è al massimo t (n) = t (4
5n) + (n), che è ancora lineare
tempo, t (n) = (n).
Caso peggiore: nel peggiore dei casi, il perno divide l'elenco in una delle dimensioni n -1 e
Uno delle dimensioni 1. In questo caso, t (n) = t (n −1) + (n), che è t (n) = (n2).
Scegliere il perno: negli esempi 9.1.2 e 9.1.3, i tempi dipendono dalla scelta
Un buon elemento per giro rapidamente.
Valore fisso: se sai che stai ordinando elementi che sono numeri all'interno
L'intervallo [1..100], quindi è ragionevole partizione di questi elementi in base a
se sono più piccoli o più grandi di 50. Questo è spesso indicato come ordinamento del secchio.
Vedere la Sezione 5.1.Tuttavia, ci sono due problemi con questa tecnica.Il primo è
che in generale non sappiamo in quale intervallo si troveranno gli elementi di input. Il secondo è che ad ogni livello di ricorsione è necessario un altro valore per il perno con cui
partizione gli elementi.La soluzione è utilizzare l'input stesso per scegliere il perno
valore.
Usa un [1] come perno: la prima cosa che si potrebbe provare è lasciare che il perno sia l'elemento che sembra essere primo nell'array di input.Il problema con questo è che se
L'input sembra essere già ordinato (o quasi ordinato), quindi questo primo elemento
Dividerà l'elenco in una dimensione zero e una delle dimensioni n -1.Questo dà un peggio
Caso tempo di (N2).Dati dati casuali, l'algoritmo eseguirà rapidamente.SU
l'altra mano, se dimentichi di aver ordinato i dati e li esegui un secondo
Tempo, quindi la seconda corsa richiederà molto tempo per essere completato.
Usa un [n
2] Come perno: motivato dall'ultimo tentativo, si potrebbe usare l'elemento
Ciò accade nel mezzo dell'array di input.Per tutti gli scopi pratici, questo probabilmente funzionerebbe bene.Funzionerebbe eccezionalmente bene quando l'elenco
è già ordinato.Tuttavia, ci sono alcuni strani input cotti per la suola
scopo di essere brutto per questa particolare attuazione dell'algoritmo,
che l'algoritmo funziona in tempo (N2).L'avversario fornirà un tale input, dando una complessità del tempo peggiore di (N2).
Un elemento scelto in modo casuale: in pratica, ciò che viene spesso fatto è scegliere il
Elemento pivot casualmente dagli elementi di input.Vedere la sezione 21.1.Il vantaggio di questo è che l'avversario che sta scegliendo l'istanza di input del caso peggiore

---
layout: 
title: Pagina 135
level: 3
---


Alcuni semplici esempi di algoritmi ricorsivi
119
Conosce l'algoritmo, ma non conosce i lanci di monete casuali.Quindi, tutti gli input
Le istanze sono ugualmente buone e ugualmente cattive.
Dimostreremo che il tempo di calcolo previsto è (n logn).Cosa questo
significa che se hai eseguito l'algoritmo 1.000.000 di volte sullo stesso input, allora
Il tempo di esecuzione medio sarebbe (n logn).
Intuizione: si ottiene spesso una buona intuizione assumendo che ciò che ci aspettiamo
accadere accade ragionevolmente spesso.Se il pivot si divide sempre l'elenco
In un sublist di un ﬁ fth la dimensione originale e una delle quattro persone della dimensione originale, quindi il tempo totale è t (n) = t (1
5n) + t (4
5n) + (n) = (n logn).
Quando un perno viene scelto in modo casuale, la probabilità che si dividesse l'elenco
almeno questo bene è 3
5. Quando una partizione è peggiore di così, non è un grosso problema.
Diciamo solo che non vengono fatti progressi significativi e ci riproviamo.Dopotutto, ci aspettiamo di fare progressi in circa tre di cinque partizioni.
Più formale: formalmente, impostiamo e risolviamo una relazione di ricorrenza difficile.
Supponiamo che l'elemento pivot scelto in modo casuale sia il ith
elemento più piccolo.Questo divide l'elenco in uno di sizei e uno delle dimensioni n -i, in
Qual è il tempo di esecuzione t (i) + t (n −i) + (n).In media questo su tutto
Valori possibili OFI fornisce la relazione ricorsiva t (n) = Avgi∈ [0..n]

T (i) + t (n -
i) + (n)

.Con un bel po 'di lavoro, questo valuta a (n logn).
Scegli casualmente tre elementi: un'altra opzione è selezionare casualmente tre
Elementi dall'elenco di input e usa quello centrale come perno.Facendo questo
aumenta notevolmente la probabilità che il perno sia vicino al mezzo e quindi
Riduce la probabilità che si verifichi il caso peggiore.Tuttavia, lo prende così anche
tempo.Tutto sommato, il tempo di esecuzione previsto è peggio.
Un algoritmo deterministico: sebbene in pratica sia un algoritmo così probabilistico
Facile da codificare e funzionare bene, gli informatici teorici piace trovare un algoritmo deterministico che è garantito per funzionare rapidamente.
Quello che segue è un metodo deterministico per scegliere il perno che porta a un
Tempo di esecuzione del caso peggiore di (n) per trovare l'elemento più piccolo KTH.Primo gruppo
gli elementi n in n
5 gruppi di cinque elementi ciascuno.All'interno di ogni gruppo di cinque anni
elementi, do (1) lavorare per trovare la mediana del gruppo.Lascia che Smedian sia l'insieme di
N
5 elementi contenenti la mediana di ciascun gruppo.Chiedi ricorsivamente a un amico di
trovare l'elemento mediano dal set smedian.Questo elemento verrà usato come nostro
perno.
Affermo che questo elemento perno ne ha almeno 3
10n elementi che sono inferiori a o
uguale ad esso e un altro
3
10n elementi più grandi o uguali ad esso.La prova di
Il reclamo è il seguente.Perché il perno è la mediana all'interno dello Smedia, ci sono
1
10n = 1
2 | Smedian |elementi all'interno di Smedian che sono meno o uguali al perno.
Considera qualsiasi elemento di questo tipo xi ∈Smediano.Perché Xi è la mediana all'interno del suo gruppo
Di cinque elementi, ci sono tre elementi all'interno di questo gruppo (incluso XI stesso)
che sono inferiori o uguali a XI e quindi a loro volta meno o uguali al perno.

---
layout: 
title: Pagina 136
level: 3
---


Ricorsione
120
Il conteggio di tutti questi dà 3 × 1
10n elementi.Un argomento simile conta così tanti
che sono maggiori o uguali al perno.
L'algoritmo per trovare il più grande elemento KTH procede originariamente come indicato.
A un amico viene chiesto di trovare o l'elemento più piccolo KTH all'interno di tutti gli elementi che
sono meno o uguali al perno o al più piccolo elemento più piccolo da tutti quelli
che sono più grandi di esso.L'affermazione garantisce che le dimensioni del sublist dato al
L'amico è al massimo 7
10n.
A differenza del primo algoritmo per il falso elemento più piccolo KTH, questo algoritmo si riprende due volte.Quindi, si assume ingenuamente che il tempo di esecuzione
è (n logn).Tuttavia, un'attenta analisi mostra che è solo (n).Lascia che t (n) denoti il ​​tempo di esecuzione.Trovare la mediana di ciascuno dei 1
I gruppi 5n prende (N)
tempo.Recepando in modo ricorsivo la mediana di Smedian prende t (1
5n) tempo.Ricorrere
il restante al massimo
7
10n Elements prendono al massimo t (7
10n) tempo.Questo dà un totale di t (n) = t (1
5n) + t (7
10n) + (n) tempo.Perché 1
5 + 7
10 <1, questo valuta
T (n) = (n).(Vedi capitolo 27.)
Un algoritmo di ordinamento rapido deterministico può utilizzare questo tempo deterministico (N)
Algoritmo per la ricerca dell'elemento più piccolo KTH, per trovare la mediana dell'elenco
essere il perno.Perché partizionando gli elementi secondo il perno già
richiede (n) tempo, i tempi sono ancora t (n) = 2t (n
2) + (n) = (n logn).
Partizionamento secondo l'elemento pivot: questo è un passaggio iterativo.L'input
è costituito da un elenco di elementi a [i] ,..., A [J] e un elemento per pivot.L'output è costituito dagli elementi riorganizzati e un indice i, in modo tale che gli elementi A [i] ,..., A [i −1] sono tutti inferiori o uguali all'elemento pivot, un [i] è l'elemento pivot e
Gli elementi A [i + 1] ,..., A [j] sono tutti maggiori di esso.
L'anello invariante è che ci sono indici I ≤i ≤j ≤j per i quali:
1. I valori in un [i] ,..., A [i −1] è inferiore o uguale all'elemento perno.
2. I valori in un [j + 1] ,..., A [j] sono maggiori dell'elemento perno.
3. L'elemento pivot è stato rimosso ed è sul lato, lasciando una voce vuota a un [i] o a un [j].
4. Gli altri elementi in un [i] ,..., Un [J] non è stato considerato.
L'invariante in loop è stabilito impostando i = i e j = j, rendendo un [i] vuoto di
Mettere l'elemento in un [i] dove si trova l'elemento perno e mette l'elemento perno
a parte.
Se il ciclo invariante è vero e io <j, allora ci sono quattro possibili casi (vedi
Figura 9.1):
Caso A. A [i] è vuoto e un [j] ≤Pivot: a [j] appartiene a sinistra, quindi spostalo su
vuoto un [i].Ora un [J] è vuoto.Aumenta il lato sinistro aumentando I di uno.

---
layout: 
title: Pagina 137
level: 3
---


Alcuni semplici esempi di algoritmi ricorsivi
121
?
io
J
J
IO
Meno
Di più
?
io
J
J
IO
Meno
Di più
Inviare:
Pre:
D:
io
IO
Meno
Di più
?
J
J
J
IO
Meno
Di più
?
Inviare:
io
Pre:
C:
Inviare:
Pre:
B:
io
J
IO
Meno
Di più
?
J
J
J
IO
Meno
Di più
?
Inviare:
io
io
J
J
IO
Meno
Di più
Pre:
UN:
io
J
J
IO
Meno
Di più
?
?
J
Figura 9.1: sono mostrati i quattro casi di come iterare.
Caso B. a [i] è vuoto e un pivot [j]>: a [j] appartiene a destra ed è già
Là.Aumenta il lato destro diminuendo J di uno.
Caso C. A [J] è vuoto e un [i] ≤Pivot: a [i] appartiene a sinistra ed è già
Là.Aumenta il lato sinistro aumentando I di uno.
Caso D. a [j] è vuoto e un pivot [i]>: a [i] appartiene a destra, quindi spostalo a
il vuoto a [j].Ora un [i] è vuoto.Aumenta il lato destro diminuendo J di uno.
In ogni caso, viene mantenuto l'invariante loop.I progressi sono fatti perché J -I diminuisce.
Wheni = J, l'elenco è diviso secondo necessità, lasciando un [i] vuoto.Metti lì il perno.IL
Segue la postcondition.
Esercizio 9.1.1 (vedi soluzione nella parte cinque.) Considera l'algoritmo che mette minimo
sforzo per dividere l'elenco in una delle dimensioni n −1 e una delle dimensioni uno, ma mette un sacco di
sforzo per ricombinare i sublisti.Considera anche l'algoritmo che fa molto sforzo
di dividere l'elenco in una delle dimensioni N −1 e una delle dimensioni uno, ma fa uno sforzo minimo
nel ricombinare i sublisti.Quali sono questi due algoritmi?
Esercizio 9.1.2 (vedi soluzione nella quinta parte.) RECUSIONE ONE-ANDIME VS Iterazione.
1.
Il tuo compito è accettare una tupla ⟨A1, A2 ,..., e restituire la tupla invertita
⟨An, an -1 ,..., A1⟩.Essendo pigro, toglirai solo un elemento da un'estremità o
Aggiungi un elemento di nuovo su un'estremità.Ma hai amici ricorsivi per aiutarti.
Fornire sia un paragrafo contenente la spiegazione dell'amico dell'algoritmo e il codice ricorsivo.
2.
Supponiamo ora di avere uno stack, ma niente amici.(Vedi capitolo 3).Schizzo rapidamente
Un programma iterativo che risolve lo stesso problema.Assicurati di includere invarianti a loop e altri passaggi chiave richiesti per descrivere un algoritmo iterativo.
3.
Traccia ciascuno di questi due programmi.Passo dopo passo, confronta e confronta i loro calcoli su un computer.
Esercizio 9.1.3 Esercizio 4.4.1 chiede un algoritmo iterativo per la ricerca all'interno
Una matrice A [1..n, 1..m] in cui ogni riga è ordinata e ogni colonna viene ordinata.Questo
richiede che T (n, m) = n + m −1 delle voci della matrice sia esaminata.Esercizio 7.0.7

---
layout: 
title: Pagina 138
level: 3
---


Ricorsione
122
dimostra che questo è stretto quando n = m.Ma è chiaramente troppo grande quando m >> n, dato uno
può fare la ricerca binaria in ogni riga in tempo n logm << n + m −1.L'obiettivo ora è progettare un algoritmo ricorsivo che accede a t (n, m) ≈n log2 (m
n) voci.Come enorme suggerimento, la relazione di ricorrenza sarà t (n, m) = maxn′∈ [1, n] t (n ′, m
2) + t (n −n ′, m
2) + log2 n.
Devi guardare l'albero ricorsivo per ottenere un po 'di intuizione per il motivo per cui è il tempo
T (n, m) ≈n log2 (m
N ).È inoltre possibile collegare T (n, m) = n log2 (m
n) + 2n −log (n) −2 in questo
relazione di ricorrenza e vedere che lo soddisfa.
9.2
Operazioni sui numeri interi
Alzando un numero intero per una potenza BN, moltiplicando x × y e moltiplicazione a matrice ciascuno
hanno sorprendenti algoritmi di divisione e conquista.
Esempio 9.2.1
bn
Supponiamo che ti vengano dati due numeri interi B e N e desideri calcolare BN.
L'algoritmo iterativo: l'ovvio algoritmo iterativo si moltiplica semplicemente B insieme n volte.L'ovvio algoritmo ricorsivo si ripresenta con potenza (B, n) = B ×
Potenza (B, N −1).Ciò richiede le stesse moltiplicazioni N.
L'algoritmo di divisione e conquista semplice: l'ovvia tecnica di divisione e conquista taglia il problema in due metà usando la proprietà che B⌈n
2 ⌉ × b⌊n
2 ⌋ =
b⌈n
2 ⌉+⌊n
2 ⌋ = bn.Questo porta all'algoritmo ricorsivo Potenza (B, N) = Potenza (B, ⌈N
2 ⌉) ×
Potenza (b, ⌊n
2 ⌋).La sua relazione di ricorrenza dà t (n) = 2t (n
2) + 1 molteplicazioni.IL
Tecnica nel capitolo 27 nota che Loga
logb = log 2
log 2 = 1 e f (n) = (n 0), quindi c = 0. perché loga
logb> c, la tecnica conclude che il tempo è dominato dai casi di base e
T (n) = (n (loga)/(logb)) = (n).Questo non è più veloce dell'algoritmo iterativo standard.
Ridurre il numero di ricorsioni: questo algoritmo può essere migliorato notando che
Le due chiamate ricorsive sono quasi le stesse e quindi devono essere fatte solo una volta.IL
La nuova relazione di ricorrenza dà t (n) = 1t (n
2) + 1 molteplicazioni.Qui loga
logb = log 1
log 2 = 0
e f (n) = (n 0), quindi c = 0. perché loga
logb = c, concludiamo che il tempo è dominato
per tutti i livelli e t (n) = (f (n) log n) = (log n).
Codice:
Algoritmo Power (B, N)
⟨Pre-Cond⟩: n ≥0 (N e B non entrambi 0)
⟨Post-Cond⟩: Output Bn.
inizio
if (n = 0) quindi
Ritorno (1)
altro
mezzo = ⌊n
2 ⌋
p = potenza (b, metà)

---
layout: 
title: Pagina 139
level: 3
---


Alcuni semplici esempi di algoritmi ricorsivi
123
if (2 · mezzo = n) quindi
restituzione (p · p) % se n è uniforme, bn = b⌊n/2⌋ · b⌊n/2⌋
altro
restituzione (p · p · b) % se n è dispari, bn = b · b⌊n/2⌋ · b⌊n/2⌋
finisci se
finisci se
Algoritmo di fine
Albero di cornici dello stack:
Fuori: 1
In: b = 2, n = 0
Fuori: 2 = 1x1x2
In: b = 2, n = 1

Out: 4 = 2x2
In: b = 2, n = 2
Fuori: 32 = 4x4x2
In: b = 2, n = 5
Tempo di esecuzione:
Dimensione input: si è tentato di dire che i primi due algoritmi (n) richiedono un numero lineare di molteplicazioni e che l'ultimo (log n) si richiede un logaritmico
numero.Tuttavia, in effetti i primi due richiedono numero esponenziale (2n) e il
ultimo un numero lineare (n) nella dimensione dell'input, che in genere viene preso come il
Numero di bit, n = log n, necessario per rappresentare il numero.
Operazione: è giusto contare le moltiplicazioni e non le operazioni di bit in questo
caso?Non dico di no.L'output bn contiene (n logb) = 2 (n) bit, e quindi lo farà
Prendi così tante operazioni bit per produrre semplicemente la risposta.Dato questo, non lo è
Davvero giusto dire che la complessità del tempo è solo (N).
Esempio 9.2.2
x × y
La complessità temporale dell'esempio 9.2.1 è stata misurata in termini di numero di molteplicazioni.Questo ignora la domanda su quanto velocemente si può moltiplicare.
L'input per il problema successivo è costituito da due stringhe di N cifre ciascuna.Questi sono
visti come due numeri interi X e Y, in notazione binaria o decimale.Il problema è
Per moltiplicarli.
L'algoritmo iterativo: l'algoritmo della scuola elementare standard considera ciascuno
Coppia di cifre, una di X e l'altra da Y, e le moltiplica insieme.Questi
I prodotti N2 vengono spostati in modo appropriato e sommati.Il tempo totale è (N2).È difficile
Credi che si potrebbe farlo più velocemente.

---
layout: 
title: Pagina 140
level: 3
---


Ricorsione
124
Esempio 9.2.2
x × y (cont.)
8
2
7
5
9
6
4
2
1
2
4
8
6
3
1
8
7
2
3
5
1
0
4
0
4
9
2
8
9
2
L'algoritmo di divisione e conquista semplice: vediamo quanto può funzionare la tecnica divisa e conquista.Dividi ogni sequenza di cifre a metà e considera
ogni metà come intero.Questo dà x = x1 × 10n/2 + x0 e y = y1 × 10n/2 + y0.Moltiplicando questi simbolicamente dà
x × y =

x1 × 10
N
2 + x0

×

Y1 × 10
N
2 + y0

=

x1y1

× 10n +

x1y0 + x0y1

× 10
N
2 +

x0y0

.
L'ovvio algoritmo di divisione e conquista calcolerebbe ricorsivamente i quattro sottoproblemi X1Y1, X1Y0, X0Y1 e X0Y0, ciascuno di N
2 cifre.Questo richiederebbe 4t (n
2) tempo.Poi
Questi quattro prodotti vengono spostati in modo appropriato e sommati.Si noti che le aggiunte possono essere
fatto in (n) tempo.Vedere la Sezione 2.2.Quindi, il tempo totale è t (n) = 4t (n
2) + (n).Qui
loga
logb = log 4
log 2 = 2 e f (n) = (n1), quindi c = 1. perché loga
logb> c, la tecnica conclude
che il tempo è dominato dai casi di base e t (n) = (n (loga)/(logb)) = (n2).
Questo non è un miglioramento nel tempo.
Ridurre il numero di ricorsioni: supponiamo che potremmo trovare un trucco in modo che noi
necessario solo ricorrere tre volte anziché quattro.La propria intuizione potrebbe essere che questo
Fornirebbe solo un risparmio di tempo lineare, ma in realtà il risparmio è molto di più.T (n) =
3t (n
2) + (n).Ora loga
logb = log 3
Log 2 = 1.58..., che è ancora più grande di c.Quindi, il tempo è
ancora dominato dai casi di base, ma ora questo è t (n) = (n
loga
logb) = (n1.58 ...).Questo è
Un miglioramento significativo oltre (N2).
Il trucco: il primo passo è moltiplicare ricorsivamente X1Y1 e X0Y0 come richiesto.Questo lascia
noi solo una moltiplicazione ricorsiva.
Se rivedi l'espansione simbolica per x × y, vedrai che in realtà non lo facciamo
È necessario conoscere i valori di X1Y0 e X0Y1.Dobbiamo solo conoscere la loro somma.Simbolicamente, possiamo osservare quanto segue:
x1y0 + x0y1 =

x1y1 + x1y0 + x0y1 + x0y0

−x1y1 −x0y0
=

(x1 + x0)

Y1 + Y0

−x1y1 −x0y0
Quindi, la somma x1y0 + x0y1 di cui abbiamo bisogno può essere calcolata aggiungendo x1 a x0 e y1 a
y0;moltiplicando queste somme;e sottraendo i valori x1y1 e x0y0 che sappiamo

---
layout: 
title: Pagina 141
level: 3
---


Alcuni semplici esempi di algoritmi ricorsivi
125
da prima.Ciò richiede solo una moltiplicazione ricorsiva aggiuntiva.Ancora una volta usiamo
Il fatto che le aggiunte siano veloci, richiedono solo un tempo (n).
Codice:
Algoritmo Multiply (x, y)
⟨Pre-Cond⟩: xey sono due numeri interi rappresentati come una matrice di n cifre
⟨Post-Cond⟩: L'output è costituito dal loro prodotto rappresentato come una matrice di N + 1
cifre
inizio
if (n = 1) allora
risultato (x × y) % prodotto di singole cifre
altro
⟨X1, x0⟩ = alto e basso ordine n
2 cifre di x
⟨Y1, y0⟩ = alto e basso ordine n
2 cifre di y
A = multiply (x1, y1)
C = multiply (x0, y0)
B = Multiply (x1 + x0, y1 + y0) −a −c
Risultato (A × 10n + B × 10
N
2 + c)
finisci se
Algoritmo di fine
È sorprendente che questo trucco riduca il tempo da (N2) a (N1.58).
Dividi in più parti: la domanda successiva è se lo stesso trucco può essere esteso per migliorare ulteriormente il tempo.Invece di dividere ciascuno di X e Y in due
Pezzi, dividiamoli ciascuno in pezzi D.Il metodo semplice moltiplica in modo ricorsivo ciascuna delle coppie di pezzi D2 insieme, una da X e una di Y.Il totale
Il tempo è t (n) = d2t (n
d) + (n).Qui a = d2, b = d, c = 1 e log d2
log d = 2> c.Questo da
T (n) = (n2).Ancora una volta, siamo tornati da dove abbiamo iniziato.
Ridurre il numero di ricorsioni: il trucco ora è fare lo stesso con meno moltiplicazioni ricorsive.Si scopre che può essere fatto con solo 2D −1 di essi.Questo
dà tempo di solo t (n) = (2d −1) t (n
d) + (n).Qui a = 2d −1, b = d, c = 1 e
registro (2d - 1)
registro (d)
≈log (d) +1
registro (d)
= 1 +
1
log (d) ≈c.Aumentando D, i tempi per il telaio dello stack superiore e
Per i casi di base diventano sempre più vicini all'essere uguali.Ricordiamo che quando ciò accade, dobbiamo aggiungere un extra (Log) per consentire i livelli (Log) di ricorsione.
Questo dà t (n) = (n logn), che è un tempo di esecuzione sorprendente per la moltiplicazione.
Trasformazione veloce di Fourier: non descriverò il trucco per ridurre il numero di
Moltiplicazioni ricorsive da D2 a solo 2D −1.Lascia che si verifichi dire che coinvolge
pensare al problema come alla valutazione e all'interpolazione dei polinomi.Quando d
diventa grande, sorgono altre complicazioni.Questi sono risolti usando le radici 2d th di
Unità su un campo concentrato.L'esecuzione delle operazioni su questo campo concentrato richiede (log logn)
tempo.Ciò aumenta il tempo totale da (n logn) a (n logn log logn).Questo algoritmo
viene utilizzato spesso per la moltiplicazione e molte altre applicazioni come l'elaborazione del segnale.
È indicato come trasformazione di Fourier veloce.

---
layout: 
title: Pagina 142
level: 3
---


Ricorsione
126
Esempio 9.2.3
Moltiplicazione della matrice di Strassen
Il prossimo problema è moltiplicare due matrici N × N.
L'algoritmo iterativo: l'ovvio algoritmo iterativo calcola il ⟨i, j⟩entry di
La matrice del prodotto moltiplicando la riga della prima matrice con la colonna JTH
del secondo.Ciò richiede (n) molteplicazioni scalari.Poiché ci sono N2 tali voci, il tempo totale è (N3).
L'algoritmo di divisione e conquista semplice: quando si progetta un algoritmo di divisione e conquista
ogni.Moltiplicarli simbolicamente dà quanto segue:

UN
B
C
D
 
e
G
F
H

=

ae + bf
Ag + BH
ce + df
CG + DH

Calcolo dei quattro N
2 × n
2 sottomissioni in questo prodotto in questo modo richiede una moltiplicazione in modo ricorsivo otto coppie di n
2 × n
2 matrici.Viene dato il tempo totale di calcolo
dalla relazione di ricorrenza t (n) = 8t (n/2) + (n2) = (n (log 8) (log 2)) = (n3).Questo è
Nessun più veloce dell'algoritmo iterativo standard.
Ridurre il numero di ricorsioni: Strassen ha trovato il modo di calcolare i quattro
N
2 × n
2 sottomissioni in questo prodotto utilizzando solo sette di queste chiamate ricorsive.Questo da
T (n) = 7t (n/2) + (n2) = (n (log 7) (log 2)) = (n2.8073).Non includerò i dettagli
dell'algoritmo.
Esercizio 9.2.1 (vedere la soluzione nella parte cinque) GCD ricorsivo.
1.
Scrivi un programma ricorsivo per trovare il GCD di due numeri.Il programma dovrebbe
Specchio l'algoritmo iterativo trovato nel capitolo 6.
2.
Riscrivi questo algoritmo ricorsivo per risolvere il seguente problema più generale.IL
L'input è ancora costituito da due numeri interi a e b.L'output è costituito da tre numeri interi G, U e V, tale che UA + VB = G = GCD (A, B).Ad esempio, su a = 25 e
B = 15 Le uscite dell'algoritmo ⟨5, 2, −3⟩, perché 2 × 25 −3 × 15 = 50 −45 = 5 =
GCD (25, 15).Fornire sia un paragrafo contenente la spiegazione dell'amico del
algoritmo e codice ricorsivo.
3.
Scrivi un algoritmo per il seguente problema.L'input è costituito da tre tentese, b e w.Supponiamo che tu viva in un paese che ha due tipi di monete, un valore
A dollari e gli altri dollari B.Sia tu che il magazzino avete una tasca piena di
ogni.Devi pagargli dollari W.Puoi dargli un numero qualsiasi di monete e lui
Può darti un cambiamento con qualsiasi numero di monete.Il tuo algoritmo deve determinare
Se questo è possibile o meno e, in tal caso, descrivi un modo per farlo (non necessariamente il modo ottimale).[Suggerimento: calcola GCD (A, B) e usa i tre valori G, U e V. Considera i due casi in cui G si divide W e quando non lo fa.(Se vuoi
Per trovare il numero ottimale di monete, fondamentalmente si cambia una soluzione usando il
fatto che (b
g) · a - (a
g) · b = 0.)]
4.
Progettazione di un algoritmo che, se somministrato un primo p e un numero intero x ∈ [1, p −1], emette uno inverso y tale che x · y ≡mod p 1. [Suggerimento: prima mostra quel gcd (p, x) =1.

---
layout: 
title: Pagina 143
level: 3
---


Alcuni semplici esempi di algoritmi ricorsivi
127
Quindi calcolare GCD (p, x) e utilizzare i valoriu ev.Dimostrando che ogni x ha tale
un inverso dimostra che i numeri interi modulo sono un campo un campo.]
9.3
La funzione di Ackermann
Se ti stai chiedendo quanto sia lentamente eseguito un programma, considera l'algoritmo qui sotto.Supponiamo che i parametri di input N e K siano numeri naturali.
Algoritmo:
Algoritmo A (k, n)
if (k = 0) quindi
restituzione (n +1 + 1)
altro
if (n = 0) quindi
if (k = 1) allora
restituzione (0)
altro
Ritorno (1)
altro
restituzione (a (k −1, a (k, n −1))
finisci se
finisci se
Algoritmo di fine
Relazione di ricorrenza: TK (N) indica il valore restituito da A (K, N).Questo da
T0 (N) = 2 + N, T1 (0) = 0, TK (0) = 1 per K ≥2 e TK (N) = TK - 1 (TK (N −1)) per K> 0 e
N> 0.
Risoluzione:
T0 (n) = 2 + n
T1 (N) = T0 (T1 (n −1)) = 2 + T1 (n −1) = 4 + T1 (n −2)
= 2i + t1 (n −i) = 2n + t1 (0) = 2n
T2 (N) = T1 (T2 (n −1)) = 2 · T2 (n −1) = 22 · T2 (n −2) = 2i · T2 (n −i) = 2n · T2 (0) = 2n
T3 (N) = T2 (T3 (N −1)) = 2T3 (n - 1) = 22T3 (n - 2) =
⎡
⎣222 ... 2
 

io
⎤
⎦
T3 (n -i)
=
⎡
⎣222 ... 2
 

N
⎤
⎦
T3 (0)
= 222 ... 2


N
T4 (0) = 1. T4 (1) = T3 (T4 (0)) = T3 (1) = 222 ... 2


1
= 2.
T4 (2) = T3 (T4 (1)) = T3 (2) = 222 ... 2


2
= 22 = 4.

---
layout: 
title: Pagina 144
level: 3
---


Ricorsione
128
T4 (3) = T3 (T4 (2)) = T3 (4) = 222 ... 2


4
= 2222
= 224 = 216 = 65, 536.
Notare che
222 ... 2


5
= 265.536 ≈1021.706
mentre il numero di atomi nell'universo è inferiore a 10100. Abbiamo
T4 (4) = T3 (T4 (3)) = T3 (65, 536) = 222 ... 2


65.536
La funzione di Ackermann è definita come A (n) = T
n (n).Vediamo che un (4) è più grande di
Qualsiasi numero nel mondo naturale.A (5) è inimmaginabile.
Tempo di esecuzione: l'unico modo in cui il programma crea un numero elevato è incrementandolo continuamente di uno.Quindi, il numero di volte in cui si aggiunge è almeno come
Enorme come il valore TK (N) è tornato.
Crashing: i programmi possono fermarsi in fase di esecuzione a causa di (1) eccesso di flusso in un valore intero;
(2) esaurire la memoria;(3) Scorendo il tempo.È probabile che accada prima?
Se i numeri interi della macchina sono di 32 bit, possiedono un valore che è di circa 1010. L'incremento fino a questo valore richiederà molto tempo.Tuttavia, molto peggio di così, ciascuno
Due incrementi hanno bisogno di un'altra chiamata ricorsiva che crei una pila di questi cornici ricorsive.La macchina è destinata a esaurire la prima memoria.
Esercizio 9.3.1 Progettare l'algoritmo e calcolare il tempo di esecuzione quando d = 3.
9.4
Esercizi
Esercizio 9.4.1
Rivedere il problema del taglio della torta iterativa (Sezione 2.3).Sei
Ora per scrivere un algoritmo ricorsivo per lo stesso problema.Naturalmente, dovrai farlo
Rendi le pre e le postcondizioni più generali in modo che quando ti ricorso, le tue sottoinstanze soddisfino le precondizioni.Come nel passare dall'ordinamento di inserzione per unire l'ordinamento, tu
È necessario rendere l'algoritmo più veloce tagliando il problema a metà.
1.
Dovrai generalizzare il problema in modo che la sottoinstabilità desideri
Il tuo amico da risolvere è un'istanza legale secondo i precondizioni e così
Le postcondizioni indicano il compito che vorresti che risolvesse.Rendi il nuovo problema, tuttavia, naturale.Ad esempio, non passare il numero N di giocatori nel
problema originale o livello di ricorsione.L'input dovrebbe essere semplicemente un set di giocatori e un sottointervallo di torta.La postcondizionalità dovrebbe dichiarare i requisiti
Come questo sottointervallo deve essere diviso tra questi giocatori.Per fare il problema
Più facile, supponiamo che il numero di giocatori sia n = 2i per un numero intero i.
2.
Dare pseudocodice ricorsivo per questo algoritmo.Come grande suggerimento, verso la progettazione di un
Algoritmo ricorsivo, ti dirò le prime cose che fa l'algoritmo.Ogni

---
layout: 
title: Pagina 145
level: 3
---


Alcuni semplici esempi di algoritmi ricorsivi
129
Il giocatore specifica dove avrebbe tagliato se dovesse tagliare la torta a metà.Quindi uno di
Questi punti sono scelti.Devi decidere quale e come creare due sottoinstanze da questo.
3.
Dimostra che se la tua istanza soddisfa i preconoscerti, allora le tue due sottoinstanti
Incontra anche i precondizioni.
4.
Dimostra che se le soluzioni del tuo amico incontrano i postcondizioni, allora la tua soluzione
incontra la postcondizionamento.
5.
Dimostra che la tua soluzione per il caso di base soddisfa i postcondizioni.
6.
Dare e risolvere la relazione di ricorrenza per il tempo di esecuzione di questo algoritmo.
7.
Supponiamo ora che N non sia 2i per nessun integeri.Come dovremmo cambiare l'algoritmo
in modo che gestisca il caso quando n è strano?Ho due soluzioni: una che modifica
l'algoritmo ricorsivo direttamente e uno che combina l'algoritmo iterativo e
L'algoritmo ricorsivo.Devi solo fare uno dei due (purché funzioni e
non aumenta il bigoh del tempo di esecuzione.)

---
layout: 
title: Pagina 146
level: 3
---


130
10 ricorsione sugli alberi
Un'applicazione chiave di algoritmi ricorsivi è eseguire azioni sugli alberi, perché
Gli stessi alberi hanno una definizione ricorsiva.La terminologia per gli alberi è riassunta in
La tabella seguente:
Termine
Definizione
Radice
Nodo in alto
Rootinfo (albero)
Le informazioni memorizzate sul nodo radice
Figlio del nodo u
Uno dei nodi appena sotto il nodo u
Genitore del nodo u
Il nodo univoco immediatamente sopra il nodo u
Fratelli
Nodi con lo stesso genitore
Antenati del nodo u
I nodi sul percorso univoco dalla radice al nodo u
Discendenti del nodo u
Tutti i nodi sotto il nodo u
Foglia
Un nodo senza figli
Altezza dell'albero
Il livello massimo.Alcune definizioni dicono che un albero con a
Il nodo singolo ha altezza 0, altri dicono l'altezza 1. Dipende da
Sia che si conti nodi o bordi.
Profondità del nodo u
Il numero di nodi (o bordi) sul percorso dalla radice
a te.
Albero binario
Ogni nodo ha al massimo due bambini.Ognuno di questi è
designato come il bambino destro o il bambino sinistro.
LeftSub (albero)
Sottostruttura sinistra della radice
di Rightsub (albero)
Sottostruttura destra della radice
Definizione ricorsiva dell'albero: un albero è nemmeno:
r un albero vuoto (zero nodi) o
r un nodo radicale con alcuni sottostrutimenti da bambini.
Un albero binario è un tipo speciale di albero in cui ogni nodo ha una destra e una sinistra
sottosuolo.

---
layout: 
title: Pagina 147
level: 3
---


Ricorsione sugli alberi
131
z
y
X
+
\*
Albero che rappresenta (x + y) \* z
Albero binario
Esempio 10.1
Numero di nodi in un albero binario
Ora svilupperemo un algoritmo ricorsivo che calcolerà il numero di nodi in a
albero binario.
Specifiche:
Precondizioni: l'input è qualsiasi albero binario.Gli alberi con una sottostruttura vuota sono validi
alberi.Così sono gli alberi costituiti da un singolo nodo e sull'albero vuoto.
Postconditions: l'output è il numero di nodi nell'albero.
Dimensione: la dimensione di un'istanza è il numero di nodi in essa.
Input generale: considera un grande albero binario con due sottostrutimenti completi.
Magia: supponiamo che per magia un amico sia in grado di contare i nodi in qualsiasi albero
Questo è strettamente più piccolo del nostro.
Substanze: le sottoinstanze del nostro albero di istanza saranno la sinistra dell'albero e la sua
Sottosolino destro.Questi sono casi validi che sono strettamente più piccoli delle nostre perché
La radice (e l'altra sottostruttura) sono state rimosse.
Sovvenuti: chiediamo a un amico di contare in modo ricorsivo il numero di nodi in
Sinistra e un altro amico per farlo nella sottostruttura destra.
Soluzione: il numero di nodi nel nostro albero è il numero nella sua sottostruttura sinistra
Il numero nel suo sotto -difensore destro più uno per la radice.
Altre istanze: supponiamo che l'istanza sia un albero con la sottostruttura giusta mancante.Sorprendentemente, l'algoritmo funziona ancora.Il numero di nodi nella sottostruttura destra del nostro albero è zero.
Questa è la risposta che il nostro amico tornerà.Quindi, l'algoritmo restituisce il numero
nella sottostruttura sinistra più zero più uno per la radice.Questa è la risposta corretta.Allo stesso modo, l'algoritmo funziona quando la sottostruttura sinistra è vuota o quando l'istanza è composta da a
nodo a foglia singola.
L'istanza rimanente è l'albero vuoto.L'algoritmo non funziona in questo
Caso, perché non ha un sottosquadro.Quindi, l'algoritmo può gestire tutti gli alberi
Tranne l'albero vuoto con un pezzo di codice.

---
layout: 
title: Pagina 148
level: 3
---


Ricorsione
132
Esempio 10.1
Numero di nodi in un albero binario (cont.)
Casi di base: l'albero vuoto è sufficientemente piccolo che possiamo risolverlo in una forza bruta
modo.Il numero di nodi in esso è zero.
L'albero delle cornici dello stack: c'è un telaio di stack ricorsivo per ogni nodo nel
L'albero e l'albero delle cornici dello stack rispecchia direttamente la struttura dell'albero.
Tempo di esecuzione: perché c'è un telaio di stack ricorsivo per ogni nodo nell'albero
e ogni frame stack fa una quantità costante di lavoro, il tempo totale è lineare nel
Numero di nodi nell'albero di input, cioè t (n) = (n).Si è dimostrato in altro modo, la relazione di ricorrenza è t (n) = t (nleft) + t (nright) + (1).Collegamento di Ipotesi t (n) = cn dà
cn = cnleft + cnright + (1), che è corretto perché n = nleft + nright + 1.
Codice:
Algoritmo NumberNodes (Tree)
⟨Pre-Cond⟩: L'albero è un albero binario.
⟨Post-Cond⟩: restituisce il numero di nodi nell'albero.
inizio
if (albero = vuoto) quindi
risultato (0)
altro
Risultato (NumberNodes (sinistra (albero))
+ NumberNodes (Rightsub (Tree)) + 1)
finisci se
Algoritmo di fine
Abbiamo assicurato che l'algoritmo sviluppato funzioni per ogni istanza di input valida.
Problema con il caso di base a nodo singolo: molte persone sono tentate di usare gli alberi
con un singolo nodo come caso di base.Un piccolo problema con questo è che significa che
La routine non funziona più per l'albero vuoto, cioè l'albero con zero nodi.Un più grande
Il problema è che la routine non funziona più per gli alberi che contengono un nodo con una sinistra
bambino ma nessun bambino giusto, o viceversa.Questo albero non è un caso di base, perché ha di più
di un nodo.Tuttavia, quando la routine si ripresenta sulla sottostruttura destra, il nuovo
La subinstance è costituita dall'albero vuoto.La routine, tuttavia, non funziona più per
questo albero.Vedi ESERCIZIO 10.2.1 per ulteriori informazioni su questo.
Risposta per l'albero vuoto: un errore comune è fornire la risposta sbagliata
per l'albero vuoto.In caso di dubbi su quale risposta dovrebbe essere data per il vuoto
albero, considera un'istanza con la sottostruttura sinistra o destra vuota.Che risposta hai
Hai bisogno di ricevere dall'albero vuoto per rendere corretta la risposta di questo albero?
Altezza: ad esempio, un albero con un nodo può essere definito per avere altezza
0 o altezza 1. È la tua scelta.Tuttavia, se dici che ha altezza 0, allora sii
Attento quando si definisce l'altezza dell'albero vuoto.

---
layout: 
title: Pagina 149
level: 3
---


Ricorsione sugli alberi
133
Definizione dell'albero di ricerca binaria: un altro esempio è che le persone lo dicono spesso
L'albero vuoto non è un albero di ricerca binaria (Sezione 3.1).Tuttavia, lo è.Un binario
L'albero non è un albero di ricerca binaria quando alcune relazioni tra i nodi
esistere.Perché l'albero vuoto non ha nodi, nessuna di queste condizioni violate
esistere.Quindi, per impostazione predefinita, è un albero di ricerca binario.
Max: qual è il valore massimo all'interno di un elenco vuoto di valori?Si potrebbe pensare
0 o ∞.Tuttavia, una risposta migliore è −∞.Quando si aggiunge un nuovo valore, si utilizza il
Codice newMax = max (oldmax, newValue).A partire da oldmax = −∞gives
Risposta corretta quando viene aggiunto il primo valore.
10.1
Attraversi degli alberi
Un compito che si deve essere in grado di eseguire su un albero binario è per attraversarlo, visitando ciascuno
nodo una volta, in uno dei tre ordini definiti.Prima che si acquisisce familiarità con i programmi ricorsivi, si tende a pensare al calcolo iterativamente: “Visito questo nodo
Prima, quindi questo, poi questo, e così via. "Ogni iterazione, il programma dice "Io solo
Ho visitato questo nodo, quindi ora lasciami trovare il nodo successivo da visitare. "Sorprendentemente, un tale calcolo è difficile da codificare.Il motivo è che gli alberi binari per loro stessa natura hanno a
struttura ricorsiva.Alla fine di questa sezione, includo il codice che attraversa un binario
albero in modo iterativo, ma solo per convincerti che è molto più difficile che fare
È ricorsivo e dovrebbe essere evitato.
La ricorsione, d'altra parte, fornisce un algoritmo molto semplice e liscio
attraversando un albero binario.Tale albero è composto da tre parti.C'è la radice
Node, la sua sottostruttura sinistra e la sua sottostruttura destra.Tu, essendo pigro, fai attraversare un amico
la sinistra e l'altro per attraversare la destra.Tu, sentendo che hai bisogno di fare un po '
Lavora da solo, visita la radice.L'ordine in cui e tre preformate le tue attività
Detta l'ordine in cui i nodi vengono visitati.I tre ordini classici di visitare il
I nodi di un albero binario sono prefissi, in ﬁ x e post ﬁ x, in cui viene visitata la radice prima, tra o dopo le sue sottoscherini sinistro e destro.
algoritmo prefisso (albero))
⟨Pre-Cond⟩: L'albero è un albero binario.
⟨Post-Cond⟩: visita i nodi
in ordine prefisso.
inizio
if (albero ̸ = vuoto) quindi
metti rootinfo (albero)
Prefisso (sinistra (albero))
Prefisso (dirittib (albero))
finisci se
Algoritmo di fine
algoritmo infix (albero))
⟨Pre-Cond⟩: L'albero è un albero binario.
⟨Post-Cond⟩: visita i nodi
nell'ordine in ﬁ x.
inizio
if (albero ̸ = vuoto) quindi
Infix (sinistra (albero))
metti rootinfo (albero)
Infix (di Rightsub (albero))
finisci se
Algoritmo di fine

---
layout: 
title: Pagina 150
level: 3
---


Ricorsione
134
Algoritmo postfix (albero))
⟨Pre-Cond⟩: L'albero è un albero binario.
⟨Post-Cond⟩: visita i nodi
nell'ordine post -ﬁ x.
inizio
if (albero ̸ = vuoto) quindi
Postfix (sinistra (albero))
Postfix (Rightsub (albero))
metti rootinfo (albero)
finisci se
Algoritmo di fine
Il seguente ordine viene prodotto se si traccia questi calcoli sui due
alberi visualizzati di seguito:
Prefisso
Infisso
Postfix
5 3 1 2 4 6
1 2 3 4 5 6
2 1 4 3 6 5
\* + 3 4 7
3 + 4 \* 7
3 4 + 7 \*
6
4
2
1
3
5
7
4
3
+
\*
Questi tre ordini hanno applicazioni diverse.In matematica l'ordine tipico di mettere gli operatori è in notazione in ﬁ x come in 3 + 4 ∗ 7.Tuttavia, stampato in questo modo produce il sbagliato
ordine delle operazioni.Ciò che è richiesto è (3 + 4) ∗ 7.Usando l'ordine pre e post ﬁ x, il
La precedenza degli operatori è determinata correttamente anche senza parentesi.Per questo
Motivo, la prima calcolatrice di Hewlett Packard ha usato le notazioni post ﬁ x 3 4 + 7 ∗.Era chiamato
Notazione polacca inversa dopo Jan L
Ukasiewicz, che lo ha sviluppato negli anni '20.Questi
sono stati un po 'un dolore, ma per fortuna per me la tecnologia è migliorata abbastanza al momento
Stavo iniziando il liceo nel 1977, quindi non avevo bisogno di usarne uno.Tuttavia, tale
I calcolatori hanno ancora i loro partigiani e Hewlett Packard li rende ancora.
Il prefisso visita i nodi nello stesso ordine in cui una ricerca di profondità trova i nodi.
Vedere la sezione 14.4 per l'algoritmo iterativo per fare la prima ricerca di un grafico più generale e la sezione 14.5 per la versione ricorsiva dell'algoritmo.
Di seguito è riportato il programma iterativo per visitare i nodi in ordine in ﬁ x.Come detto, lo è
Inutilmente complesso ed è incluso solo per mostrarti cosa evitare.
algoritmo iterativetraversal (albero)
⟨Pre-Cond⟩: L'albero è un albero binario.Come al solito, ogni nodo ha un valore e puntatori al
radici delle sue sottostrutture sinistro e destro.Inoltre, ogni nodo ha un puntatore al suo genitore.
⟨Post-Cond⟩: fa un attraversamento in ﬁ x dell'albero.

---
layout: 
title: Pagina 151
level: 3
---


Ricorsione sugli alberi
135
inizio
elemento = root (albero)
% Nodo corrente in attraversamento
count = zero
% Conteggio corrente dei nodi
ciclo continuo
⟨Loop-invariant⟩: l'elemento è un nodo nell'albero e alcuni nodi
sono stati visitati.
Se (l'elemento ha un bambino sinistro e non è stato visitato) allora
elemento = leftchild (elemento)
Elseif (Element non ha un bambino di sinistra o il suo bambino sinistro è stato visitato
e l'elemento non è stato visitato) allora
Visita l'elemento
Elseif (il sottocre e l'elemento sinistro di Element sono stati visitati
e l'elemento ha un bambino giusto e non è stato visitato) allora
Element = RightChild (elemento)
Elseif (la sottostruttura sinistra, l'elemento stesso e la sottostruttura di Element sono stati
visitato ed elemento ha un genitore) quindi
elemento = genitore (elemento)
altrimenti (tutto è stato visitato e l'elemento è la radice del globale
albero) quindi
Uscita
finisci se
End Loop
Algoritmo di fine
10.2
Esempi semplici
Ecco un elenco di problemi che coinvolgono alberi binari.
1.
Restituisce il massimo dei campi di dati dei nodi.
2.
Restituire l'altezza dell'albero.
3.
Restituisce il numero di foglie nell'albero.(Uno più difficile.)
4.
Copia l'albero.
Provali prima da soli.Vedi Figura 10.1.
4
2
5
2
1
2
2
1
1
0
0
1
1
2
1
1
0
0
1
3
Il numero di foglie
Φ
Φ
Φ
0



5
Massimo
Φ
Φ
Φ
3
2
4
1
2
5
Altezza
3
Φ
Φ
Φ
0
-
-
-
Figura 10.1: Viene fornito il risultato restituito su ciascuna sottostruttura.

---
layout: 
title: Pagina 152
level: 3
---


Ricorsione
136
Massimo: dato un albero binario, il tuo compito è determinarne il valore massimo.IL
Il primo passo è decidere come creare sottoinstanze per i tuoi amici.Come detto, quando il
L'istanza di input è un albero binario, le sottoinstanze più naturali sono la sua sinistra e destra
Sottosolino.I tuoi amici devono risolvere lo stesso problema che fai.Quindi, supponiamo che
Ti forniscono il valore massimo all'interno di ciascuno di questi alberi.Fortunatamente, il
Il valore massimo all'interno di un albero è il massimo a sinistra, il massimo
il diritto o il valore nella radice.Il nostro unico compito è quindi determinare quale di questi
Tre è il massimo.Come descritto all'inizio del capitolo 10, il massimo di
L'elenco vuoto è −∞.
Algoritmo Max (albero)
⟨Pre-Cond⟩: L'albero è un albero binario.
⟨Post-Cond⟩: restituisce il massimo dei campi di dati dei nodi.
inizio
if (albero = vuoto) quindi
risultato (−∞)
altro
Risultato (max (max (sinistra (albero)), max (dirittib (albero)), rootdata (albero)))
finisci se
Algoritmo di fine
Altezza: in questo problema, il tuo compito è per trovare l'altezza del tuo albero binario.Ancora una volta, i tuoi amici possono facilmente darti l'altezza dei sottospere sinistra e destra.L'altezza
del tuo albero è determinato dal più profondo dei suoi sottocre.Date le loro altezze, si determina quale è più profonda e ne aggiungi uno per tenere conto della radice.L'altezza del
L'albero vuoto è discusso all'inizio di questo capitolo.
algoritmo altezza (albero)
⟨Pre-Cond⟩: L'albero è un albero binario.
⟨Post-Cond⟩: restituisce l'altezza dell'albero misurata in nodi, ad esempio un albero con
Un nodo ha altezza 1.
inizio
if (albero = vuoto) quindi
risultato (0)
altro
Risultato (max (altezza (sinistra (albero)), altezza (dirittib (albero)) + 1)
finisci se
Algoritmo di fine
Esercizio 10.2.3 considera un'altra versione di questo algoritmo.
Numero di foglie: questo problema è più difficile di quelli precedenti.Iniziamo considerando un albero con entrambi una sottostruttura a destra sinistra.Per questo, il numero di foglie in
L'intero albero è la somma dei numeri nei sottospere sinistra e destra.Se l'albero

---
layout: 
title: Pagina 153
level: 3
---


Ricorsione sugli alberi
137
Ha una sottostruttura, ma l'altra è vuota, quindi questo stesso algoritmo funziona ancora.Se la
L'albero è vuoto, quindi ha zero foglie.Tuttavia, se questo fosse tutto il codice, allora
La risposta restituita sarebbe sempre zero.Il caso che deve ancora essere considerato è l'albero costituito da una radice senza figli.Questa radice è una foglia.Abbiamo bisogno di
contalo.
Algoritmo NumberLeaves (albero)
⟨Pre-Cond⟩: L'albero è un albero binario.
⟨Post-Cond⟩: restituisce il numero di foglie nell'albero.
inizio
if (albero = vuoto) quindi
risultato (0)
altrimenti if (leftSub (albero) = EmptyTree e Rightsub (Tree) = EmptyTree) quindi
risultato (1)
altro
Risultato (NumberLeaves (LeftSub (Tree)) + NumberLeaves (Rightsub (Tree)))
finisci se
Algoritmo di fine
Copia albero: se si desidera creare una copia di un albero, potresti essere tentato di usare il
Codice treecopia = albero.Tuttavia, l'effetto di questo sarà solo che entrambe le variabili
La treecopia e l'albero si riferiscono alla stessa struttura dei dati dell'albero che l'albero ha originariamente fatto.Questo
Sarebbe sufficiente se si desidera solo avere accesso a lettura alla struttura dei dati da
entrambe le variabili.Tuttavia, se si desidera modificare una delle copie, allora hai bisogno di un
copia completamente separata.Per ottenere questo, la routine di copia deve allocare la memoria
Per ciascuno dei nodi nell'albero, copiare le informazioni in ciascun nodo e collegare
i nodi insieme nel modo appropriato.Il seguente semplice algoritmo ricorsivo, Treecopy = copy (albero), realizza questo.
Copia dell'algoritmo (albero)
⟨Pre-Cond⟩: L'albero è un albero binario.
⟨Post-Cond⟩: restituisce una copia dell'albero.
inizio
if (albero = vuoto) quindi
Risultato (EmptyTree)
altro
Treecopy = alloca memoria per un nodo
rootInfo (treecopy) = rootInfo (albero)
% Copia dati complessivi nel nodo root
LeftSub (treecopy) = copia (sinistra (albero))
% Copia sottocampi a sinistra
RightsUB (TreEcopy) = copy (Rightsub (Tree))
% Copia sottostruttura destra
risultato (treecopia)
finisci se
Algoritmo di fine

---
layout: 
title: Pagina 154
level: 3
---


Ricorsione
138
Esercizio 10.2.1 Molti testi che presentano algoritmi ricorsivi per gli alberi non considerano l'albero vuoto come un'istanza di input valida, ma non considerando gli alberi vuoti
L'algoritmo richiede molti più casi.Riprogetta l'algoritmo dell'esempio 10.1 per tornare
Il numero di nodi nell'albero di input senza considerare l'albero vuoto.
Esercizio 10.2.2 Sviluppare un algoritmo che restituisce la somma dei valori all'interno del
nodi di un albero binario.
Esercizio 10.2.3
Abbiamo dato un algoritmo ricorsivo per trovare l'altezza di a
albero binario misurato in nodi, ad esempio un albero con un nodo ha altezza 1. Riscrivi questo
algoritmo in modo che l'altezza sia misurata nei bordi, ad esempio un albero con un nodo
Altezza 0.
Esercizio 10.2.4 Se il sistema informatico non ha una raccolta di immondizia, allora lo è
la responsabilità del programmatore di trattare la memoria utilizzata da tutti i nodi di
un albero quando l'albero viene scartato.Sviluppa un algoritmo ricorsivo, si depara (albero), quello
realizza questo.Quanta libertà c'è nell'ordine delle righe del codice?
Esercizio 10.2.5 Sviluppa un algoritmo che cerca una chiave all'interno di una ricerca binaria
albero.
10.3
Generalizzare il problema risolto
A volte quando si scrive un algoritmo ricorsivo per un problema, è più facile risolvere un
versione più generale del problema, fornendo maggiori informazioni sull'originale
istanza o chiedere ulteriori informazioni sulle sottoinstanze.Ricorda, tuttavia, che tutto ciò che chiedi al tuo amico di fare, devi essere in grado di fare da solo.
Esempio 10.3.1
L'albero è un albero di ricerca binaria?
L'algoritmo richiesto restituisce se l'albero dato è o meno un albero di ricerca binaria
(BST).
Un algoritmo inefficace:
Algoritmo Isbsttree (albero)
⟨Pre-Cond⟩: L'albero è un albero binario.
⟨Post-Cond⟩: l'output indica se si tratta di un albero di ricerca binario.
inizio
if (albero = vuoto) quindi
restituire sì
altrimenti se (isbsttree (sinistra (albero)) e isbsttree (dirittifub (albero))
e max (sinistra (albero)) ≤RootKey (albero) ≤Min (di Rightsub (albero))) quindi
restituire sì

---
layout: 
title: Pagina 155
level: 3
---


Ricorsione sugli alberi
139
altro
restituire n
finisci se
Algoritmo di fine
Tempo di esecuzione: per ciascun nodo nell'albero di input, l'algoritmo sopra calcola il
Valore minimo o massimo nei sottostrutimenti sinistra e destra del nodo.Anche se questi
Le operazioni sono relativamente veloci per gli alberi di ricerca binari, eseguendoli per ciascun nodo
aumenta la complessità del tempo dell'algoritmo, poiché ogni nodo può essere attraversato
dalla routine Min o Max molte volte.Supponiamo, ad esempio, che l'input
L'albero è completamente sbilanciato, cioè un singolo percorso.Per il nodo I, calcolando il massimo del suo
La sottostruttura comporta attraversare la parte inferiore del percorso e richiede tempo n -i.Quindi il
Il tempo di esecuzione totale è t (n) =
i = 1..n (n −i) = (n2).Questo è troppo lento.
Chiedi ulteriori informazioni sulla subinstance: è meglio combinare il
Isbsttree e le routine Min e Max in una routine in modo che l'albero abbia solo bisogno
da attraversare una volta.
Oltre al fatto che l'albero sia o meno un BST, la routine restituirà il valore minimo e il massimo nell'albero.Se il nostro albero di istanza è l'albero vuoto, allora
Restriamo che è un BST con valore minimo ∞ e con valore massimo −∞.(Vedere
Sezione 8.5.) Altrimenti, chiediamo a un amico della sottostruttura sinistra e di un altro circa
la destra.Ci dicono il minimo e i valori massimi di questi e se
Sono BST.Se entrambe le sottostrutture sono BST e sinistra ≤RootKey (albero) ≤Rightmin, allora
Il nostro albero è un BST.Il nostro valore minimo è min (leftmin, destra, rootkey (albero)) e
Il nostro valore massimo è max (sinistra, destra, rootkey (albero)).
Algoritmo Isbsttree (albero)
⟨Pre-Cond⟩: L'albero è un albero binario.
⟨Post-Cond⟩: l'output indica se si tratta di un BST.Dà anche il minimo
e i valori massimi nell'albero.
inizio
if (albero = vuoto) quindi
restituire ⟨yes, ∞, −∞⟩
altro
⟨Leftis, leftmin, leftmax⟩ = isbsttree (sinistra (albero))
⟨Rightis, Rightmin, RightMax⟩ = ISBsttree (Rightsub (Tree))
min = min (leftmin, destra, rootkey (albero))
max = max (sinistra, destra, rootkey (albero))
if (sinistra e destra e sinistra ≤rootkey (albero) ≤rightmin)
isbst = sì
altro
isbst = no

---
layout: 
title: Pagina 156
level: 3
---


Ricorsione
140
finisci se
restituire ⟨isbst, min, max⟩
finisci se
Algoritmo di fine
Potresti chiederti perché l'amico di sinistra fornisca anche il minimo della sottostruttura sinistra
sebbene non sia usato.Ci sono due motivi correlati.Innanzitutto, le postcondizioni le richiedono di farlo.Se lo desideri, puoi cambiare le postcondizioni, ma qualunque contratto sia stipulato, tutti devono mantenerlo.Secondo, l'amico di sinistra non lo sa
È l'amica di sinistra.Tutto quello che sa è che le viene dato un albero come input.Il designer dell'algoritmo non deve supporre che l'amico sappia qualcosa sul contesto
in cui sta risolvendo il suo problema diverso da quello che viene passata nell'input
esempio.
Fornire ulteriori informazioni sull'istanza originale: un altro elegante algoritmo per il problema ISBST generalizza il problema per fornire il tuo amico
Maggiori informazioni sulla tua sottoinstabilità.Qui il problema più generale, oltre all'albero, fornirà una gamma di valori [min, max] e chiederà se il
L'albero è un BST con valori all'interno di questo intervallo.Il problema originale viene risolto utilizzando
Isbsttree (albero, [−∞, ∞]).
Algoritmo Isbsttree

albero, [min, max]

⟨Pre-Cond⟩: L'albero è un albero binario.Inoltre, [min, max] è un intervallo di valori.
⟨Post-Cond⟩: l'output indica se è un BST con valori all'interno di questo
allineare.
inizio
if (albero = vuoto) quindi
restituire sì
altro se (
rootkey (albero) ∈ [min, max] e
Isbsttree (sinistra (albero), [min, rootkey (albero)]) e
ISBSTTREE (Rightsub (Tree), [Rootkey (Tree), Max]) quindi
restituire sì
altro
restituire n
finisci se
Algoritmo di fine
Esercizio 10.3.1 (vedi soluzione nella parte quinta.) Scrivi un programma ricorsivo che prende un
BST e un numero intero K come input e restituisce l'elemento più piccolo KTH nell'albero.Richiamare
che tutti i nodi nella sottostruttura sinistra sono più piccoli della radice e di tutti quelli a destra
sono più grandi.

---
layout: 
title: Pagina 157
level: 3
---


Ricorsione sugli alberi
141
memorizzato nell'elemento array A [3].
I contenuti di questo nodo sono
5
1
3
2
4
6
n = 9
7
9
8
1
2
3
4
5
6
7
8
9
Figura 10.2: la mappatura tra i nodi in un albero binario bilanciato e gli elementi di
un array.
10.4
Ordina heap e code prioritarie
HEAP Ord è un algoritmo di ordinamento rapido che è facile da implementare.Come Quick Ord, ha
Il vantaggio di essere fatto in atto in memoria, mentre si uniscono e radix
Gli ordini richiedono un array ausiliario di memoria per trasferire i dati.Includo heap
Ordina in questo capitolo perché è implementato utilizzando la ricorsione all'interno di un albero dati
struttura.
Albero binario completamente equilibrato: visualizzeremo i valori ordinati come
Conservato in un albero binario completamente bilanciato, cioè ogni livello dell'albero è completamente pieno tranne il livello inferiore, che viene riempito da sinistra.
Implementazione dell'array di un albero binario equilibrato: perché l'albero ha sempre
Questa forma equilibrata, non dobbiamo preoccuparci del sovraccarico di avere nodi con
puntatori.In realtà, i valori sono archiviati in un semplice array A [1, N].Vedi Figura 10.2.
La mappatura tra la struttura dell'albero visualizzato e la struttura dell'array effettiva è
Fatto indicizzando i nodi dell'albero 1, 2, 3 ,..., n, a partire dalla radice dell'albero
e riempire ogni livello da sinistra a destra.
r La radice è memorizzata in un [1].
r il genitore di un [i] è un [⌊i
2⌋].
r Il figlio sinistro di un [i] è un [2 · i].
r Il figlio giusto di un [i] è un [2 · i + 1].
r Il nodo all'estrema destra del livello inferiore viene memorizzato in un [n].
r Se 2i + 1> n, allora il nodo non ha un bambino giusto.
Definizione di un heap: un heap impone un ordine parziale (vedere la sezione 14.6) sul set
di valori, richiedendo che il valore di ciascun nodo sia maggiore o uguale a quello di ciascuno
dei figli del nodo.Non ci sono regole sul fatto che sia il bambino sinistro o destro
più grandi.Vedi Figura 10.3.

---
layout: 
title: Pagina 158
level: 3
---


Ricorsione
142
2
3
1
7
4
5
8
6
9
Figura 10.3: un esempio di nodi ordinati in un mucchio.
Massimo alla radice: un'implicazione delle regole di heap è che la radice contiene il
valore massimo.Il massimo può apparire ripetutamente anche in altri luoghi.
Esercizio 10.4.1 ti dà più pratica comprendendo questa definizione.
Il problema di heapify:
Specifiche:
PRESIDIZIONE: L'ingresso è un albero binario bilanciato in modo tale che la sua sinistra e la sua destra
Le sottostruttura sono un sacco.(Cioè, è un mucchio tranne per il fatto che la sua radice potrebbe non essere
più grande di quello dei suoi figli.)
Postcondition: i suoi valori sono riorganizzati in posizione per renderlo completo.
Algoritmo ricorsivo: il primo compito nel trasformare questo albero in un mucchio è mettere il suo
valore massimo nella radice.Vedi Figura 10.4.Perché i sottostrutici sinistra e destra
sono cumuli, i massimi di questi alberi sono alle loro radici.Quindi, il massimo
dell'intero albero è alla radice, al nodo figlio sinistro o al bambino destro
nodo.Hai trovato il massimo tra questi tre.Se il massimo è alla radice, allora sei finito.Altrimenti, ai fini della discussione, supponiamo che il
Il massimo è nel bambino sinistro della radice.Scambia questo valore massimo con quello del
radice.La radice e la sottostruttura destra ora formano un mucchio, ma la sottostruttura sinistra potrebbe
non.Darà la sottovalutazione di trasformare la tua sottostruttura sinistra in un mucchio di un amico ricorsivo.Prima di poterlo fare, devi assicurarti che questa subinstance
soddisfa le condizioni preliminari del problema.Con il nostro presupposto, la nostra sottostruttura sinistra
era un mucchio quando l'abbiamo ricevuto.Abbiamo cambiato la sua radice.Dopo questo cambiamento, lo ha ancora
La proprietà che i suoi sottostrutimenti sinistra e destra sono cumuli.Quindi, i precondizioni
del nostro problema sono soddisfatti e puoi dare la tua sottostruttura sinistra al tuo amico.Dal
Postcondition, l'amico trasforma questa sottostruttura in un mucchio.L'intero albero ora è un
mucchio.
2
9
6
8
5
3
2
3
1
7
4
6
8
9
5
8
5
9
6
2
3
1
7
4
4
7
1
Figura 10.4: un esempio di calcolo di heapify.

---
layout: 
title: Pagina 159
level: 3
---


Ricorsione sugli alberi
143
Codice:
Algoritm HeaPify (R)
⟨Pre-conf⟩: L'albero binario equilibrato radicato a una [r] è tale che la sua sinistra
e i sotto -diritti di destra sono un sacco.
⟨Post-Cond⟩: i suoi valori sono riorganizzati in posizione per renderlo completo
mucchio.
inizio
if (a [destrachild (r)] è massimo di {a [r], a [destro (r)], a [leftchild (r)]})
SWAP (A [R], A [RASTCHILD (R)])
HeaPify (destrimHcild (R))
elseif (a [leftchild (r)] è massimo di {a [r], a [destro (r)], a [leftchild (r)]}) quindi
SWAP (A [R], A [Leftchild (R)])
HeaPify (Leftchild (R))
else % a [r] è massimo di {a [r], a [destro (r)], a [leftchild (r)]}
Uscita
finisci se
Algoritmo di fine
Tempo di esecuzione: t (n) = 1 · t (n/2) + (1).Dal capitolo 27 sappiamo che loga
logb =
Log 1
log 2 = 0 e f (n) = (n0), quindi c = 0. perché loga
logb = c, concludiamo che il tempo è
dominato da tutti i livelli e t (n) = (f (n) logn) = (logn).
Poiché questo algoritmo si riprende solo una volta per chiamata, può essere facilmente trasformato in un algoritmo iterativo.
Algoritmo iterativo: un buon ciclo invariante sarebbe “L'intero albero è un mucchio
Tranne il fatto che Nodei potrebbe non essere maggiore o uguale a entrambi i suoi figli.Anche il
Il valore del genitore di I è almeno il valore di I e dei figli di I. "Quando sono la radice, questa è la condizione preliminare.L'algoritmo procede come nell'algoritmo ricorsivo.
Nodo I segue un percorso lungo l'albero verso una foglia.Quando sono una foglia, l'intero albero è
un mucchio.
Codice:
Algoritm HeaPify (R)
⟨Pre-conf⟩: L'albero binario equilibrato radicato a una [r] è tale che la sua sinistra
e i sotto -diritti di destra sono un sacco.
⟨Post-Cond⟩: i suoi valori sono riorganizzati in posizione per renderlo completo
mucchio.
inizio
i = r
ciclo continuo

---
layout: 
title: Pagina 160
level: 3
---


Ricorsione
144
⟨Loop-invariant⟩: l'intero albero radicato in un [r] è un mucchio tranne
Quel nodo potrei non essere maggiore o uguale a entrambi i suoi figli.
Inoltre, il valore del genitore di I è almeno il valore di io e di io
bambini.
uscita quando sono una foglia
if (a [giuridtchild (i)] è massimo di {a [i], a [destro (i)],)
A [Leftchild (i)]} quindi
scambia (a [i], a [destro (i)])
i = destrachild (i)
elseif (a [LeftChild (i)] è massimo di {a [i], a [destro (i)], a [leftchild (i)]}) quindi
scambia (a [i], a [leftchild (i)])
i = Leftchild (i)
else % a [i] è massimo di {a [i], a [destro (i)], a [leftchild (i)]}
Uscita
finisci se
End Loop
Algoritmo di fine
Tempo di esecuzione: t (n) = (altezza dell'albero) = (log).
Il problema di MakeHeap:
Specifiche:
Precondizionismo: l'input è un array di numeri, che può essere visto come a
albero binario bilanciato dei numeri.
PostCondition: i suoi valori sono riorganizzati in posizione per renderlo un mucchio.
Algoritmo ricorsivo: l'ovvio algoritmo ricorsivo è fare ricorsivamente
⌈N - 1
2 ⌉ dei numeri in un heap, fai un altro ⌊n - 1
2 ⌋into un mucchio e metti il
Numero rimanente alla radice di un albero con questi due cumuli da bambini.Questo ora
Incontra il presupposto di HeaPify, che trasforma il tutto in un mucchio.
Tempo di esecuzione: t (n) = 2t (n
2) + (logn).Di nuovo dal capitolo 27, Loga
logb =
Log 2
log 2 = 1 e f (n) = (n0 logn), quindi c = 0. perché loga
logb> c, lo concluiamo
Il tempo è dominato i casi di base e t (n) = (nloga/logb) = (n).
La struttura dell'albero ricorsivo per questo algoritmo è molto prevedibile, quindi può essere facilmente trasformata in un algoritmo iterativo, che chiama accumulare esattamente sugli stessi nodi
sebbene in un ordine leggermente diverso.
Algoritmo iterativo: vedi Figura 10.5.L'anello invariante è che tutti i sottostrutici di
altezza sono un sacco.Inizialmente, le foglie di altezza i = 1 sono già cumuli.Supponiamo che tutti i sottosuolo di altezza che io siano un sacco.Le sottostrutture di altezza i + 1 hanno il

---
layout: 
title: Pagina 161
level: 3
---


Ricorsione sugli alberi
145
7
4
5
8
6
9
2
5
1
7
4
6
8
9
3
Accumulare
Accumulare
1
2
3
3
6
1
9
4
5
2
7
8
3
6
1
9
5
Accumulare
2
4
7
8
Accumulare
6
8
9
5
3
2
7
1
4
Figura 10.5: un esempio della versione iterativa di MakeHeap.
Proprietà che i loro sottostrutimenti sinistra e destra sono cumuli.Quindi, possiamo usare Heapify
per trasformarli in cumuli.Questo mantiene l'invariante invariante mentre aumenta io
da uno.La postcondition segue chiaramente dall'andata invariante e dall'uscita
condizione che i = logn.
Codice:
Algoritmo MakeHeap ()
⟨Pre-Cond⟩: l'input è un array di numeri, che può essere visto come a
albero binario bilanciato dei numeri.
⟨Post-Cond⟩: i suoi valori sono riorganizzati in posizione per renderlo un mucchio.
inizio
Loop k = ⌊n
2 ⌋, ⌊n
2 ⌋ - 1, ⌊n
2 ⌋ - 2 ,..., 2, 1
Heapify (k)
End Loop
Algoritmo di fine
Tempo di esecuzione: il numero di sottostrutimenti di alti è 2 (log) −i, perché ciascuno di questi
L'albero ha la sua radice a livello (logn) −i nell'albero.Ogni prendendo (i) per accumulare.Questo da
un tempo totale di t (n) = logn
i = 1 (2 (logn) −i) i.Questa somma è geometrica.Quindi, il suo totale è
Theta del suo termine massimo.Il primo termine con i = 1 è (2 (logn) −i) i = (2logn) =
(n).L'ultimo termine con i = logn è (2 (logn) −i) i = (20) logn = logn.Il primo termine
è il più grande, dando un tempo totale di (n).Vedi il capitolo 26 per ulteriori informazioni sulle sommazioni di approssimazione.
Il problema del heapsort:
Specifiche:
Precondizionismo: l'input è un array di numeri.
Postcondition: i suoi valori sono riorganizzati in posizione per essere ordinati.
Algoritmo: l'invariante invariante è che per alcuni i ∈ [0, n], gli elementi più grandi N -I sono stati rimossi e ordinati sul lato e gli elementi i rimanenti formano un mucchio.Vedi le figure 10.6 e 10.7.È stabilito l'invariante in loop
Per i = n formando un heap dai numeri usando l'algoritmo MakeHEAP.
Quando i = 0, i valori sono ordinati.
Supponiamo che il ciclo invariante sia vero per i.Il massimo dei restanti
I valori sono alla radice del heap.Rimuoverlo e mettilo nel suo posto ordinato a sinistra

---
layout: 
title: Pagina 162
level: 3
---


Ricorsione
146
3
2
1
9
8
7
9
5
6
2
12
8
9
5
2
23
31
35
57
1
2
3
4
5
1
2
3
4
5
6
7
8
9
1
2
3
7
6
5
4
9
8
8
9
4
5
6
7
23
8
12
2
5
9
8
12
57
35
31
57
35
31
23
Figura 10.6: Il diagramma sinistro mostra l'invariante invariante con n −i = 9 −5 = 4 del più grande
Elementi nell'array e i restanti I = 5 elementi che formano un mucchio.Il diagramma giusto
sottolinea il fatto che sebbene un heap sia visto come immagazzinato in un albero, in realtà lo è
implementato in un array.Quando alcuni degli elementi sono ancora nell'albero e alcuni sono nel
Array, queste viste si sovrappongono.
fine dell'elenco ordinato.Prendi l'elemento in basso a destra del heap e infila
Il buco appena creato alla radice.Questo mantiene la forma corretta dell'albero.
L'albero ora ha la proprietà che i suoi sottostrutimenti sinistra e destra sono cumuli.Pertanto, puoi usare un mucchio per trasformarlo in un mucchio.Questo mantiene l'invariante in loop
pur diminuendo I di uno.
Implementazione dell'array: l'ordinamento HEAP può verificarsi in posizione all'interno dell'array.Come il
Heap si riduce, le voci dell'array a destra diventano vuote.Questi possono essere
Utilizzato per archiviare l'elenco ordinato che si trova sul lato.Mettendo l'elemento radice dove è
9
2
6
8
5
4
7
1
3
9
8
1
2
4
5
3
6
7
3
1
2
6
7
8
9
4
5
3
9
1
8
6
7
5
4
2
1
Accumulare
Accumulare
Accumulare
9
8
7
6
5
1
3
4
2
Accumulare
2
9
8
7
6
5
4
3
Accumulare
5
8
6
9
2
5
8
7
4
9
1
6
3
Buildheap
4
Accumulare
3
8
6
7
5
4
2
1
9
Accumulare
2
3
1
7
6
7
8
9
5
3
2
1
4
3
9
8
7
6
5
4
1
2
9
8
7
6
5
4
3
2
1
3
4
5
6
7
8
9
2
1
9
8
7
2
4
1
3
5
1
3
5
2
6
9
8
7
2
4
5
3
6
1
4
9
8
7
6
5
1
3
2
4
2
9
8
7
6
1
3
4
5
6
7
8
9
Figura 10.7: un esempio di calcolo di heapsort.

---
layout: 
title: Pagina 163
level: 3
---


Ricorsione sugli alberi
147
appartiene, mettendo l'elemento in basso a sinistra alla radice e diminuendo le dimensioni di
Il mucchio può essere realizzato scambiando gli elementi su un [1] e su un [i] e
decrementare i.
Codice:
algoritmo heapsort ()
⟨Pre-Cond⟩: L'ingresso è un array di numeri.
⟨Post-Cond⟩: i suoi valori sono riorganizzati in posizione per essere ordinati.
inizio
MakeHeap ()
i = n
ciclo continuo
⟨Loop-Invariant⟩: gli elementi N-I più grandi sono stati rimossi e ordinati in un [I + 1, N] e gli elementi I rimanenti formano un mucchio in un [1, I].
uscita quando i = 1
scambia (a [root], a [i])
i = i −1
Heapify (root)
% Su un mucchio di dimensioni i.
End Loop
Algoritmo di fine
Tempo di esecuzione: MakeHeap richiede (n) tempo, accumulare un albero di dimensioni che ho tempo
log (i), per un totale di t (n) = (n) + 1
i = n logi.Questa somma si comporta come un'aritmetica
somma.Quindi, il suo totale è n volte il suo valore massimo, cioè (n logn).
Errori comuni quando descrivono questi algoritmi: dichiarazioni che sono sempre vere, come "la radice è il massimo di qualsiasi heap", non fornire informazioni sul
stato del programma all'interno del ciclo.Per HeaPify, "la sottostruttura sinistra e la sottostruttura destra del nodo corrente sono un sacco" è utile.Tuttavia, alla fine diventa la sottostruttura
Una foglia, a quel punto questo loop invariante non ti dice che l'intero albero è un mucchio.
Per il heapsort, "L'albero è un mucchio" è buono, ma come si ottiene un elenco ordinato da questo
alla fine?Non eseguire routine senza assicurarsi che le loro preconoscenze siano
incontrato, come avere una chiamata heapsort heapify senza essere sicuri che la sinistra e la destra
Le subtrees del nodo dato sono un sacco.
Code prioritarie: come stack e code, le code prioritarie sono un ADT importante.
Definizione: una coda prioritaria è costituita da:
Dati: un insieme di elementi, ognuno dei quali è associato a un numero intero che è
indicato come priorità dell'elemento.

---
layout: 
title: Pagina 164
level: 3
---


Ricorsione
148
Operazioni:
Inserisci un elemento: un elemento, insieme alla sua priorità, viene aggiunto al
coda.La codifica è lasciata per l'esercizio 10.4.2.
Priorità del cambiamento: la priorità di un elemento già nella coda è
cambiato.La routine viene trasmessa un puntatore all'elemento all'interno della coda prioritaria e la sua nuova priorità.La codifica è lasciata per l'esercizio 10.4.3.
Rimuovere un elemento: rimuove e restituisce un elemento della massima priorità dalla coda.
Implementazioni:
Implementazione
Inserire il tempo
Cambia tempo
Rimuovere il tempo
Ordinato in un array o in un elenco collegato da
priorità
SU)
SU)
O (1)
Disortato in un array o in un elenco collegato
coda separata per ciascuno
livello di priorità
O (1)
O (1)
SU)
(Per aggiungere, vai alla coda corretta;
Elimina, trova primi non vuoti
coda)
O (1)
O (1)
O (n. Di priorità)
Cumuli
O (log n)
O (log n)
O (log n)
Implementazione dell'heap: gli elementi di una coda prioritaria sono conservati in un heap ordinato in base alla priorità degli elementi.
Operazioni:
Rimuovere un elemento: l'elemento della massima priorità è nella parte superiore di
il mucchio.Può essere rimosso e il mucchio dovrebbe quindi essere rechettato come
fatto in heapsort.
Inserire un elemento: posizionare il nuovo elemento nell'angolo in basso a destra del
accumulare, e poi bollerlo verso l'alto fino a quando non trova il posto corretto in base alla sua priorità.
Cambia priorità: la routine viene passata un puntatore all'elemento di cui
la priorità sta cambiando.Dopo aver apportato il cambiamento, questo elemento è gorgogliato
Su o giù per il mucchio, a seconda che la priorità sia aumentata o diminuita.

---
layout: 
title: Pagina 165
level: 3
---


Ricorsione sugli alberi
149
Esercizio 10.4.1 (vedi soluzione nella parte cinque.)
Considera un heap che memorizza i valori
1, 2, 3 ,..., 15.
1.
Dove nel mucchio può andare il valore 1?
2.
Quali valori possono essere memorizzati nella voce A [2]?
3.
Dove nel mucchio può andare il valore 15?
4.
In che dove può andare nel valore del valore 6?
Esercizio 10.4.2 Progettare un algoritmo per inserire un nuovo elemento nell'implementazione dell'heap della coda prioritaria.
Esercizio 10.4.3 Progettare un algoritmo per cambiare la priorità di un elemento nel mucchio
Attuazione della coda prioritaria.
10.5
Rappresentando espressioni con alberi
Ora considereremo come rappresentare espressioni multivariate usando alberi binari.
Svilupperemo gli algoritmi per valutare, copiare, differenziare, semplificare e stampare
tale espressione.Sebbene questi siano problemi apparentemente complessi, hanno semplici soluzioni ricorsive.
Definizione ricorsiva di un'espressione:
r Variabili singole x, y e z e valori reali singoli sono esse stesse espressioni.
r Se f e g sono espressioni, allora f + g, f −g, f ∗ g e f/g sono anche espressioni.
Struttura dei dati dell'albero: la definizione ricorsiva di un'espressione rispecchia direttamente
di un albero binario.Per questo motivo, un albero binario è una struttura di dati naturale per la conservazione di un
espressione.(Al contrario, puoi usare un'espressione per rappresentare un albero binario.)
Esempio 10.5.1
Valutare l'espressione
Questa routine valuta un'espressione rappresentata da un albero.Ad esempio,
può valutare f = x ∗ (y + 7), con xvalue = 2, yValue = 3 e zValue = 5 e restituire
2 ∗ (3 + 7) = 20.
+
y
7
X
\*
F

---
layout: 
title: Pagina 166
level: 3
---


Ricorsione
150
Esempio 10.5.1
Valutare l'espressione (cont.)
Codice:
Algoritmo Eval (F, XValue, YValue, ZValue)
⟨Pre-Cond⟩: f è un'espressione le cui uniche variabili sono x, y e z e xvalue, yvalue e zvalue sono i tre valori reali da assegnare a queste variabili.
⟨Post-Cond⟩: il valore restituito è la valutazione dell'espressione a questi valori
per x, y e z.L'espressione è invariata.
inizio
if (f = un valore reale) allora
risultato (f)
altrimenti if (f = "x") quindi
Risultato (XValue)
altro if (f = "y") quindi
risultato (yvalue)
altro if (f = "z") quindi
Risultato (ZValue)
else if (rootop (f) = "+")
Risultato (Eval (Sub sinistra (albero), XValue, yvalue, zValue)
+Eval (di Rightsub (albero), xvalue, yvalue, zValue))
else if (rootop (f) = “ -”)
Risultato (Eval (LeftSub (Tree), XValue, YValue, ZValue)
-Val (dirittib (albero), xvalue, yvalue, zValue))
else if (rootop (f) = “\*”)
Risultato (Eval (LeftSub (Tree), XValue, YValue, ZValue)
× Eval (di Rightsub (albero), xvalue, yvalue, zValue))
else if (rootop (f) = “/”)
Risultato (Eval (LeftSub (Tree), XValue, YValue, ZValue)
/Eval (Rightsub (Tree), XValue, YValue, ZValue))
finisci se
Algoritmo di fine
Esempio 10.5.2
Differenziare l'espressione
Questa routine calcola il derivato di una data espressione rispetto a un indicato
variabile.
Specifica:
Precondizioni: l'input è costituito da ⟨f, x⟩, dove f è un'espressione rappresentata
da un albero e x è una stringa che dà il nome di una variabile.
Postconditions: l'output è il derivato f ′ = df/dx.Questo derivato dovrebbe essere
Un'espressione rappresentata da un albero i cui nodi sono separati da quelli di f.IL
La struttura dei dati F dovrebbe rimanere invariata.Vedi Figura 10.8.
La codifica è lasciata per l'esercizio 10.5.1 e la traccia per l'esercizio 10.5.2.

---
layout: 
title: Pagina 167
level: 3
---


Ricorsione sugli alberi
151
X
F
\*
y
+
1
y
\*
\*
0
X
y
-
-
-
/
F
X

\*
y
y
X
0
\*
\*
y
1
/
y
+
F
X
+
0
1
/
semplificare f4 ′
\*
X
X
−1
X
/
/
X
X
S
1
F1
′
F2 ′
F3 ′
F4 ′
F4
2
3

/
\*
X
X

1
1
\*
X
X
/
\*
X
\*
X
/
X
X
X
\*
\*
1
UN
B
D
UN'
D
D'
C
C
C
C
B'
C'
S
T
u
v
M
N
P
Q
B
B
v
D
D
D
D
UN
C
Figura 10.8: quattro funzioni e loro derivati.Il quarto derivato è stato semplificato.
Esempio 10.5.3
Semplificare l'espressione
Questa routine semplifica una determinata espressione.Ad esempio, il derivato di x ∗ y con
Il rispetto a X verrà calcolato in 1 ∗ y + x ∗ 0.Questo dovrebbe essere semplificato a Y.
Specifica:
Precondizioni: l'input è costituito da un'espressione F rappresentata da un albero.
Postconditions: l'output è un'altra espressione che è una semplificazione di f.Suo
I nodi dovrebbero essere separati da quelli di F e F dovrebbero rimanere invariati.
Codice:
Algoritmo semplificare (f)
⟨Pre-Cond⟩: f è un'espressione.
⟨Post-Cond⟩: l'output è una semplificazione di questa espressione.
inizio
if (f = un valore reale o una singola variabile)
risultato (copia (f))
altrimenti % f è della forma (g ′ op h ′)
g = semplifica (sinistra (f))
H = semplificare (dirittiB (f))

---
layout: 
title: Pagina 168
level: 3
---


Ricorsione
152
Esempio 10.5.3
Semplificare l'espressione (cont.)
if (si applica uno dei seguenti moduli:
1 ∗ H = H
G ∗ 1 = G
0 ∗ H = 0
g ∗ 0 = 0
0 + H = H
g + 0 = g
g −0 = g
x −x = 0
0/h = 0
g/1 = g
g/0 = ∞
x/x = 1
6 ∗ 2 = 12
6/2 = 3
6 + 2 = 8
6 −2 = 4
) Poi
risultato (la forma semplificata)
altro
Risultato (G op H)
finisci se
finisci se
Algoritmo di fine
Questo è rintracciato nell'esercizio 10.5.3.
Esercizio 10.5.1 (vedi soluzione nella quinta parte.) Descrivere l'algoritmo per il derivato.
Non dare il codice completo.Dai solo le idee chiave.
Esercizio 10.5.2 Traccia l'esecuzione dell'algoritmo derivato sull'istanza
f = (x/x)/x indicato sopra.In altre parole, disegna un albero con una scatola per ogni volta una routine
è chiamato.Per ogni casella, includere solo la funzione f passata e il derivato restituito.
Esercizio 10.5.3 (vedi soluzione nella parte cinque.) Tracciano l'esecuzione di semplificare sul
Derivato F ′ ottenuto nell'esercizio 10.5.1, dove f = (x/x)/x.In altre parole, disegna a
albero con una scatola per ogni volta che viene chiamata una routine.Per ogni casella, includi solo la funzione
F passò e l'espressione semplificata restituita.

---
layout: 
title: Pagina 169
level: 3
---


153
11 immagini ricorsive
La ricorsione può essere utilizzata per costruire immagini molto complesse e belle.Noi iniziamo
Combinando le stesse due immagini fissate in modo ricorsivamente ancora e ancora.Ciò produce immagini simili a frattali le cui sottostrutture sono identiche al tutto.Successivamente lo faremo
generare labirinti casuali usando casualità per modificare leggermente queste due immagini così
che le sottostrutture non sono identiche.
11.1
Disegnare un'immagine ricorsiva da un ricorsivo fisso
e un'immagine della custodia base
Disegnare un'immagine: un'immagine è specificata da una serie di righe, cerchi e archi e da
Due punti A e B che sono indicati come maniglie.Prima di tale immagine può
essere disegnato sullo schermo, la sua posizione, dimensioni e orientamento sullo schermo devono essere
specificato.Lo faremo specificando due punti A e B sullo schermo.Poi un
Il programma semplice può tradurre, ruotare, scala e disegnare l'immagine sullo schermo in tale
un modo in cui i due punti maneggiano l'immagine atterrano su questi due punti specifici
lo schermo.
Specifica un'immagine ricorsiva: un'immagine ricorsiva è specificata da quanto segue:
1. Un'immagine della custodia base
2. Un'immagine ricorrente
3. Una serie di luoghi all'interno dell'immagine ricorrente per ricorrere
4. I due punti A e B sullo schermo in cui dovrebbe essere l'immagine ricorsiva
disegnato.
5. Un numero intero n.
Il caso di base: se n = 1, allora viene disegnata l'immagine del caso di base.

---
layout: 
title: Pagina 170
level: 3
---


Ricorsione
154
Figura 11.1: (a) uomo incorniciato in modo ricorsivo;(b) quadrato rotante.
RECURSING: se n> 1, allora l'immagine ricorsiva viene disegnata sullo schermo nella posizione
specificato.Incluse nell'immagine ricorsiva sono numerosi luoghi da ricorrere.Questi sono
ciascuno raffigurato da una freccia, ->> -.Quando l'immagine ricorsiva viene tradotta, ruotata, ridimensionata e disegnata sullo schermo, queste frecce si trovano da qualche parte sullo schermo.
Le frecce stesse non sono disegnate.Invece, la stessa immagine è disegnata in modo ricorsivo
in queste posizioni, ma con il valore n −1.
Esempi:
Man incorniciato in modo ricorsivo: vedi Figura 11.1.a.Il caso di base per questa costruzione
è composto da una faccia felice.Quando n = 1, questa faccia è disegnata.L'immagine ricorsiva
è costituito da un uomo che tiene un telaio.C'è un posto dove ricorrere all'interno del telaio.
Quindi, quando n = 2, quest'uomo è disegnato con la faccia felice n = 1 al suo interno.Per
n = 3, l'uomo tiene in mano una cornice contenente l'immagine n = 2 di un uomo in possesso di
incorniciata n = 1 faccia felice.L'immagine ricorsiva fornita è con n = 5.
di un uomo che tiene una foto di un uomo che tiene una foto di un uomo che tiene una foto
di ... una faccia.In generale, l'immagine ricorsiva per n contiene r (n) = r (n −1) + 1 =
n −1 uomini e b (n) = b (n −1) = 1 facce felici.
Quadrato rotante: vedi Figura 11.1.b.Questa immagine è costruita in modo simile a
precedente.Qui, tuttavia, il caso di base n = 1 è costituito da un cerchio.L'immagine ricorsiva è costituita da un singolo quadrato con l'immagine n -1 ridotta e ruotata
al suo interno.I quadrati continuano a spirale verso l'interno fino al raggiungimento del caso di base.
Torta di compleanno: vedi Figura 11.2.L'immagine ricorsiva della torta di compleanno è diversa
in quanto si ripresenta in due luoghi.Il caso di base n = 1 è costituito da un singolo cerchio.
L'immagine ricorsiva è costituita da una singola riga con due copie più piccole del
N −1 Immagine disegnata sopra di essa.In generale, l'immagine ricorsiva per n contiene r (n) =
UN
B
UN
Figura del caso base
Figura ricorsiva
B
Figura 11.2: torta di compleanno.

---
layout: 
title: Pagina 171
level: 3
---


Immagini ricorsive
155
Figura fogliare
Figura non-base
Figura del caso base
UN
UN
B
B
Figura 11.3: foglia.
2r (n −1) + 1 = 2n - 1 −1 linee dall'immagine ricorsiva e b (n) = 2b (n −1) =
Cerchi 2n - 1 dall'immagine del caso di base.
Foglia: vedi Figura 11.3.Una foglia è costituita da un singolo stelo più otto subleaves lungo di essa.
Ogni subleaf è una foglia n -1.L'immagine del caso di base è vuota e l'immagine ricorsiva è costituita dallo stelo più gli otto luoghi da ricorrere.Quindi, l'immagine n = 1
è vuoto.L'immagine n = 2 è costituita da uno stelo solitario.L'immagine n = 3 è uno stelo con
Otto steli per le foglie e così via.In generale, l'immagine ricorsiva per N contiene
R (n) = 8r (n −1) + 1 = 1
7 (8n - 1 −1) deriva dall'immagine ricorsiva.
Frattal: vedi Figura 11.4.Questa immagine ricorsiva è un classico.Il caso di base è un singolo
linea.L'immagine ricorsiva è vuota tranne quattro posti da ricorrere.Quindi, n = 1
è costituito dalla linea.n = 2 è costituito da quattro righe, che formano una linea con un equilatero
Triangolo che ne spinge.Man mano che N diventa grande, l'immagine diventa una fiologia della neve.Esso
è un frattale in quanto ogni pezzo sembra una copia del tutto.
Il modo classico per costruirlo è leggermente diverso da quello fatto qui.Nel metodo classico, ci è consentito la seguente operazione.Dato una linea, dividerla in
Tre parti uguali.Sostituire la parte centrale con le due linee di uguale lunghezza che formano un triangolo equilatero.A partire da una singola riga, costruisci il frattale applicando ripetutamente questa operazione a tutte le linee che appaiono.
In generale, l'immagine ricorsiva per n contiene B (n) = 4b (n −1) = 4N - 1 Base
linee di casi.La lunghezza di ciascuna di queste linee è l (n) = 1
3 l (n −1) =
1
3
n - 1.IL
La lunghezza totale di tutte queste linee è b (n) · l (n) =
4
3
n - 1.Come n si avvicina alla ﬁ writy, il
Il frattale diventa una curva della lunghezza in fini.
Tre -quattro figura
Figura non-base
Figura del caso base
UN
UN
B
B
Figura 11.4: Frattal.

---
layout: 
title: Pagina 172
level: 3
---


Ricorsione
156
UN
B
UN
Figura del caso base
Figura ricorsiva
B
UN
B
UN
Figura del caso base
Figura ricorsiva
B
(UN)
(B)
(C)
Figura 11.5: altri tre esempi.
Esercizio 11.1.1 (vedi soluzione nella parte cinque.) Vedi Figura 11.5.A.Costruire il ricorsivo
Immagine che deriva dal caso di base e dall'immagine ricorsiva per un po 'di grande n.Descrivere
che cosa sta accadendo.
Esercizio 11.1.2 (vedi soluzione nella parte cinque.) Vedi Figura 11.5.b.Costruire il ricorsivo
Immagine che deriva dal caso di base e dall'immagine ricorsiva per un po 'di grande n.Notare che
Uno dei luoghi in cui ricorrere è puntare di fronte all'altro.Per allineare l'immagine con
Queste frecce, l'immagine deve essere ruotata di 180 °.L'immagine non può essere fluida.
Esercizio 11.1.3 Vedi Figura 11.5.c.Questa costruzione sembra abbastanza semplice.La difficoltà si sta tenendo traccia di cui è angolare il cerchio.Costruire il caso di base e
L'immagine ricorsiva da cui sorge l'immagine ricorsiva data.Descrivi cosa è
accadere.
11.2
Generare casualmente un labirinto
Useremo metodi simili per generare un labirinto casuale.Il labirinto M sarà rappresentato da un array bidimensionale N × M con voci di {mattoni, pavimentazione, formaggio}.
Le pareti sono costituite da linee di mattoni.Un mouse sarà in grado di muoversi lungo le piazze del pavimento
una delle otto direzioni.Il labirinto generato non conterrà corridoi in quanto tale, ma solo molte piccole stanze rettangolari.Ogni stanza avrà una porta in una
Angolo della stanza o due porte negli angoli opposti.Il formaggio verrà collocato in un file
stanza che viene scelta in modo casuale tra le stanze che sono abbastanza lontane da
Posizione di inizio.
Precondizionismo: i addwall di routine vengono superati una matrice che rappresenta il labirinto come
costruito finora e le coordinate di una stanza al suo interno.La stanza avrà un muro circostante tranne una porta in uno dei suoi angoli.La stanza sarà vuota di
muri.La routine viene anche passata a una vasca che indica se il formaggio dovrebbe essere o meno
aggiunto da qualche parte nella stanza.
Postcondition: l'output è lo stesso labirinto con un sottomissione scelto in modo casuale
Aggiunti all'interno della stanza indicata e del formaggio aggiunti come appropriato.

---
layout: 
title: Pagina 173
level: 3
---


Immagini ricorsive
157
Formaggio
J
io
Figura 11.6: un labirinto contenente formaggio.
Condizioni iniziali: per soddisfare le condizioni preliminari di Addwalls, la routine principale prima
Costruisce le quattro pareti esterne con il quadrato in alto a destra a sinistra come una piastrella a pavimentazione per
Agire come una porta nel labirinto e come il quadrato di inizio per il mouse.Chiamando Addwalls
In questa camera singola completa il labirinto.
Sottosegui: se la stanza indicata ha altezza e larghezza di almeno 3, allora i addwall di routine sceglieranno una singola posizione (i, j) uniformemente a caso da tutti quelli
Nella stanza che non si trova proprio accanto a una delle sue pareti esterne.(Il (i, j) scelto dal
È indicato il telaio dello stack superiore nella Figura 11.6.) Viene aggiunto un muro all'interno della stanza tutto il
via attraverso la riga I e fino in fondo la colonna J, suddividendo la stanza in quattro
stanze più piccole.Per agire come una porta che collega queste quattro stanze, la piazza in posizione
(I, J) rimane una piastrella di pavimentazione.Vedi Figura 11.7.Quindi a quattro amici viene chiesto di infilare un labirinto
in ciascuna di queste quattro stanze più piccole.Se la nostra camera deve avere il formaggio, allora uno dei
Tre camere non contenenti la porta della nostra stanza sono selezionate per contenere il formaggio.
Amico 3
camera
camera
Amico 4
Amico 2
camera
camera
Amico 1
(i, j)
Figura 11.7: partizionamento di una stanza del labirinto.

---
layout: 
title: Pagina 174
level: 3
---


Ricorsione
158
Tempo di esecuzione: il tempo necessario per costruire un labirinto N × N è (N2).Questo può essere
visto in due modi.Per il modo più semplice, si noti che un mattone viene aggiunto al massimo una volta a qualsiasi voce
della matrice e che ci sono voci (N2).Il modo più duro risolve la ricorrenza
relazione t (n) = 4t (n/2) + (n) = (n2).
Cercare il labirinto: un modo per rappresentare un labirinto è da un grafico.Capitolo 14
Presenta una serie di algoritmi iterativi per la ricerca di un grafico.Sezione 14.5 Presenti
La versione ricorsiva dell'algoritmo di ricerca di profondità.Tutti questi potrebbero essere usati
da un topo per trovare il formaggio.
Esercizio 11.2.1 Scrivi il codice per generare un labirinto di stanze.
Esercizio 11.2.2 piastrellatura: il preliminare al problema è che ti vengono somministrati tre
numeri interi ⟨n, i, j⟩, dove io e j siamo nell'intervallo da 1 a 2n.Hai un quadrato 2n per 2n
Board of Squares.Hai un numero sufficiente di piastrelle ciascuna con la forma
.Il tuo obiettivo
è posizionare piastrelle non sovrapposte sul tabellone per coprire ciascuna delle piastrelle 2n × 2n tranne
Il quadrato singolo nella posizione ⟨i, j⟩.Dare un algoritmo ricorsivo per questo problema in cui
Metti una piastrella da solo e poi hai quattro amici che ti aiutino.Qual è il tuo caso di base?

---
layout: 
title: Pagina 175
level: 3
---


159
12 analisi con grammatiche senza contesto
Un importante problema di informatica è analizzare una stringa secondo un dato
Grammatica senza contesto.Una grammatica senza contesto è un mezzo per descrivere quali stringhe
dei personaggi sono contenuti in una lingua particolare.È costituito da una serie di regole
e un simbolo non terminale di inizio.Ogni regola specifica un modo per sostituire un simbolo non terminal nella stringa corrente con una stringa di simboli terminali e non terminali.
Quando la stringa risultante consiste solo di simboli terminali, ci fermiamo.Lo diciamo qualsiasi
Tale stringa risultante è stata generata dalla grammatica.
Le grammatiche senza contesto sono usate per comprendere sia la sintassi che la semantica di molte lingue molto utili, come espressioni matematiche, Java e inglese.La sintassi di una lingua indica quali stringhe di token sono frasi valide
in quella lingua.La semantica di una lingua comporta il significato associato
stringhe.Affinché un compilatore o un riconoscimento in lingua naturale determinino cosa
Una stringa significa che deve analizzare la stringa.Ciò implica derivare la stringa dal
Grammatica e, nel fare ciò, determinando quali parti della stringa sono frasi sostantivi, frasi verbali, espressioni e termini.
Alcune grammatiche senza contesto hanno una proprietà chiamata Look Ahead One.Stringhe da
Tali grammatiche possono essere analizzate in tempo lineare da quello che considero uno dei più
Algoritmi ricorsivi sorprendenti e magici.Questo algoritmo è presentato in questo capitolo.Dimostra molto chiaramente l'importanza di lavorare a livello di amici
di astrazione invece di tracciare i frame dello stack: scrivi attentamente le specifiche per ciascun programma, credi per magia che i programmi funzionino, scrivi i programmi
chiamarsi come se già lavorassero e assicurati che man mano che si ripresenta, il
L'istanza che viene input si riduce.
Nella sezione 19.8 analizzeremo un elegante algoritmo di programmazione dinamica
analizza una stringa da qualsiasi grammatica senza contesto, non solo guardare avanti uno, in (N3)
tempo.
La grammatica: esamineremo una grammatica molto semplice che considera le espressioni
Over × e +.In questa grammatica, un fattore è un intero semplice o un più complesso

---
layout: 
title: Pagina 176
level: 3
---


Ricorsione
160
espressione all'interno di parentesi;Un termine è uno o più fattori moltiplicati insieme;e un
L'espressione è uno o più termini sommati.Più precisamente:
Exp ⇒ Term
⇒ Term + termine +...+ termine
Termine ⇒ Fact
⇒ Fatto ∗ Fatto ∗ · · · ∗ Fatto
Fatto ⇒
⇒ (exp)
Non terminali, terminali e regole: più in generale, una grammatica è definita da a
Set di non terminali, un insieme di terminali, un non terminal iniziale e un insieme di regole.Qui
I non terminali sono "exp", "termine" e "fatto". I terminali sono numeri interi, il personaggio
"+" E il personaggio "\*".Il non terminal iniziale è "Exp." Il display precedente dà
L'elenco delle regole per questa grammatica.
Una derivazione di una stringa: una grammatica definisce un linguaggio di stringhe che possono essere derivate nel modo seguente.Una derivazione di una stringa inizia con il simbolo di avvio (un non terminal).Quindi ogni regola, come quelle appena fornite, dice che puoi sostituire il non terminal a sinistra con la stringa di terminali e non terminali a destra.
L'analisi di un'espressione: Sia S una stringa composta da terminali.Un'analisi di
Questa stringa è un albero.Ogni nodo interno dell'albero è etichettato con un simbolo non terminale e la radice con il non terminal avviamento.Ogni nodo interno deve corrispondere a
una regola della grammatica.Ad esempio, per la regola A ⇒bc, il nodo è etichettato a e il suo
Due bambini sono etichettati B e C. Le foglie dell'albero, lette da sinistra a destra, danno il
stringa di input S di terminali.La Figura 12.1 è un esempio.
fatto
fatto
Exp
termine
fatto
Exp
termine
Exp
termine
fatto
fatto
fatto
fatto
fatto
fatto
fatto
fatto
termine
termine
termine
termine
Exp
termine
fatto
fatto
fatto
termine
6
\*
8
+
(
(
2
+
42
)
\*
(
5
+
12
978
)
+
\*
\*
+
\*
7
123
15
54
)
Figura 12.1: un albero di analisi per la stringa s = 6 ∗ 8 + ((2 + 42) ∗ (5 + 12) + 987 ∗ 7 ∗ 123 + 15 ∗
54).

---
layout: 
title: Pagina 177
level: 3
---


Analisi con grammatiche senza contesto
161
Il tipo di dati astratti di analisi: quello che segue è un esempio in cui è utile non fornire i dettagli di implementazione completi di un tipo di dati astratto.In caso di fatto, noi
lascerà anche la specifica della struttura di analisi aperta per l'implementatore
decidere.
Per i nostri scopi, diremo solo quanto segue: quando P è una variabile di tipo
Analisi, useremo "p = 5" per indicare che è assegnato un'analisi dell'espressione
"5." Continueremo a sovraccaricare le operazioni ∗ e + come operazioni che si uniscono a due argini in uno.Ad esempio, se P1 è un'analisi dell'espressione '2 ∗ 3' e p2 di '5 ∗ 7', allora useremo P = P1 + P2 per indicare un'analisi dell'espressione '2 ∗ 3' + 5 ∗ 7.
L'implementatore definisce la struttura di un'analisi specificando in modo più dettagliato
Cosa fanno queste operazioni.Ad esempio, se l'implementatore vuole che l'analisi sia un
albero binario che rappresenta l'espressione, quindi p1 + p2 sarebbe il funzionamento della costruzione di un albero binario con la radice essendo un nuovo nodo " +", la sottostruttura sinistra è la
albero binario P1 e la sottostruttura destra è l'albero binario P2.D'altra parte, se
L'implementatore vuole che l'analisi sia semplicemente una valutazione intera dell'espressione, quindi P1 + P2 sarebbe la somma intera dei numeri interi P1 e P2.
Specifiche per l'algoritmo di analisi:
Precondizionismo: l'input è costituito da una stringa di token s.I token possibili
sono i personaggi "\*" e "+" e numeri interi arbitrari.I token sono indicizzati come
S [1], S [2], S [3] ,..., s [n].
Postcondition: se l'input è un'espressione valida generata dalla grammatica, allora
L'output è un'analisi dell'espressione.Altrimenti, viene emesso un messaggio di errore.
L'algoritmo è costituito da una routine per ogni non terminal della grammatica: getExp, getterm e getFact.
Specifiche per GETEXP:
Precondizionismo: l'input di GetExp è costituito da una stringa di token e un indice i
Ciò indica un punto di partenza all'interno di s.
Postcondition: l'output consiste in un'analisi della sottostringa più lunga S [i], s [i +
1] ,..., s [j −1] di s che inizia all'indice I ed è un'espressione valida.Il risultato
Include anche l'indice J del token che viene immediatamente dopo l'analisi
espressione.
Se non esiste un'espressione valida a partire da S [i], viene emesso un messaggio di errore.
Le specifiche per getterm e getFact sono le stesse di GETEXP, tranne per questo
restituiscono l'analisi del termine o del fattore più lungo che iniziano da S [i] e finiscono
S [J −1].

---
layout: 
title: Pagina 178
level: 3
---


Ricorsione
162
Esempi di getExp, getterm e getfact: vedi Figura 12.2
Figura 12.2: Le istanze di input di esempio sono riportate per Get Exp, GetTerm e Get Fat.La stringa
S è lo stesso per tutti gli esempi.L'inizio del rettangolo indica l'indice di input i in cui
L'analisi dovrebbe iniziare.Il contenuto del rettangolo indica l'analisi risultante.La fine di
Il rettangolo indica l'indice di output J a cui finisce l'analisi.

---
layout: 
title: Pagina 179
level: 3
---


Analisi con grammatiche senza contesto
163
Ragionamento per getExp: considera alcune stringhe di input s e alcune indici i.La più lunga
sottostringa s [i] ,..., s [j −1] che è un'espressione valida consiste di un certo numero di termini
aggiunto insieme.In tutti questi casi, inizia con un termine.Per magia, supponiamo che il
La routine getterm funziona già.Chiamare getterm (s, i) restituirà pterm e jterm, dove
pterm è l'analisi di questo primo termine e jterm indicizza il token immediatamente dopo questo
termine.In particolare, se l'espressione ha un altro termine, allora jterm indicizza il "+"
è tra questi termini.Quindi, possiamo determinare se c'è un altro termine
Verifica s [jterm].Se s [jterm] = "+", allora getExp chiamerà di nuovo getterm per ottenere il prossimo
termine.Se S [jterm] non è un "+" ma qualche altro personaggio, allora getExp è finito la lettura
In tutti i termini.GetExp quindi costruisce l'analisi costituita da tutti questi termini
aggiunto insieme.
Il ragionamento per getterm è lo stesso.
Codice getExp:
algoritmo getExp (s, i)
⟨Pre-Cond⟩: s è una stringa di token, Andi è un indice che indica un punto di partenza
all'interno di S.
⟨Post-Cond⟩: L'output è costituito da una anallo p della sottostringa più lunga S [i], s [i +
1] ,..., s [j −1] di s che inizia all'indice I ed è un'espressione valida.Il risultato
Include anche l'indice J del token che viene immediatamente dopo l'analisi
espressione.
inizio
if (i> | s |) restituisce “Errore: caratteri attesi passati alla fine della stringa.”finisci se
⟨P⟨term, 1⟩, j⟨term, 1⟩⟩ = getterm (s, i)
k = 1
ciclo continuo
⟨Loop-invariant⟩: i primi termini K dell'espressione sono stati
Leggere.
Esci quando s [j⟨term, k⟩] ̸ = "+"
⟨P⟨term, k+1⟩, j⟨term, k+1⟩⟩ = getterm (s, j⟨term, k⟩+1)
k = k + 1
End Loop
pexp = p⟨term, 1⟩+ p⟨term, 2⟩+...+ p⟨term, k⟩
jexp = j⟨term, k⟩
return ⟨pexp, jexp⟩
Algoritmo di fine
Codice getterm:
algoritmo getterm (s, i)
⟨Pre-Cond⟩: s è una stringa di token, Andi è un indice che indica un punto di partenza
all'interno di S.
⟨Post-Cond⟩: L'output è costituito da una anallo P della sottostringa più lunga S [i], s [i +
1] ,..., s [j −1] di s che inizia all'indice I ed è un termine valido.L'output include anche l'indice J del token che arriva immediatamente dopo il termine analizzato.

---
layout: 
title: Pagina 180
level: 3
---


Ricorsione
164
inizio
if (i> | s |) restituisce “Errore: caratteri attesi passati alla fine della stringa.”finisci se
⟨P⟨fact, 1⟩, j⟨fact, 1⟩⟩ = getfact (s, i)
k = 1
ciclo continuo
⟨Loop-invariant⟩: i primi fatti K del termine sono stati letti.
Esci quando S [J⟨Fact, K⟩] ̸ = "\*"
⟨P⟨fact, k+1⟩, j⟨fact, k+1⟩⟩ = getfact (s, j⟨fact, k⟩+1)
k = k + 1
End Loop
pterm = p⟨fact, 1⟩ ∗ p⟨fact, 2⟩ ∗ · · ∗ p⟨fact, k⟩
jterm = j⟨fact, k⟩
return ⟨pterm, jterm⟩
Algoritmo di fine
Ragionamento per GetFact: la sottostringa più lunga s [i] ,..., s [j −1] che è un fattore valido
ha una delle seguenti due forme:
Fatto ⇒
Fatto ⇒ (exp)
Quindi, possiamo determinare quale forma il fattore ha dal test S [i].
Se S [i] è un numero intero, allora siamo finiti.PFACT è un'analisi di questo singolo numero intero s [i] e jfact = i + 1. Il +1 sposta l'indice oltre l'intero.
Se s [i] = "(", allora per S essere un fattore valido, deve esserci un'espressione valida che inizia da JTerm + 1, seguita da una fascia di chiusura ")".Possiamo analizzare questa espressione con
GetExp (s, jterm + 1), che restituisce pexp e jexp.La staffa di chiusura dopo l'espressione deve essere in S [JEXP].Il nostro fattore analizzato sarà PFACT = (PEXP) e JFACT = JEXP + 1.
+1 sposta l'indice oltre il ")".
Se S [i] non è né un numero intero né un "(", allora non può essere un fattore valido. Dai un messaggio di errore significativo.
Ottieni codice:
algoritmo getfact (s, i)
⟨Pre-Cond⟩: s è una stringa di token ei è un indice che indica un punto di partenza
all'interno di S.
⟨Post-Cond⟩: L'output è costituito da una anallo P della sottostringa più lunga S [i], s [i +
1] ,..., S [J −1] di S che inizia all'indice I ed è un fattore valido.Anche l'output
Include l'indice J del token che viene immediatamente dopo il fattore analizzato.
inizio
if (i> | s |) restituisce “Errore: caratteri attesi passati alla fine della stringa.”finisci se
if (s [i] è un int)
pFact = S [i]
jfact = i + 1
restituire ⟨pfact, jfact⟩

---
layout: 
title: Pagina 181
level: 3
---


Analisi con grammatiche senza contesto
165
else if (s [i] = "(")
⟨Pexp, jexp⟩ = getExp (s, i + 1)
if (s [jexp] = ")")
pFact =

pexp

jfact = jexp + 1
restituire ⟨pfact, jfact⟩
altro
Output "Errore: previsto") "su indice jexp"
finisci se
altro
Output "Errore: intero previsto o" ("all'indice i"
finisci se
Algoritmo di fine
Frame di albero di stack: getExp chiama getterm, che chiama getfact, che può chiamare
GetExp e così via.Se uno dovesse disegnare l'intero albero dei cornici dello stack
Chi chiama chi, questo avrebbe rispecchiato esattamente l'albero di analisi che ha creato.Vedi Esercizio 12.0.1.
Tempo di esecuzione: dimostriamo che il tempo di esecuzione di tutto questo calcolo è lineare
nelle dimensioni dell'albero di analisi prodotto, che a sua volta è lineare nelle dimensioni (n) del
stringa di input.
Per dimostrare il primo, è sufficiente dimostrare che il tempo di esecuzione di ogni stack
Il frame o è costante o è lineare nel numero di bambini del nodo durante lo slancio
albero che questa cornice stack produce.Ad esempio, se il telaio dello stack per getfact ﬁ nd
Un numero intero, quindi il suo nodo nell'albero di analisi non ha figli, ma getfact usa solo un
quantità costante di tempo.Al contrario, se un frame stack per GETExp legge in termini T, il suo tempo di esecuzione sarà un tempo più costante e il suo nodo nell'albero di sancio
avere bambini.
Dimostriamo ora che le dimensioni dell'albero di analisi prodotta è lineare nelle dimensioni (n) di
la stringa di input.Se la grammatica è tale che ogni non terminal va ad almeno uno
terminale o almeno due non terminali, quindi ogni nodo nell'albero di sancio è una foglia
o ha almeno due figli.Ne consegue che il numero di nodi nell'albero di sancio
essere al massimo alcuni tempi costanti il ​​numero di foglie, che è la dimensione dell'input
corda.Nella nostra grammatica, tuttavia, un'espressione potrebbe andare a un singolo termine, che può
Vai a un singolo fattore.Questo crea un piccolo percorso di outdegree.Tuttavia, non può essere
più lungo di questo, perché un fattore è una foglia o ha tre figli: uno è "("
secondo un'espressione e il terzo ")".Tali piccoli percorsi possono solo aumentare le dimensioni di
l'albero di analisi di un fattore 3.
In conclusione, il tempo di esecuzione è (n).
Prova della correttezza: per dimostrare che un programma ricorsivo funziona, dobbiamo considerare
la dimensione di un'istanza.La routine deve solo considerare i post -ﬁ x s [i], s [i + 1] ,..., che contiene | s |−i + 1 caratteri.Quindi, definiremo le dimensioni dell'istanza

---
layout: 
title: Pagina 182
level: 3
---


Ricorsione
166
⟨S, i⟩to essere | ⟨s, i⟩ |= | S |−i + 1. Sia H (n) l'affermazione “Ognuno di GetFac, GetTerm e GetExp funziona sull'istanza ⟨s, I⟩when | ⟨s, I⟩ |= | S |−i + 1 ≤n. "Dimostriamo di
induzione che ∀n ≥0, h (n).
Se | ⟨s, i⟩ |= 0, quindi i> | s |: non esiste un'espressione, un termine o un fattore validi che iniziano
S [i] e tutte e tre le routine restituiscono un messaggio di errore.Ne consegue che H (0) è vero.
Se | ⟨s, i⟩ |= 1, allora c'è un token rimanente: affinché questo sia un fattore, un termine o
espressione, deve essere un singolo numero intero.Getfac è scritto per dare la risposta corretta in
questa situazione.Getterm dà la risposta corretta, perché chiama getfac.GetExp dà
La risposta corretta, perché chiama getterm, che a sua volta chiama getfac.Ne consegue che
H (1) è vero.
Supponiamo che H (n −1) sia vero, cioè che ciascuno di GetFac, GetTerm e GetExp operi
su istanze di dimensioni al massimo n -1.
Considera Getfac (s, i) su un'istanza di dimensioni | s |−i + 1 = n.Fa al massimo uno
Chiamata di subroutine, getExp (s, i + 1).La dimensione di questa istanza è | s |- (i + 1) + 1 = n −1.
Quindi, per presupposto, questa chiamata di subroutine restituisce la risposta corretta.Perché tutto
delle chiamate subroutine di Getfac (s, i) restituiscono la risposta corretta, ne consegue che Getfac (s, i)
Funziona su tutti i casi di dimensioni n.
Ora considera getterm (s, i) su un'istanza di dimensioni | s |−i + 1 = n.Chiama GetFac
un certo numero di volte.L'istanza di input per la prima chiamata getfac (s, i) ha ancora la taglia n.
Quindi, l'ipotesi di induzione H (n −1) non afferma di funzionare.comunque, il
Il paragrafo precedente dimostra che questa routine funziona effettivamente su istanze di dimensioni n.
Le chiamate rimanenti sono su casi più piccoli.
Infine, considera getExp (s, i) su un'istanza ⟨s, i⟩of size | s |−i + 1 = n.Noi usiamo
Il paragrafo precedente per dimostrare che è la prima chiamata di subroutine getterm (s, i) funziona.
In conclusione, tutti e tre funzionano su tutti i casi di dimensione N e quindi su H (N).Questo
Completa la fase di induzione.
Guarda avanti uno: si dice che una grammatica sia guarda prima se, date due regole per
Lo stesso non terminal, il primo posto in cui le regole differiscono è una differenza in un terminale.
(Equivalentemente, le regole possono essere visualizzate come percorsi lungo un albero.) Questa funzione consente la nostra
Algoritmo di analisi per guardare solo il segno successivo per decidere cosa fare dopo.
Quindi l'algoritmo funziona in tempo lineare.Un esempio di una buona serie di regole sarebbe
A ⇒ b "u" c "w" e
A ⇒ b "u" c "x" f
A ⇒ b "u" c
A ⇒ b "v" g h
H
G
v
UN
B
u
C
w
X
E
F
(In realtà, anche questa grammatica potrebbe anche essere problematica se quando s = "bbbucccweee", b
Potrebbe essere analizzato come "BBB" o come "BBBU". Avere B che mangia la "U" sarebbe un problema.)

---
layout: 
title: Pagina 183
level: 3
---


Analisi con grammatiche senza contesto
167
Un esempio di una cattiva serie di regole sarebbe
A ⇒bc
A ⇒ de.de
Con una tale grammatica, non sapresti se iniziare a analizzare la stringa come a
B o un D. Se avessi fatto la scelta sbagliata, dovresti eseguire il backup e ripetere il
processi.
Esercizio 12.0.1 (vedere la soluzione nella parte cinque.) Considera s = (((1) ∗ 2 + 3) ∗ 5 ∗ 6 + 7).
1.
Dare una derivazione dell'espressione s.
2.
Disegna la struttura dell'albero dell'espressione s.
3.
Traccia l'esecuzione del programma su getExp (s, 1).In altre parole, disegna a
albero con una scatola per ogni volta che viene chiamata una routine.Per ogni scatola, includi solo se
È un'espressione, un termine o un fattore e la stringa s [i] ,..., s [j −1] che è analizzato.
Esercizio 12.0.2
Considera una grammatica G che include le quattro regole del lookahead per
A. Dai il codice per GETA (s, i) che è simile a quello per GetExp (s, i).Possiamo assumere
che può essere analizzato, quindi non preoccuparti del rilevamento degli errori.
Esercizio 12.0.3
Se ti senti audace, prova a scrivere un programma ricorsivo per un generico
Algoritmo di analisi.L'ingresso è ⟨g, t, s, i⟩, dove g è una grammatica da look-ahead-one, t
è un non terminal di g, s è una stringa di terminali e i è un indice.L'output consiste
di un'analisi della sottostringa più lunga s [i], s [i + 1] ,..., s [j −1] di s che inizia all'indice i
ed è una t valida secondo la grammatica G. In altre parole, l'analisi inizia con
T non terminali T e termina con la stringa s [i], s [i + 1] ,..., s [j −1].L'output include anche l'indice J del token che arriva immediatamente dopo l'espressione analizzata.Per
Esempio, getExp (s, i) è lo stesso di chiamare questo algoritmo su ⟨g, exp, s, i⟩where g è
La grammatica fornita sopra.
L'anello invariante è che hai analizzato un pre -ﬁ x s [i], s [i + 1] ,..., S [J ′ −1] di S, producendo un'analisi parziale, P e il resto della stringa, S [J ′], S [J ′ + 1] ,..., s [j −1], verrà analizzato usando una delle regole parziali nell'insieme R. Ad esempio, supponiamo il
La grammatica G include le quattro regole del lookahead per un dato sopra, stiamo iniziando
con il non terminale t = a e stiamo analizzando la stringa s = "bbbuccccweee".Inizialmente, non abbiamo analizzato nulla e R contiene tutte le quattro regole, vale a dire
R = {Bucwe, Bucxf
, Buc, Bvgh}.Dopo due iterazioni, abbiamo analizzato "BBBU" usando un
Anallo di PB per "BBB" seguito dal personaggio "U".Dobbiamo analizzare il resto della stringa
cccweee usando una delle regole in r = {cwe, cxf
, C}.Si noti che il pre-x x usate
Dalle regole coerenti e le regole incoerenti sono state eliminate.Poiché la grammatica è guardare avanti, sappiamo che o il primo token in ogni regola di R è lo stesso
Non terminal B, o ogni regola di R inizia con un terminale o è la regola vuota.Questi sono
I due casi la tua iterazione deve affrontare.

---
layout: 
title: Pagina 184
level: 3
---


---
layout: 
title: Pagina 185
level: 3
---


PARTE TERZA
Problemi di ottimizzazione

---
layout: 
title: Pagina 186
level: 3
---


---
layout: 
title: Pagina 187
level: 3
---


171
13 Definizione dei problemi di ottimizzazione
Molti problemi importanti e pratici possono essere espressi come problemi di ottimizzazione.
Tali problemi comportano la ricerca del meglio di una serie di soluzioni esponenzialmente grandi.Esso
Può essere come trovare un ago in un pagliaio.L'ovvio algoritmo, considerando ciascuno
Delle soluzioni, richiede troppo tempo perché ci sono così tante soluzioni.Alcuni
Di questi problemi possono essere risolti nel tempo polinomiale usando flusso di rete, programmazione lineare, algoritmi avidi o programmazione dinamica.In caso contrario, il backtracking ricorsivo a volte può trovare una soluzione ottimale per alcuni casi in alcune applicazioni pratiche.A volte si possono trovare più soluzioni ottimali
facilmente.Gli algoritmi casuali, che le monete fluttuanti, a volte hanno più fortuna.Tuttavia, per i problemi di maggior ottimizzazione, l'algoritmo più noto richiede 2 (n) tempi
Nelle istanze di input del caso peggiore.La convinzione comunemente ritenuta è che non ci sono
Algoritmi a tempo polinomiale per loro (anche se potremmo sbagliarci).Competenze NP
aiuta a giustificare questa convinzione dimostrando che alcuni di questi problemi sono universalmente
difficile tra questa classe di problemi.Ora definisco formalmente questa classe di problemi.
Ingredienti: un problema di ottimizzazione è specificato dal definire istanze, soluzioni e costi.
I istanze: le istanze sono i possibili input del problema.
Soluzioni ad esempio: ogni istanza ha una serie di soluzioni esponenzialmente grandi.
Una soluzione è valida se soddisfa una serie di criteri determinati dall'istanza a portata di mano.
Misura del successo: ogni soluzione ha un costo, valore o misura del successo facili da comparire che deve essere minimizzato o massimizzato.
Specificazione di un problema di ottimizzazione:
Precondizioni: l'input è un'istanza.
Postconditions: l'output è una delle soluzioni valide per questa istanza con
ottimale (minimo o massimo come può essere il caso) misura del successo.(IL
Soluzione da produrre non deve essere unica.)

---
layout: 
title: Pagina 188
level: 3
---


Problemi di ottimizzazione
172
Esempi:
Sottoce successione comune più lunga: questo è un esempio per il quale abbiamo un algoritmo a tempo polinomiale.
Istanze: un'istanza è costituita da due sequenze, ad esempio x = ⟨a, b, c, b, d, a, b⟩and y = ⟨b, d, c, a, b, a⟩.
Soluzioni: una successione di una sequenza è un sottoinsieme degli elementi presi
nello stesso ordine.Ad esempio, z = ⟨b, c, a⟩ è una sottosequenza di x =
⟨A, B, C, B, D, A, B⟩.Una soluzione è una sequenza z che è una sottosequenza di entrambi
X e Y. Ad esempio, z = ⟨b, c, soluzione a⟩is, perché è una sottosequenza
Comune sia a X e Y (Y = ⟨b, D, C, A, B, A⟩).
Misura del successo: il valore di una soluzione è la lunghezza del comune
SUSTIVE, E.G., | Z |= 3.
Obiettivo: date due sequenze xey, l'obiettivo è quello di trovare il comune più lungo
SUSTINE (LCS in breve).Per l'esempio sopra indicato, z = ⟨b, c, b, a⟩
è una sottosequenza comune più lunga.
Pianificazione dei corsi: questo è un esempio per il quale non abbiamo un algoritmo di tempo polinomiale.
Istanze: un'istanza consiste nel set di corsi specifici da un'università, dall'insieme di corsi che ogni studente richiede e il set di fasce orarie in questo
I corsi possono essere offerti.
Soluzioni: una soluzione per un'istanza è un programma che assegna ciascun corso
Uno fascia oraria.
Misura del successo: un conflitto si verifica quando due corsi sono programmati al
Lo stesso tempo anche se uno studente richiede entrambi.Il costo di un programma
è il numero di conflitti che ha.
Obiettivo: dato il corso e le informazioni degli studenti, l'obiettivo è trovare il
Programma con il minor numero di conflitti.
Aereo: quanto segue è un esempio di un problema pratico.
I istanze: un'istanza specifica i requisiti di un piano: dimensione, velocità, efficienza del carburante, ecc.
Soluzioni: una soluzione per un'istanza è una specifica di un piano, proprio verso il basso
a ogni curva e dado e bullone.
Misura del successo: l'azienda ha un modo per misurare quanto bene il
La specifica soddisfa i requisiti.
Obiettivo: dati requisiti aerei, l'obiettivo è quello di trovare una specifica che soddisfa
loro in modo ottimale.

---
layout: 
title: Pagina 189
level: 3
---


173
14 algoritmi di ricerca del grafico
Un problema di ottimizzazione richiede la ricerca del meglio di un gran numero di soluzioni.
Questo può essere paragonato a un formaggio di mouse in un labirinto.Algoritmi di ricerca del grafico
Fornire un modo per cercare sistematicamente attraverso questo labirinto di possibili soluzioni.
Un altro esempio di un problema di ottimizzazione è trovare il percorso più breve tra due nodi in un grafico.Potrebbe esserci un numero esponenziale di percorsi tra
Questi due nodi.Ci vorrebbe troppo tempo per considerare ogni percorso del genere.Gli algoritmi usati per trovare uno più corto dimostrano molti dei principi che sorgeranno
Quando si risolvono problemi di ottimizzazione più difficili.
Un numero sorprendentemente elevato di problemi nell'informatica può essere espresso
come problemi di teoria dei grafici.In questo capitolo, impareremo prima un algoritmo di ricerca generico che trova sempre più del grafico seguendo i bordi arbitrari dai nodi
che sono già stati trovati.Consideriamo anche gli ordini più specifici di profondità
e prima ricerca per attraversare il grafico.
Usando queste idee, siamo in grado di risolvere il problema di ottimizzazione della scoperta
Percorsi più brevi tra coppie di nodi e per conoscere la struttura del grafico.

---
layout: 
title: Pagina 190
level: 3
---


Problemi di ottimizzazione
174
14.1
Un algoritmo di ricerca generico
Il problema di raggiungibilità:
Precondizioni: l'input è un grafico G (diretto o non indirizzato) e a
nodo di origine s.
Postconditions: l'output è costituito da tutti i nodi U che sono raggiungibili da a
percorso in g da s.
Passaggi di base: supponiamo di sapere che il nodo u è raggiungibile da s (indicato come s -
→ U)
e che c'è un vantaggio da U a v. Quindi puoi concludere che V è raggiungibile da
S (cioè, s -
→ U → V).È possibile utilizzare tali passaggi per creare una serie di nodi raggiungibili.
R S ha un vantaggio su V4 e V9.Quindi, V4 e V9 sono raggiungibili.
R V4 ha un vantaggio su V7 e V3.Quindi, V7 e V3 sono raggiungibili.
R V7 ha un vantaggio su V2 e V8....
Difficazioni:
Struttura dei dati: come si tiene traccia di tutto questo?
Condizione di uscita: come fai a sapere di aver trovato tutti i nodi?
Halting: come evitare il ciclismo, come in S → V4 → V7 → V2 → V4 → V7 → V2 →
V4 → V7 → V2 → V4 → · · ·, per sempre?
Ingredienti del ciclo invariante:
Trovato: se tracciare un percorso da s a un nodo, allora diremo che il nodo ha
stato trovato.
Gestito: ad un certo punto nel tempo dopo che il nodo U è stato trovato, vorrai farlo
Segui tutti i bordi da U e trovano tutti i nodi V che hanno bordi da u.Quando
L'hai fatto per Node U, diciamo che è stato gestito.
Struttura dei dati: è necessario mantenere (1) l'insieme di nodi basati che hanno
è stato trovato e gestito e (2) l'insieme di nodi trovati in modo che abbiano
stato trovato ma non gestito.Vedi Figura 14.1.
Il ciclo invariante:
Li1: Per ogni nodo trovato V, sappiamo che V è raggiungibile da S, perché abbiamo
Tracciato un percorso S -
→ V da s ad esso.
LI2: Se è stato gestito un nodo, allora tutti i suoi vicini sono stati trovati.
Questi invarianti ad anello sono abbastanza semplici da stabilire e mantenerli
dovrebbe essere facile.Ma si suonano per dimostrare il postcondizionismo?Vedremo.

---
layout: 
title: Pagina 191
level: 3
---


Algoritmi di ricerca del grafico
175
Nodo appena gestito
FoundNothandled
Fund -Handled
S
S
S
S
S
S
Figura 14.1: L'algoritmo di ricerca generico gestisce un nodo trovato alla volta trovando il suo
vicinato.
Corpo del ciclo: un passo ragionevole sarebbe:
r Scegli un po 'di nodo U da FoundNothandled e maneggilo.Ciò implica seguire tutti i bordi di u.
r nuovi nodi ora sono ora aggiunti al set fondato (se non lo hanno fatto
è già stato trovato).
R u viene spostato da fondati a base di fondi.
Codice:
Algoritmo Genericsearch (G, S)
⟨Pre-Cond⟩: G è un grafico (diretto o non indirizzato) e S è uno dei suoi nodi.
⟨Post-Cond⟩: l'output è costituito da tutti i nodi U che sono raggiungibili da un percorso
in g da s.
inizio
FODDHANDLED = ∅
FoundNotHandled = {s}
ciclo continuo
⟨Loop-Invariant⟩: vedi Li1, Li2.
uscita quando è stato fondato = ∅
Lascia che tu sia un nodo da FoundNothandled
Per ogni V collegato a u
Se V non è stato precedentemente trovato allora
Aggiungi V a FoundNothandled
finisci se
fine per

---
layout: 
title: Pagina 192
level: 3
---


Problemi di ottimizzazione
176
spostati da fondati a base di fondi
End Loop
Restituisce Fund -Handled
Algoritmo di fine
Mantenimento dell'invariante in loop (⟨li′⟩ & not ⟨exit⟩ & codeloop → ⟨li′′⟩):
Supponiamo che li ′ (la dichiarazione del ciclo invariante prima dell'iterazione) sia
è vero, la condizione di uscita ⟨exit⟩ non è e abbiamo eseguito un'altra iterazione del
algoritmo.
Mantenimento di LI1: dopo l'iterazione, il nodo V viene considerato.Quindi, in
Ordine per mantenere l'invariante del ciclo, dobbiamo essere sicuri che V sia raggiungibile da S.
Poiché tu era a fondare, l'invariante loop ci assicura che abbiamo
Tracciato un percorso S -
→ u ad esso.Ora che abbiamo rintracciato il bordo u → V, abbiamo
tracciato un percorso s -
→ U → V a v.
Mantenimento di Li2: il nodo U è designato gestito solo dopo aver assicurato che tutto il suo
I vicini sono stati trovati.
La misura del progresso: la misura del progresso richiede i seguenti tre
proprietà:
Progressi: dobbiamo garantire che almeno la nostra misura del progresso aumenti
uno ogni volta intorno al ciclo.Altrimenti, possiamo caricarci per sempre, facendo no
progresso.
Limitato: deve esserci un limite superiore sui progressi richiesti prima del
Loop uscite.Altrimenti, possiamo loop per sempre, aumentando la misura del progresso a
in ﬁ writy.
Conclusione: quando sono stati fatti progressi sufficienti per uscire, dobbiamo essere in grado di farlo
concludere che il problema è risolto.
Una misura ovvia sarebbe il numero di nodi trovati.Il problema è che quando
Gestione di un nodo, puoi trovare solo nodi che sono già stati trovati.In tale
Caso, in realtà non sono stati fatti progressi.
Una migliore misura del progresso è il numero di nodi che sono stati gestiti.Noi
può fare progressi semplicemente gestendo un nodo che non è stato ancora gestito.Anche noi
Sappi che se il grafico G ha solo n nodi, questa misura non può aumentare n.
Condizione di uscita: data la nostra misura del progresso, quando siamo finiti?Possiamo solo
Gestire i nodi che sono stati trovati e non gestiti.Quindi, quando tutti i nodi che
Sono stati trovati anche gestiti, non possiamo fare più progressi.A questo
punto, dobbiamo fermarci.
Codice iniziale (⟨pre-Cond⟩ & CodePre-Loop ⇒⟨loop-invariante⟩): inizialmente, lo sappiamo solo
Quella s è raggiungibile da s.Quindi, iniziamo dicendo che S si trova ma non gestita
e che tutti gli altri nodi non sono ancora stati trovati.

---
layout: 
title: Pagina 193
level: 3
---


Algoritmi di ricerca del grafico
177
Uscire loop (⟨li⟩ & ⟨exit⟩ → ⟨post⟩): il nostro output sarà l'insieme di nodi trovati.
La postcondition richiede che le seguenti due affermazioni siano vere.
Reclamo: i nodi trovati sono raggiungibili da s.
Questo è chiaramente indicato nell'invariante loop.
Reclamo: ogni nodo raggiungibile è stato trovato.Una dichiarazione logicamente equivalente è
che ogni nodo che non è stato trovato non è raggiungibile.
Una prova: disegna un cerchio attorno ai nodi del grafico G che sono stati trovati.
Se non ci sono bordi che vanno dall'interno del cerchio all'esterno del cerchio, non ci sono percorsi da s ai nodi all'esterno del cerchio.Quindi, possiamo
afferma che abbiamo trovato tutti i nodi raggiunti da s.Come facciamo a sapere che questo
Circle non ha bordi che lo lasciano?Considera un nodo U nel cerchio.Perché sei stato
Trovato e trovato inNothandled = ∅, sappiamo che anche U è stato gestito.Dal
Loop invariant li2, se ⟨u, v⟩is un bordo, allora è stato trovato e quindi è nel
cerchia anche.Quindi, se u è nel cerchio e ⟨u, v⟩is un bordo, allora V è nel cerchio
Inoltre (cioè nessun borgo lascia il cerchio).
Proprietà di chiusura: questa è nota come proprietà di chiusura.Vedere la sezione 18.3.3 per ulteriori informazioni
informazioni su questa proprietà.
Un'altra prova: prova per contraddizione.
Supponiamo che W sia raggiungibile da S e che W non sia stato trovato.Prendere in considerazione
un percorso da s a w.Perché S è stato trovato e W no, il percorso inizia
L'insieme di nodi trovati e ad un certo punto lo lascia.Lascia che ⟨u, sia il primo bordo
Il percorso per il quale U ma non V è stato trovato.Perché sei stato trovato e
FoundNothandled = ∅, ne consegue che sei stato gestito.Perché sei stato
gestito, v deve essere trovato.Ciò contraddice la definizione di V.
Tempo di esecuzione:
Un argomento semplice ma falso: per ogni iterazione del ciclo, viene gestito un nodo e nessun nodo viene gestito più di una volta.Quindi, la misura del progresso
(Il numero di nodi gestiti) aumenta di uno con ogni ciclo.G ha solo
| V |= n nodi.Quindi, l'algoritmo loop al massimo n.Quindi, la corsa
Il tempo è O (n).
Questo argomento è falso, perché durante la gestione di u dobbiamo considerare V per ogni bordo che esce da te.
Ovestimation: ogni nodo ha al massimo i bordi che ne usciranno.Quindi, il tempo di esecuzione è O (N2).
Complessità corretta: ogni bordo di G viene esaminato esattamente due volte, una volta da ciascuno
direzione.Il tempo dell'algoritmo è dominato da questo fatto.Quindi, il tempo di esecuzione
è O (| e |), dove E è l'insieme dei bordi in G.

---
layout: 
title: Pagina 194
level: 3
---


Problemi di ottimizzazione
178
L'ordine di gestione dei nodi: questo algoritmo non ha indicato quale non indicava quale
Node U per selezionare da fondati.Non aveva bisogno, perché l'algoritmo
Funziona, non importa come è fatta questa scelta.Considereremo ora gli ordini specifici
che gestire i nodi e specifiche applicazioni di questi ordini.
Coda (prima ricerca): un'opzione è quella di gestire i nodi nell'ordine in cui sono
si trovano in. Questo trattano i trafficati come una coda: "Prima in primo piano."IL
L'effetto è che la ricerca è di larghezza, il che significa che tutti i nodi alla distanza 1 da
S vengono gestiti per la prima volta, quindi tutti quelli alla distanza 2 e così via.Un sottoprodotto di questo è
che troviamo per ciascun nodo V un percorso più breve da S a v. Vedi la sezione 14.2.
Percorsi prioritari code (più brevi (ponderati)): un'altra opzione calcola per ciascuno
Il nodo V in fondato non ha la distanza minima ponderata da S a V lungo
Qualsiasi percorso visto finora.Quindi gestisce il nodo più vicino a s
a questa approssimazione.Poiché queste approssimazioni cambiano nel tempo, FoundNothandled viene implementata utilizzando una coda di priorità: "Priorità più alta attuale per la prima volta".Come la prima ricerca in larghezza, la ricerca gestisce i nodi più vicini
per primo, ma ora la lunghezza di un percorso è la somma dei suoi pesi.Un sottoprodotto
di questo metodo è che troviamo per ciascun nodo v il percorso ponderato più breve da s
a v. Vedi Sezione 14.3.
Stack (ricerca profondità): un'altra opzione è quella di gestire il nodo che è stato trovato
più recentemente.Questo metodo si tratta di fondato come uno stack: "Ultimo, prima".
L'effetto è che la ricerca è di profondità, il che significa che un percorso particolare è seguito il più profondamente possibile nel grafico fino a raggiungere un vicolo cieco, forzando
L'algoritmo per tornare indietro.Vedere la sezione 14.4.
ESERCIZIO
14.1.1
Prova a cercare il seguente grafico usando la coda (prima
Ricerca), coda prioritaria (percorsi più brevi (ponderati)) e stack (prima ricerca).
1
1
1
5
5
1
4
2
1
6
3
7
5
UN
B
C
D
e
F
G
H
2
S
1

---
layout: 
title: Pagina 195
level: 3
---


Algoritmi di ricerca del grafico
179
14.2
Larghezza prima ricerca di percorsi più brevi
Ora svilupperemo un algoritmo per un problema di ottimizzazione chiamato il problema più breve.L'algoritmo utilizza una prima ricerca.Questo algoritmo è meno
versione generica dell'algoritmo nella sezione 14.1, perché l'ordine in cui i nodi
vengono gestiti è ora specificato in modo più preciso.Gli invarianti ad anello sono rafforzati in
per risolvere il problema con il percorso più corto.
Il problema con il percorso più corto (lavandino multiplo): in generale, il problema con il percorso più corto trova un percorso più breve tra un nodo di origine S e un nodo di lavandino T in un grafico G.
Qui, tuttavia, considereremo il caso in cui consideriamo contemporaneamente tutti i nodi
v per essere il lavandino.
Precondizionismo: ⟨G, S⟩consisti di un grafico G e un nodo di origine s.Il grafico G può
essere diretto o non indirizzato.
Postconditions: l'output è costituito da A d (v) e un π (v) per ciascun nodo di G.
ha le seguenti proprietà:
1. Per ciascun nodo V, d (v) fornisce la lunghezza Δ (s, v) del percorso più breve da s
a v.
2. L'albero di ricerca più corto o in larghezza è definito
Usando una funzione π come segue: s è la radice dell'albero.
π (V) è il genitore di V nell'albero.Per ogni nodo V, uno dei percorsi più brevi da S a V viene somministrato all'indietro, con v, π (v), π (π (v)), π (π (π (v))) ,..., S.Una definizione ricorsiva è che questo percorso più breve da S a V è
il percorso più breve dato da S a π (V), seguito dal
Edge ⟨π (V), V⟩.
π (
π (π (
π (π (π (
π (π (π (π (
s =
v
v)
v))
v)))
v)))
Un problema di ottimizzazione: la versione singola a singolo sink del problema con il percorso più corto può essere visualizzata come un problema di ottimizzazione.Vedi il capitolo 13.
Istanze: un'istanza ⟨g, s, t⟩consisti di un grafico e due nodi s e t.
Soluzioni ad esempio: una soluzione per l'istanza ⟨g, s, è un percorso π da s a t.
Misura del successo: la lunghezza (o il costo) di un percorso π è il numero di bordi in
il sentiero.
Obiettivo: data un'istanza ⟨g, s, t⟩, l'obiettivo è trovare una soluzione ottimale, cioè a
Path più breve da S a T in G.
Algoritmo di forza bruta: come spesso accade con problemi di ottimizzazione, il
Il numero di soluzioni per un'istanza potrebbe essere esponenziale.Noi non vogliamo
per controllarli tutti.

---
layout: 
title: Pagina 196
level: 3
---


Problemi di ottimizzazione
180
u
S
VK+1
Vk
Coda di fondati
Non trovato
Gestito
Figura 14.2: Albero di ricerca in larghezza: non possiamo supporre che il grafico sia un albero.Qui ho
Presentato solo i bordi degli alberi dati da π.La figura aiuta a spiegare l'invariante in loop, che mostra
quali nodi sono stati trovati, che hanno trovato ma non gestiti e che hanno gestito.
Dimostrare il percorso è più breve: per affermare che il percorso più breve da S a V è di
un po 'di lunghezza d (v), devi fare due cose:
Non oltre: è necessario produrre un percorso adatto di questa lunghezza.Chiamiamo questo percorso a
Testimone del fatto che la distanza da S a V è al massimo D (V).Intorno a un nodo, tracciamo un percorso da S ad esso.Se abbiamo già rintracciato un percorso più breve da
s to u con d (u) bordi in esso e tracciamo un bordo da u a v, quindi abbiamo rintracciato
Un percorso da S a V con d (v) = d (u) + 1 bordi in esso.In questo percorso da s a v, il
Il nodo precedente v è π (v) = u.
Non più vicino: devi dimostrare che non ci sono percorsi più brevi.Questo è più difficile.Altro
che controllare un numero esponenziale di percorsi, come puoi dimostrare che ci siano
Nessun percorso più breve?Lo faremo usando il seguente trucco: supponiamo di poterlo fare
che l'ordine in cui troviamo i nodi è in base alla lunghezza del più breve
percorso da s a loro.Quindi, quando ci troviamo, sappiamo che non esiste un percorso più breve
Ad esso, altrimenti l'avremmo già trovato.
Definizione di V J: Lascia che VJ indicasse l'insieme di nodi a distanza j da s.
Il ciclo invariante: vedi Figura 14.2.
Li1: Per ogni nodo trovato V, i valori di D (V) e π (V) sono come richiesti, cioè danno la lunghezza più breve e un percorso più breve da S al nodo.
LI2: Se è stato gestito un nodo, allora tutti i suoi vicini sono stati trovati.
Li3: Finora, l'ordine in cui sono stati trovati i nodi è secondo il
lunghezza del percorso più breve da s ad esso, cioè i nodi in VJ prima di quelli in
VJ+1.
Ordine in cui gestire i nodi: l'unico modo in cui stiamo cambiando il
L'algoritmo di ricerca generico della sezione 14.1 è più attento nella nostra scelta di cui

---
layout: 
title: Pagina 197
level: 3
---


Algoritmi di ricerca del grafico
181
1
1,2
1,2,3
1,2,3,4
1,2,3,4,5
1,2,3,4,5,6,7,8,9
{1}
S
1
2
3
4
5
6
7
8
9
d = 1
d = 2
d = 0
Gestito
{2,3,4,5}
{3,4,5,6,7}
{4,5,6,7}
{5,6,7,8}
{6,7,8,9}
{Coda}
Figura 14.3: prima ricerca di un grafico.I numeri mostrano l'ordine in cui i nodi
furono trovati.I contenuti della coda sono riportati ad ogni passaggio.I bordi degli alberi sono oscurati.
nodo da fondato innovando per gestire successivamente.Secondo Li3, i nodi che erano
Trovati in precedenza sono più vicini a S rispetto a quelli che si trovano in seguito.Più un nodo più vicino è
s, più sono i suoi vicini.Quindi, nel tentativo di trovare nodi vicini, l'algoritmo gestirà successivamente il primo nodo trovato.Questo si ottiene trattando il
SET è stato fondato come una coda, "prima in primo luogo."
Esempio: vedere la Figura 14.3.
Corpo del ciclo: rimuovere il primo nodo U dalla coda fondata e
Gestiscilo come segue.Per ogni vicino V di u che non è stato trovato, r aggiungi il nodo alla coda, r let d (v) = d (u) + 1, r let π (v) = u e
R considera di essere gestito e v sei in fondato.
Codice:
Algoritmo ShortestPath (G, S)
⟨Pre-Cond⟩: G è un grafico (diretto o non indirizzato) e S è uno dei suoi nodi.
⟨Post-Cond⟩: π specifica un percorso più breve da s a ciascun nodo di g e d specifica
le loro lunghezze.
inizio
FODDHANDLED = ∅
FoundNotHandled = {s}
d (s) = 0, π (s) = ϵ
ciclo continuo
⟨Loop-invariant⟩: vedi sopra.
uscita quando è stato fondato = ∅
Lascia che tu sia il nodo nella parte anteriore della coda fondata
Per ogni V collegato a u
Se V non è stato precedentemente trovato allora
Aggiungi V a FoundNothandled

---
layout: 
title: Pagina 198
level: 3
---


Problemi di ottimizzazione
182
d (v) = d (u) + 1
π (v) = u
finisci se
fine per
spostati da fondati a base di fondi
End Loop
(per V, D (V) = ∞)
restituire ⟨d, π⟩
Algoritmo di fine
Mantenimento dell'invariante in loop (⟨li′⟩ & non ⟨exit⟩ & codeloop → ⟨li′′⟩): supponiamo che li ′ (la dichiarazione dell'invariante invariante prima dell'iterazione) sia vera, la condizione di uscita non èe abbiamo eseguito un'altra iterazione del
algoritmo.
Sono già stati trovati nodi più vicini: avremo bisogno della seguente richiesta due volte.
Reclamo: se il primo nodo nella coda fondata, cioè u è in vk, allora
1. Tutti i nodi in v0, v1, v2, ..., vk - 1 sono già stati trovati e gestiti, e
2. Tutti i nodi in VK sono già stati trovati.
Prova della parte 1 di reclamo: che u ′ denota qualsiasi nodo in v0, v1, v2, ..., vk - 1.Perché Li3 ′ garantisce che i nodi siano stati trovati nell'ordine della loro distanza
e poiché u ′ è più vicino a s rispetto a u, u ′ deve essere stato trovato prima di u.
Quindi, u ′ non può essere nella coda fondata, altrimenti sarebbe prima nella coda di te, eppure u è prima.Ciò dimostra che U ′ è stato gestito.
Prova della parte 2 di reclamo: considera qualsiasi nodo V in vk e qualsiasi percorso di lunghezza k
ad esso.Sia u ′ il nodo precedente in questo percorso.Perché il sottofondo a U ′ è di
La lunghezza K −1, U ′ è in VK - 1, e quindi dalla rivendicazione 1 è già stata gestita.
Pertanto, per li2 ′, i vicini di u ′, di cui V è uno, devono essere stati
trovato.
Mantenendo LI1: durante questa iterazione, tutti i vicini v del nodo U non lo avevano fatto
sono stati trovati ora ritenuti trovati.Quindi, il loro d (v) e π (v) devono ora dare
la lunghezza più breve e un percorso più breve da s.Il codice imposta D (v) su d (u) + 1 e
π (v) a u.Quindi, dobbiamo dimostrare che i vicini V sono in VK+1.
Non oltre: c'è un percorso da S a V di lunghezza k + 1: seguire il percorso di
lunghezza da k a u, e poi prendi il bordo per v. Quindi, il percorso più breve verso V può
non essere più questo.

---
layout: 
title: Pagina 199
level: 3
---


Algoritmi di ricerca del grafico
183
Non più vicino: sappiamo che non esiste un percorso più breve per V, o sarebbe stato
già trovato.Più formalmente, l'affermazione afferma che tutti i nodi in V0, V1, V2, ..., VK sono già stati trovati.Perché V non è già stato trovato, questo
non può essere uno di questi.
Mantenimento di Li2: il nodo U è designato gestito solo dopo aver assicurato che tutto il suo
I vicini sono stati trovati.
Mantenimento di LI3: secondo l'affermazione, tutti i nodi in V0, V1, V2, ..., VK hanno già
sono stati trovati e quindi sono già stati aggiunti alla coda.Abbiamo anche già dimostrato che il nodo V trovato è in VK+1.Ne consegue che l'ordine in
che i nodi si trovano continua a essere in base alla loro distanza da s.
Codice iniziale (⟨pre⟩ → ⟨li⟩): il codice iniziale mette la sorgente S in fondi e fondati
e imposta d (s) = 0 e π (s) = ϵ.Questo è corretto, dato che inizialmente è stato trovato ma
non gestito.Gli altri nodi non sono stati trovati, e quindi i loro d (v) e π (v) sono
irrilevante.Gli invarianti ad anello seguono facilmente.
ESCIPE LOOP (⟨li⟩ & ⟨exit⟩ → ⟨post⟩): le postcondizioni di ricerca generale da
La sezione 14.1 dimostra che sono stati trovati tutti i nodi raggiungibili.Li1 lo afferma per questi
nodi I valori di d (v) e π (v) sono come richiesti.
Per i nodi irraggiungibili da S, è possibile impostare d (v) = ∞or che puoi lasciare
loro non finanziati.In alcune applicazioni (come il World Wide Web), non hai
Accesso a nodi irraggiungibili.Un vantaggio di questo algoritmo è che non deve mai
Conosci un nodo a meno che non sia stato trovato.
Esercizio 14.2.1 (vedi soluzione nella parte cinque.) Supponiamo che U sia gestito, u ∈Vk e
V è un vicino di u.Per ciascuno dei seguenti casi, spiega in quale vk ′ V potrebbe essere in:
r ⟨u, v⟩is un bordo non indirizzato e V è stato trovato in precedenza.
r ⟨u, v⟩is un bordo non orientato e V non è stato trovato prima.
r ⟨u, v⟩is a bordo diretto e v è stato trovato in precedenza.
r ⟨u, v⟩is a bordo diretto e v non è stato trovato prima.
Esercizio 14.2.2 (vedere la soluzione nella parte quinta.) Stimare il tempo necessario per trovare il
Percorso più breve tra due nodi dati s e t.
14.3
L'algoritmo di percorso più corto di Dijkstra
Ora renderemo il problema più breve più generale permettendo ogni bordo
per avere un peso diverso (lunghezza).La lunghezza di un percorso da S a V sarà la somma
dei pesi sui bordi del percorso.Questo rende il problema più difficile, perché
Il percorso più breve verso un nodo può avviarsi in profondità nel grafico lungo molti bordi corti
Invece di alcuni bordi lunghi.Nonostante ciò, è necessario apportare solo piccole modifiche
All'algoritmo.Il nuovo algoritmo si chiama Algoritmo di Dijkstra.

---
layout: 
title: Pagina 200
level: 3
---


Problemi di ottimizzazione
184
1
1
1
100
Nodo: ordine trovato, ordine gestito
V: 2,4
U: 4,3
T: 3,2
S: 1,1
Figura 14.4: l'algoritmo percorsi più brevi gestisce i nodi
nell'ordine di lunghezza del percorso più breve per loro.
Specificazioni del problema con il percorso più corto:
Precondizioni: l'input è un grafico G (diretto o non indirizzato) e a
nodo di origine s.Ogni bordo ⟨u, V⟩is ha assegnato un peso non negativo W⟨u, v⟩.
Postconditions: l'output è costituito da d e π, dove per ciascun nodo V di g, d (v)
dà la lunghezza Δ (s, v) del percorso ponderato più corto da s a v e π definizione a
albero percorso più corto.(Vedi Sezione 14.2.)
Dimostrare il percorso è più breve: come prima, dimostrando che il percorso più breve da S a V è di
un po 'di lunghezza d (v) prevede la produzione di un percorso adatto di questa lunghezza e lo dimostra
Non ci sono percorsi più brevi.
Non oltre: come prima, un testimone che esiste un tale percorso è prodotto da Tracing
esso.L'unico cambiamento è che quando troviamo un percorso s -
→ U → V, calcoliamo
lunghezza da essere d (v) = d (u) + w⟨u, v⟩instead di solo d (v) = d (u) + 1.
Non più vicino: a differenza dell'algoritmo per la prima ricerca di larghezza dalla sezione 14.2, l'algoritmo non trova i nodi nell'ordine di lunghezza
Percorso più breve per loro da s.Tuttavia, gestisce i nodi in questo ordine.
Vedi Figura 14.4.Per questo motivo, quando gestiamo un nodo, sappiamo che c'è
Nessun percorso più breve, perché altrimenti l'avremmo già gestito.
Il nodo successivo da gestire: l'algoritmo deve scegliere quale non manovra
nodi da gestire dopo.La difficoltà è che inizialmente non conosciamo la lunghezza del
Path più breve.Invece, scegliamo il nodo più vicino a S in base alla nostra attuale approssimazione.Nella Figura 14.4, dopo aver maneggiato la nostra migliore approssimazione della distanza
a v è 100 e a t è solo 1. Quindi, gestiamo T successiva.
Un criterio avido adattivo: questa scelta equivale a un criterio avido adattivo.Vedi il capitolo 16 per ulteriori informazioni su algoritmi avidi.
Crescere un albero un nodo alla volta: si scopre che il nodo successivo da gestire sarà sempre solo un bordo da un nodo gestito in precedenza.Quindi il
L'albero dei nodi gestiti si espande, un nodo alla volta.

---
layout: 
title: Pagina 201
level: 3
---


Algoritmi di ricerca del grafico
185
(UN)
P'
u
Un percorso gestito per u
Un percorso potenzialmente più corto per u
<
<
<P ′
u
d (u)
d (u ′)
| P |
Nodi gestiti
u ′
u
S
P
(B)
Caso 1: | P | = D ′ (V)
Caso 2: | p | = d ′ (u)+w (u, v)
Nodi gestiti
u
S
u ′
v
La Figura 14.5: (a) mostra un percorso gestito verso il nodo U e viene utilizzato per mantenere LI1.(b) è usato
mantenere Li2.
Approssimazione delle distanze più brevi: per ogni nodo V, prima di ottenere la distanza complessiva più breve, manterremo D (V) e π (V) come lunghezza e percorso più corti
Da S a V da quei percorsi che abbiamo gestito finora.
Aggiornamento: queste informazioni vengono continuamente aggiornate mentre troviamo percorsi più brevi a
v. Ad esempio, se troviamo V quando ci maneggiamo, allora aggiorniamo questi valori come
segue:
FundPathLength = d (u) + w⟨u, v⟩
Se d (v)> fondatPathLength quindi
d (v) = fondathLength
π (v) = u
finisci se
S
u
(u, v)
(u, v)
Nuovo percorso di lunghezza d (u) + w
w
Percorso precedente di lunghezza D (V)
v
(v)
π
Quando si maneggiano S nel nostro esempio, D (V) è impostato su D (S) + W⟨S, V⟩ = 0 + 100 = 100.
Più tardi, durante la gestione di U, viene aggiornato a d (u) + w⟨u, v⟩ = 2 + 1 = 3.
Definizione di un percorso gestito: diciamo che è stato gestito un percorso se contiene
solo i bordi gestiti.Tali percorsi iniziano da s, visitano come un numero qualsiasi di nodi gestiti, quindi seguono un ultimo bordo su un nodo che può o meno essere gestito.(Vedi il
Percorso solido a U in Figura 14.5.a.)
Coda di priorità: il nodo successivo da gestire è quello con il più piccolo d (u)
valore.Cerca l'insieme di nodi non gestiti per questo nodo durante ogni iterazione
sarebbe troppo dispendioso in termini di tempo.Riempire i nodi ogni iterazione come d (u)
La variazione dei valori sarebbe anche troppo dispendiosa.Un'implementazione più efficace utilizza una coda prioritaria per tenere la priorità dei nodi non gestiti
al loro valore d (u) attuale.Questo può essere implementato utilizzando un heap.(Vedi la Sezione 10.4.) Diretteremo questa coda prioritaria da non manodro.
Considera tutti i nodi "trovati": nessun percorso è stato ancora gestito a nessun nodo che
non è stato ancora trovato, e quindi d (v) = ∞.Se aggiungiamo questi nodi alla coda, saranno selezionati per ultimo.Pertanto, non vi è alcun danno nell'aggiuntarli.Quindi, noi
distinguerà solo tra quei nodi che sono stati gestiti e quelli che
non aver.

---
layout: 
title: Pagina 202
level: 3
---


Problemi di ottimizzazione
186
Il ciclo invariante:
Li1: Per ogni nodo gestito V, i valori di d (v) e π (v) danno la lunghezza più breve
e un percorso più breve da S (e questo percorso contiene solo nodi gestiti).
Li2: per ciascuno dei nodi non gestiti V, i valori di d (v) e π (v) danno il
La lunghezza e il percorso più corti tra quei percorsi che sono stati gestiti.
Corpo del ciclo: prendi il nodo successivo U dalla coda prioritaria nothendled, e
occupatene.Ciò comporta la gestione di tutti i bordi ⟨u, v⟩out di u.Gestione del bordo ⟨u, v⟩
Comprende l'aggiornamento dei valori d (v) e π (v).Le priorità di questi nodi vengono modificate
Nella coda prioritaria se necessario.
Esempio: vedere la Figura 14.6.
Codice:
Algoritmo DijkstrashortestwededPath (G, S)
⟨Pre-conf⟩: G è un grafico ponderato (diretto o non indirizzato) e S è uno dei suoi
nodi.
⟨Post-Cond⟩: π specifica un percorso ponderato più breve da S a ciascun nodo di G, e
D specifica le loro lunghezze.
inizio
d (s) = 0, π (s) = ϵ
per altri v, d (v) = ∞ e π (v) = nil
gestito = ∅
nothandled = coda prioritaria contenente tutti i nodi.Priorità donate da D (V).
ciclo continuo
⟨Loop-invariant⟩: vedi sopra.
Esci quando non hamped = ∅
Lascia che tu sia un nodo da not -gesto con più piccolo d (u)
Per ogni V collegato a u
FundPathLength = d (u) + w⟨u, v⟩
Se d (v)> fondatPathLength quindi
d (v) = fondathLength
π (v) = u
(Aggiorna la coda di priorità nothandled)
finisci se
fine per
Spostati da nothedled a gestiti
End Loop
restituire ⟨d, π⟩
Algoritmo di fine
Mantenimento di Li1 (⟨li1 ′, li2′⟩ e non ⟨exit⟩ & codeloop → ⟨li1′⟩): il ciclo gestisce un nodo U con d (u) più piccolo da nothandled.Quindi per mantenere LI1, dobbiamo
Assicurarsi che i suoi valori d (u) e π (u) diano un percorso più breve complessivo a u.Considera un po '

---
layout: 
title: Pagina 203
level: 3
---


Algoritmi di ricerca del grafico
187
Altro percorso p a u.Vedremo che non è più breve.Vedi Figura 14.5.A.Perché il
Il percorso P inizia dal nodo gestito s e termina al nodo U precedentemente non gestito, deve esserci un nodo U ′ che è il primo nodo precedentemente non gestito lungo P.
(È possibile cheu ′ = u.) Con la scelta di, u ha il più piccolo d (u) da nothandled.
Quindi, d (u) ≤d (u ′).Lascia che pu ′ sia la parte il percorso che va da s a u ′.Questo è un percorso precedentemente gestito.Quindi, per li2 ′, d (u ′) ≤ | pu ′ |.Dal momento che | Pu ′ |è un sottofondo e lì
non sono pesi negativi, | pu ′ |≤ | p |.Combinando questi dà d (u) ≤ | p |.In conclusione, D (U) è la lunghezza del percorso più breve per U e quindi è stato mantenuto Li1.
Mantenendo Li2 (⟨li1 ′, li2′⟩ & non ⟨exit⟩ & codeloop → ⟨li2′′⟩): impostazione da d ′ ′ (v) a
min {d ′ (v), d ′ (u) + w⟨u, v⟩} assicura che ci sia un percorso maneggiato con questa lunghezza a v.
mantenere Li2, dobbiamo dimostrare che non esiste uno più breve tra quelli
Percorsi che ora sono considerati gestiti.Tali percorsi possono ora includere il nodo appena gestito U.Lascia che p sia più corto.Vedi Figura 14.5.b.Sia u ′ il secondo ultimo nodo
In P. Poiché P è un percorso gestito, U ′ deve essere un nodo maneggiato.Ci sono due casi:
u ̸ = u ′: se u ′ è un nodo precedentemente gestito, quindi dalla seconda parte di li1 ′, il
Il percorso più breve non è necessario contenere il nodo appena gestito U.Segue
che questo percorso da P a V è un percorso precedentemente consegnato.Quindi, la sua lunghezza è almeno il
Lunghezza del percorso più corto in precedenza a V, che per Li2 ′ è d ′ (V).Questo in
Il turno è almeno min {d ′ (v), d ′ (u) + w⟨u, v⟩} = d ′ ′ (v).
u = u ′: se il secondo ultimo nodo in p è il nodo appena gestito U, allora la sua lunghezza
è la lunghezza del percorso più breve per u, che ora sappiamo è d ′ (u), più il
Peso del bordo ⟨u, v⟩.Ne consegue che | p |≥Min {d ′ (v), d ′ (u) + w⟨u, v⟩} = d ′ ′ (v).
Ad ogni modo, il percorso più corto da P a V che ora è considerato gestito ha una lunghezza
Almeno D ′ ′ (V).Quindi, Li2 è mantenuto.
Codice iniziale (⟨pre⟩ → ⟨li⟩): il codice iniziale è lo stesso di quello per la prima larghezza
Cerca algoritmo per il percorso più corto dalla sezione 14.2, cioè s si trova ma non gestito
con d (s) = 0, π (s) = ϵ.Inizialmente non sono stati gestiti percorsi per V, e quindi il
io
J
io
0
J
C
e
F
UN
B
G
1
1
1
1
5
5
1
4
2
1
6
3
7
5
UN
B
C
D
e
F
G
H
2
io
UN
B
C
D
e
F
G
H
valori d
Gestito
H
S
6
5
5
2
3
4
5
6
7
8
8
S
D
5
S
8
24
28
27
34
20
16
24
15 25
21
16
13
24
0
28
15
27
valori d
Gestito
UN
D
F
B
e
G
H
H
G
F
e
D
C
B
UN
C
UN
B
C
D
e
F
G
H
24
18
2
7
6
4
15
9
8
8
8
4
13
3
12
1
J
Figura 14.6: Algoritmo di Dijkstra.Il valore D ad ogni passaggio è dato per ciascun nodo.L'albero
I bordi sono oscurati.

---
layout: 
title: Pagina 204
level: 3
---


Problemi di ottimizzazione
188
La lunghezza del percorso gestito più corto verso V è d (v) = ∞.Questo soddisfa tutti e tre
invarianti.
ESCIPE LOOP (⟨li⟩ & ⟨exit⟩ → ⟨post⟩): vedere l'algoritmo più corto.
Esercizio 14.3.1 Stimare il tempo di esecuzione dell'algoritmo per il percorso più basso di Dijkstra.
Esercizio 14.3.2 (vedere la soluzione nella parte cinque.) Dato un grafico in cui ogni peso del bordo è
uno, confronta e confronta il calcolo della prima ricerca per il percorso più corto
Algoritmo dalla sezione 14.2 e quello dell'algoritmo di percorso più corto di Dijkstra.
Come si confrontano le loro scelte del nodo successivo e i loro invarianti ad anello?
Esercizio 14.3.3 Algoritmo di Dijkstra:
1.
Dai invariante il ciclo completo per l'algoritmo di Dijkstra.Includere la definizione di qualsiasi
Termini che usi.
2.
Qual è la condizione di uscita per l'algoritmo di Dijkstra?
3.
Dimostrare che si ottiene la postconditura.
4.
Considera un calcolo dell'algoritmo di Dijkstra sul grafico seguente quando il
I nodi cerchi sono stati gestiti.Il nodo iniziale è a.A sinistra, dai la corrente
valori di d.
d =
d =
d =
d =
d =
d =
UN
B
C
D
e
H
24
18
2
7
8
8
4
13
3
Gestito
d =
d =
d =
d =
d =
d =
UN
B
C
D
e
H
24
18
2
7
8
8
4
13
3
Gestito
5.
A destra, cambia la figura per fare un passo nell'algoritmo di Dijkstra.Includere come
Bene, qualsiasi π cambia.
Esercizio 14.3.4
Dai un grafico semplice con un bordo con un peso negativo e mostra
Quell'algoritmo di Dijkstra dà la risposta sbagliata.
14.4
Ricerca profondità
Abbiamo considerato la prima ricerca in largo, che visita la prima distanza alla distanza 1 da S, quindi quelli a distanza 2 e così via.Considereremo ora una prima ricerca di profondità, che

---
layout: 
title: Pagina 205
level: 3
---


Algoritmi di ricerca del grafico
189
S
(UN)
(B)
(C)
S
Il percorso è stack di tuple
Trovato: gestito in parti
Non trovato
Gestito
S
Figura 14.7: se il nodo successivo nello stack è stato completamente gestito, allora l'ordine iniziale in
quali nodi vengono trovati in (a).Se il nodo successivo viene gestito solo parzialmente, allora questa iniziale
L'ordine è riportato in (b).(c) presenta più dell'ordine in cui vengono trovati i nodi.Sebbene il
Il grafico di input potrebbe non essere un albero, la figura mostra solo i bordi dell'albero forniti da π.
continua a seguire un percorso il più profondamente possibile nel grafico prima che venga forzato
per tornare indietro.Do un algoritmo iterativo in questa sezione e ricorsivo nella sezione 14.5.
Modifiche all'algoritmo di ricerca generico nella sezione 14.1: il nodo successivo U
Gestiamo è quello che è stato trovato più recentemente.verrà implementato FoundNothandled
Come una pila di tuple ⟨v, iv⟩.Ad ogni iterazione, facciamo spingere la tupla spinta
⟨U, iu⟩ e gestire il bordo (iu + 1) St da u.Provalo su un grafico (o su un albero).IL
modello in cui i nodi si trovano è costituito da un singolo percorso con bordi singoli sospesi
fuori.Vedi Figura 14.7.
Al fine di evitare che i singoli bordi si appengano dal percorso, noi
apportare una seconda modifica all'algoritmo di ricerca originale: non abbiamo più completamente
Gestire un nodo prima di iniziare a gestire i bordi da altri nodi.Da s, un bordo
è seguito a uno dei suoi vicini V1.Prima di visitare gli altri vicini di S, il
Il percorso di corrente di V1 viene esteso a V2, V3 ,....(Vedi Figura 14.7.b.) Teniamo traccia di cosa
è stato gestito conservando un numero intero IU per ogni nodo u.Lo manteniamo per ciascuno
U, i primi bordi di te sono già stati gestiti.
Invarianti ad anello:
Li1: i nodi nella pila fondati non sono ordinati in modo che definiscano a
Percorso a partire da s.
Li2: FoundNothandled è una pila di tuple ⟨v, ivsuch that per ogni v, il primo IV
I bordi di V sono stati gestiti.Ogni nodo V non appare più di una volta.
Codice:
Algoritmo DepthFirstSearch (G, S)
⟨Pre-Cond⟩: G è un (diretto o non indirizzato), grafico e S è uno dei suoi nodi.
⟨Post-Cond⟩: l'output è un albero di ricerca di profondità di G radicato a s.

---
layout: 
title: Pagina 206
level: 3
---


Problemi di ottimizzazione
190
inizio
FODDHANDLED = ∅
FoundNotHandled = {⟨s, 0⟩}
tempo = 0 % utilizzato per il timestamp.Vedi la discussione seguente.
ciclo continuo
⟨Loop-Invariant⟩: vedi elenco precedenti.
uscita quando è stato fondato = ∅
pop ⟨u, ho lo stack fondato
Se hai un (i+1) St Edge ⟨u, v⟩
Push ⟨u, i + 1⟩onto FoundNothandled
Se V non è stato precedentemente trovato allora
π (v) = u
⟨U, è un bordo dell'albero
Push ⟨v, 0⟩onto FoundNothandled
s (v) = tempo;tempo = tempo + 1
altro se v è stato trovato ma non completamente gestito allora
⟨U, è un bordo posteriore
altro (V è stato completamente gestito)
⟨U, è un attaccante o un bordo incrociato
finisci se
altro
Spostati su Fund -Handled
f (v) = tempo;tempo = tempo + 1
finisci se
End Loop
Restituisce Fund -Handled
Algoritmo di fine
Esempio: vedere la Figura 14.8.
Stabilire e mantenere l'invariante del loop: è facile vederlo con
FoundNothandled = {⟨s, 0⟩}, viene stabilito l'invariante Loop.Se lo stack contiene un percorso da s a u e u ha un bordo non gestito a v, allora è mantenuto sullo stack
e V viene spinto in cima.Questo estende il percorso da u in poi a v. Se non hai
Un bordo non manipolato, quindi U viene messo fuori dallo stack.Questo riduce il percorso da s da
uno.
Classificazione dei bordi: l'algoritmo di ricerca di profondità può essere utilizzato per classificare
bordi:
Bordi ad albero: i bordi degli alberi sono i bordi ⟨u, contro il primo albero di ricerca.Quando
Tali bordi vengono gestiti, V non è stato ancora trovato.
Bordi: bordi posteriori sono i bordi ⟨u, v⟩such che v è un antenato di u nel
Primo albero di ricerca.Quando tali bordi vengono gestiti, V è nello stack, cioè trovato ma non completamente gestito.

---
layout: 
title: Pagina 207
level: 3
---


Algoritmi di ricerca del grafico
191
Bordi
Bordi in avanti
Bordi incrociati
Bordi degli alberi
Tipi di bordi
2
9
7
8
6
5
4
3
Cornici di stack ricorsivi
Grafico
s = 1
Algoritmo iterativo
9
S
8
7
6
1
5
4
3
2
Gestito
6,5,4,3
6,5,4,3
6,5,4,3,8,7
6,5,4,3,8,7
6,5, 4,3,8, 7,9,2,1
Pila
{s = 1}
{1,2,3,4,5,6}
{1,2}
{1,2,7,8}
{1,2}
{1,2,9}
Figura 14.8: prima ricerca di un grafico.I numeri danno l'ordine in cui sono i nodi
trovato.Il contenuto dello stack è riportato ad ogni passaggio.
Cyclic: un grafico è ciclico se e solo se ha un bordo posteriore.
Prova (⇐): L'anello invariante dell'algoritmo di ricerca di profondità garantisce che il contenuto dello stack formino un percorso da S a V e avanti
a te.Aggiungendo sul bordo ⟨u, V⟩ crea un ciclo di ritorno a v.
Prova (⇒): in seguito dimostriamo che se il grafico non ha bordi posteriori, allora lì
è un ordinamento totale dei nodi che rispettano i bordi e quindi il grafico ha
Nessun ciclo.
Bipartito: un grafico è bipartito se e solo se non c'è bordo posteriore tra
Eventuali due nodi con la stessa parità di livello, cioè se non ha una lunghezza dispari
cicli.
Bordi in avanti e bordi incrociati: i bordi in avanti sono bordi ⟨u, v⟩such che v è un
discendente di u nell'albero di ricerca di profondità.
Bordi incrociati ⟨u, se non si trovano in diversi rami dell'albero di ricerca di profondità (cioè non sono né antenati né discendenti l'uno dell'altro)
Il ramo di V è attraversato prima (a sinistra del ramo di U).
Quando vengono gestiti i bordi in avanti e i bordi incrociati, V è stato completamente
gestito.L'algoritmo di ricerca per la profondità non si distingue tra l'attaccante
bordi e bordi incrociati.
Time Stamping: alcune implementazioni di profondità di ricerca di tempo ciascuno
Node U con un tempo di inizio s (u) e un tempo finale f (u).Qui il tempo viene misurato iniziando
un contatore a zero e aumentalo ogni volta che un nodo viene trovato per la prima volta

---
layout: 
title: Pagina 208
level: 3
---


Problemi di ottimizzazione
192
o un nodo è completamente gestito.s (u) è il tempo in cui il nodo u viene trovato prima e
F (u) è il momento in cui è completamente gestito.I timestamp sono utili in
seguente:
r v è un discendente di u se e solo se l'intervallo di tempo [s (v), f (v)] è completamente
contenuto in [s (u), f (u)].
r Se u e v non sono né antenati né discendenti l'uno dell'altro, allora gli intervalli di tempo [s (u), f (u)] e [s (v), f (v)] sono completamente disgiunti.
Usando i timestamp, questo può essere determinato in tempo costante.
Esercizio 14.4.1 Dimostra che quando si esegue la prima ricerca su grafici non diretti lì
non sono mai spigoli in avanti o incrociato.
14.5
Ricucita di profondità-prima
Ora presento un'implementazione ricorsiva di un algoritmo di ricerca di profondità, che
rispecchia direttamente la versione iterativa.L'unica differenza è che la versione iterativa
Utilizza uno stack per tenere traccia del percorso sul nodo iniziale, mentre il ricorsivo
La versione utilizza lo stack di frame stack ricorsivi.
Il vantaggio del ricorsivo
L'algoritmo è che è più facile da programmare e più facile da capire.L'algoritmo iterativo
potrebbe funzionare leggermente più velocemente, ma un buon compilatore convertirà l'algoritmo ricorsivo
in uno iterativo.
Codice:
algoritmo DepthFirstSearch (S)
⟨Pre-Cond⟩: Un'istanza di input è costituita da un grafico (diretto o non indirizzato) G
con alcuni dei suoi nodi contrassegnati e un nodo di origine s.
⟨Post-Cond⟩: l'uscita è lo stesso grafico G, tranne tutti i nodi V raggiungibili da
s senza passare attraverso un nodo precedentemente trovato è ora contrassegnato come essere
trovato.Il grafico G è un ADT variabile globale, che si presume sia entrambi input
e output alla routine.
inizio
Se S è contrassegnato come trovato, allora
fare niente
altro
Mark S come trovato
Per ogni V collegato a S
DepthFirstSearch (V)
fine per
finisci se
Algoritmo di fine

---
layout: 
title: Pagina 209
level: 3
---


Algoritmi di ricerca del grafico
193
S
v
u
UN
B
C
Grafico quando
Restituisce di routine
S
v
u
UN
B
C
S
v
u
UN
B
C
Esempio
Secondo amico
Terzo amico
Il nostro telaio dello stack
Primo amico
S = s
v
u
B
C
S
v
u
B
C
a = s
UN
S
v
u
UN
C
b = s
S
v
u
UN
B
c = s
Il nostro telaio dello stack
Invariato
Figura 14.9: un grafico di istanza di esempio.
Percorsi di potatura: considera il grafico di istanza nella Figura 14.9.Esistono due percorsi ovvi dal nodo S al nodo v. Tuttavia, in realtà esiste un numero in modo concreto di tali percorsi.Un percorso di interesse è quello che inizia da S e attraversa
intorno a U fino a C e poi fino a v. Tutti questi percorsi ugualmente apprezzati saranno
potato dalla considerazione, tranne quello che passa da S a B e U direttamente
a v.
Tre amici: dato questo istanza, segniamo il primo il nostro nodo di origine con una X, e
Quindi ricordiamo tre volte, una volta da ciascuno di A, B e C.
F Riend A: Il nostro primo amico segna tutti i nodi che sono raggiungibili dalla sua fonte
nodo a = s senza passare attraverso un nodo precedentemente contrassegnato.Ciò comprende
Solo i nodi nel ramo più a sinistra, perché quando abbiamo segnato la nostra fonte, abbiamo bloccato il suo percorso verso il resto del grafico.
F Riend B: Il nostro secondo amico fa lo stesso.Trova, ad esempio, il percorso che
va da b a u direttamente a v. trova anche e segna i nodi
intorno a c.
F Riend C: Il nostro terzo amico è di particolare interesse.Ripeta che il suo nodo di origine, C, è già stato contrassegnato.Quindi, ritorna senza fare nulla.Questo
Punes fuori dall'intero ramo dell'albero di ricorsione.Il motivo per cui può fare
Questo è quello per qualsiasi percorso a un nodo che considererebbe, un altro percorso verso il
Lo stesso nodo è già stato considerato.
Raggiungere il postcondizionismo: considera il componente del grafico raggiungibile
Dalla nostra fonte S senza passare attraverso un nodi precedentemente contrassegnati.(Perché il nostro
L'istanza non ha nodi contrassegnati, questo include tutti i nodi.) Per contrassegnare i nodi all'interno
Questo componente, facciamo quanto segue.Innanzitutto, segniamo la nostra fonte s.Queste partizioni
il nostro componente dei nodi raggiungibili in sottocomponenti che sono ancora raggiungibili

---
layout: 
title: Pagina 210
level: 3
---


Problemi di ottimizzazione
194
l'un l'altro.Ciascuno di questi sottocomponenti ha almeno un bordo da S in esso.Quando noi
Attraversare il primo vantaggio, l'amico segna tutti i nodi all'interno di questo sottocomponente.
Tempo di esecuzione: contrassegnare un nodo prima che venga ricorso da garantire che ogni nodo
è ricorso al massimo una volta.Il ricorso da un nodo implica attraversare ogni bordo
da.Quindi, ogni bordo viene attraversato al massimo due volte: una volta da ciascuna direzione.Quindi, il tempo di esecuzione è lineare nel numero di bordi.
Esercizio 14.5.1
Traccia l'algoritmo iterativo e ricorsivo sullo stesso
grafico e vedere come si confrontano.Hanno lo stesso tempo di esecuzione?
14.6
Ordine lineare di un ordine parziale
Trovare un ordine lineare coerente con un determinato ordine parziale è una delle tante applicazioni di una prima ricerca di profondità.(Suggerimento: se una domanda menziona mai che è diretto un grafico
aciclico, inizia sempre eseguendo questo algoritmo.)
Definizione dell'ordine totale: un ordine totale di un insieme di oggetti V specifica per ogni coppia
di oggetti u, v ∈ V (1) che u è prima di V o (2) che V è prima di u.Dev'essere
Transitivo, in quanto se sei prima di V e V è prima di W, allora U è prima di W.
Definizione dell'ordine parziale: un ordine parziale di un insieme di oggetti v fornisce solo alcuni
delle informazioni di un ordine totale.Per ogni coppia di oggetti u, v ∈V, specifica neanche
che è prima v, che v è prima di u, o che l'ordine di u e v è non finanziato.Deve
essere anche transitivo.
Ad esempio, devi indossare le mutande davanti ai pantaloni e devi
Metti le scarpe dopo i pantaloni e i calzini.Secondo la transitività, questo
significa che devi indossare la biancheria intima davanti alle scarpe.Tuttavia, hai
La libertà di mettere le mutande e le calze in entrambi gli ordini.Mio figlio, Josh, quando sei, ha scambiato questo ordine parziale per un ordine totale e si è rifiutato di indossare le calze
davanti alla sua biancheria intima.Quando aveva otto anni, mi ha spiegato che il motivo per cui lui
poteva vestirsi più velocemente di me che aveva un "collegamento", consistendo nel mettere il suo
calzini davanti ai pantaloni.Ero elettrizzato dal fatto che avesse almeno parzialmente compreso il
Idea di un ordine parziale:
biancheria intima
\
pantaloni
calzini
\
/
scarpe
Un ordine parziale può essere rappresentato da un grafico aciclico diretto (DAG) G. I vertici sono costituiti dagli oggetti V e dal bordo diretto ⟨u, v⟩indicati che è prima
v. segue dalla transitività che se esiste un percorso diretto in g da u a v, allora noi

---
layout: 
title: Pagina 211
level: 3
---


Algoritmi di ricerca del grafico
195
Sappi che è prima.Un ciclo in G fromu tov e posteriore tou presenta una contraddizione, perché non può essere sia prima che dopo v.
Specifiche del problema dell'ordinamento topologico:
Precondizioni: l'input è un grafico aciclico diretto G che rappresenta un parziale
ordine.
Postconditions: l'output è un ordine totale coerente con l'ordine parziale indicato
Per g, cioè per tutti i bordi ⟨u, v⟩∈G, u appare prima di V nell'ordine totale.
Un algoritmo facile ma lento:
L'algoritmo: inizia a qualsiasi nodo V di G. Se v ha un bordo in uscita, cammina lungo di esso
a uno dei suoi vicini.Continua a camminare fino a trovare un nodo T che non ha bordi in uscita.Un tale nodo è chiamato lavandino.Questo processo non può continuare per sempre, perché il grafico non ha cicli.
Il lavandino può andare dopo ogni nodo in G. Quindi, dovresti mettere l'ultimo nel
Ordine totale, elimina t da G e ripetere ricorsivamente il processo su g −v.
Tempo di esecuzione: ci vuole fino a n tempo per trovare il primo lavandino, n −1 per trovare il secondo e così via.Il tempo totale è (N2).
Algoritmo usando una ricerca profondità: inizia da qualsiasi nodo S di G. fare una profondità prima
Cerca a partire dal nodo s.Dopo aver completato questa ricerca, i nodi che vengono considerati
Trovato continuerà a essere considerati trovati e quindi non dovrebbe essere considerato più.
Sia S ′ qualsiasi nodo infallibile di G. fare una prima ricerca a partire dal nodo s ′.Ripetere
Il processo fino a quando non sono stati trovati tutti i nodi.
Usa il timestamp f (u) per tenere traccia dell'ordine in cui i nodi sono completamente
gestito, cioè rimosso dallo stack.Uscire i nodi in ordine inverso.
Se hai mai trovato un bordo posteriore, fermati e segnala che il grafico ha un ciclo.
Prova di correttezza:
Lemma: per ogni bordo ⟨u, v⟩of G, il nodo V è completamente gestito prima di u.
Prova del lemma: considera un po 'di bordo, v⟩of G. prima è completamente gestito, deve essere messo sulla pila fondata.A questo punto, ci sono tre casi:
Tree Edge: V non è stato ancora trovato.Perché hai un vantaggio a v, v è
Metti sulla parte superiore dello stack sopra di te prima che tu sia stato completamente gestito.Non verranno fatti più progressi nel gestire U fino a V non è stato
Completamente gestito e rimosso dallo stack.
Bordo posteriore: V è stato trovato, ma non completamente gestito, e quindi
è sullo stack da qualche parte sotto di u.Un tale bordo è un bordo posteriore.Questo
contraddice il fatto che G sia aciclico.

---
layout: 
title: Pagina 212
level: 3
---


Problemi di ottimizzazione
196
(Toplogical Ord) = A, H, B, C, I, J, K, D, E, F, L, G
Gestito
Pila
g, l, f, e, d, k, j, i, c, b, h, a
g, l, f, e, d, k, j, i, c, b
g, l, f, e, d, k, j, i, c, b
g, l, f, e, d, k, j, i
g, l, f, e, d, k, j, i
g, l, f, e, d, k, j, i
g, l, f, e, d
g, l, f, e, d
g, l, f, e, d
G
G
{}
{a, h}
{UN}
{a, b, c}
{UN}
{}
{i, j, k}
{io}
{}
{d, e, f, l}
{d, e, f}
{d, e, f, g}
{D}
G
e
D
B
H
l
K
J
io
F
C
UN
Figura 14.10: un tipo topologico si trova usando una prima ricerca.
Proprietà in avanti o cross: V è già stata completamente gestita e rimossa dallo stack.In questo caso, abbiamo finito: V è stato completamente gestito prima di te.
Topologicamente ordinato: Esercizio 14.6.1 chiede di dimostrare che questo lemma è sufficiente per dimostrare che l'ordine inverso in cui i nodi erano completamente
gestito è un tipo topologico corretto.
Esempio: vedere l'istanza di esempio nella Figura 14.10.
Tempo di esecuzione: come per la prima ricerca, nessun bordo è seguito più di
una volta.Quindi, il tempo totale è (| e |).
Percorso più breve su un DAG: supponiamo di voler trovare il percorso più basso per un grafico diretto G che sai è aciclico.Potresti usare l'algoritmo di Dijkstra dalla sezione 14.3.Tuttavia, come accennato sopra, ogni volta che una domanda
menziona che un grafico è aciclico, è sempre più veloce iniziare trovando un ordine lineare
coerente con i bordi del grafico.Una volta che questo è stato completato, è possibile gestire i nodi (come fatto nell'algoritmo di Dijkstra) in questo ordine lineare.Esercizio 14.6.2 chiede
Per dimostrare la correttezza di questo algoritmo.
Esercizio 14.6.1 mostra che per dimostrare che l'ordine inverso in cui i nodi
erano completamente gestiti è un tipo topologico corretto, è sufficiente dimostrare che per
Ogni bordo ⟨u, v⟩of G, il nodo V è completamente gestito prima di u.
Esercizio 14.6.2 (vedi soluzione nella parte cinque.) Dimostrare la correttezza e stimare il
Tempo di esecuzione di questo algoritmo per i percorsi ponderati più brevi per i DAG.

---
layout: 
title: Pagina 213
level: 3
---


Algoritmi di ricerca del grafico
197
14.7
Esercizio
Esercizio 14.7.1
Tracce di larghezza e profondità-prima ricerche sui seguenti due
grafici.Per ognuno fai quanto segue:
1.
Inizia dal nodo s e, quando c'è una scelta, seguire i bordi da sinistra a destra.Numero
I nodi 1, 2, 3 ,...Nell'ordine in cui vengono trovati, a partire dal nodo S = 1.
2.
Oscura i bordi dell'albero specificato dall'array predecessore π.
3.
Qual è la struttura dei dati utilizzata da ogni ricerca per archiviare i nodi che si trovano ma
Non ancora gestito?
4.
Cerchia i nodi che si trovano in questa struttura di dati quando il nodo 8 viene trovato per la prima volta.
S
1
(a) prima ricerca
S
1
(b) Search-First Search

---
layout: 
title: Pagina 214
level: 3
---


198
15 flussi di rete e
Programmazione lineare
Il flusso di rete è un classico problema computazionale con un numero sorprendentemente grande di
Applicazioni, come il routing di camion e abbinare coppie felici.Pensa a un dato
Grafico diretto come una rete di tubi che iniziano da un nodo di origine e terminano in un lavandino
nodo t.Attraverso ogni tubo, l'acqua può fluire in una direzione ad alcuni fino ad alcuni
capacità massima.L'obiettivo è quello di trovare la velocità totale massima al quale l'acqua può
Flusso dal nodo di origine S al nodo del lavandino.Se questo fosse un sistema fisico di tubi, è possibile determinare la risposta semplicemente spingendo tutta l'acqua come te
Potevo.Tuttavia, raggiungere questo algoritmicamente è più difficile di quanto si possa al primo posto
pensa, perché esponenzialmente molti percorsi di S tot si sovrappongono, in avanti e
indietro in modi complicati.
Un problema di ottimizzazione: il flusso di rete è un altro esempio di ottimizzazione
Problema, che prevede la ricerca di una soluzione migliore da alcune grandi soluzioni.Le specifiche formali sono descritte nel capitolo 13.
Specificazione del flusso di rete: data un'istanza ⟨g, s, t⟩, l'obiettivo è quello di trovare un tasso massimo di flusso attraverso il grafico G dal nodo S al nodo t.
Precondizionismo: ci viene data una delle seguenti istanze.
Istanze: un'istanza ⟨g, s, t⟩consist di un grafico diretto G e specifico
nodi s e t.Ogni bordo ⟨u, V⟩ è associato a una capacità positiva c⟨u, v⟩.
Ad esempio, vedere la Figura 15.1.a.
Postcondition: l'output è una soluzione con valore massimo e il valore di
quella soluzione.
Soluzioni ad esempio: una soluzione per l'istanza è un flusso, che specifica
il flamu f⟨u, v⟩through ogni bordo del grafico.I requisiti di un flusso sono
come segue.Ad esempio, vedere la Figura 15.1.b.
Flusso unidirezionale: per qualsiasi coppia di nodi, è più facile supporre che
Il flusso non va in entrambe le direzioni tra di loro.Quindi, ci richiederemo
che almeno uno di f⟨u, v⟩ e f⟨v, U⟩be zero e che non è negativo.

---
layout: 
title: Pagina 215
level: 3
---


Flussi di rete e programmazione lineare
199
UN
3
B
T
S
C
D
e
F
G
H
io
J
K
l
1
5
3
8
6
2
5
7
4
4
3
9
5
6
UN
3
B
T
S
C
D
e
F
G
H
io
J
K
l
1
5
3
8
6
2
5
7
4
4
3
9
5
6
(una rete
(c) Min Cut
(b) Flusso massimo
V
U
0/6
0/9
0/3
0/4
0/5
2/4
2/7
2/5
2/2
2/6
1/3
1/5
1/1
1/3
1/8
UN
B
T
S
C
D
e
F
G
H
io
J
K
l
Figura 15.1: (a) Una rete con le sue capacità di bordo etichettate.(b) un flusso massimo in questa rete.
Il primo valore associato a ciascun bordo è il suo flusso e il secondo è la sua capacità.Il tasso totale
del flusso è 3 = 1 + 2 −0.Si noti che non è possibile spingere più flusso lungo il percorso superiore, perché
il bordo ⟨b, c⟩is a capacità.Allo stesso modo per il bordo ⟨e, f⟩.Si noti inoltre che non viene spinto il flusso
il percorso inferiore, perché ciò ridurrebbe il totale da s a t.(c) un taglio minimo in questo
rete.La capacità di questo taglio min è 3 = 1 + 2. Si noti che la capacità del bordo ⟨j, non è
Incluso nella capacità del taglio, perché sta andando nella direzione sbagliata.(b) vs (c): la tariffa
del flusso massimo è uguale alla capacità del taglio min.I bordi che attraversano in avanti
Attraverso il taglio sono a capacità nel flusso, mentre quelli che attraversano all'indietro hanno flusso zero.Questi
Le cose non sono coincidenze.
Capacità del bordo: il flusso attraverso qualsiasi bordo non può superare la capacità
del bordo, vale a dire f⟨u, v⟩≤c⟨u, v⟩.
Nessuna perdita: non è possibile aggiungere acqua in nessun nodo diverso dalla sorgente s e nessuna acqua può essere drenata in nessun nodo diverso dal lavandino t.A ciascuno
Altro nodo Il flusso totale nel nodo è uguale al flusso totale, cioè, per
Tutti i nodi u ̸∈ {s, t},
v f⟨v, u⟩ =
v f⟨u, v⟩.
Misura del successo: il valore di un flusso F, tasso indicato (F), è il tasso totale
di flusso dalla fonte s al lavandino t.Definiremo questo per essere il totale
foglie S senza tornare, velocità (f) =
v [f⟨s, v⟩ - f⟨v, s⟩].Accettare con il nostro
Intuizione, dimostreremo in seguito che, poiché nessuna perdita di flusso o è creata tra S e T, questo flusso è uguale a che fluisce in T senza lasciarlo, vale a dire

v [f⟨v, t⟩ - f⟨t, v⟩].
Min Cut Specification: un altro problema di ottimizzazione interessante e forse sorprendentemente correlato è il taglio min.Data un'istanza ⟨g, s, t⟩, l'obiettivo è quello di trovare un taglio tra s e t che ha la possibile capacità minima che lo attraversa dal lato s a
il lato t.
Precondizionismo: ci viene data una delle seguenti istanze.
Istanze: un'istanza ⟨g, s, t⟩consist di un grafico diretto G e specifico
nodi s e t.Ogni bordo ⟨u, V⟩ è associato a una capacità positiva c⟨u, v⟩.
Si noti che il flusso di rete e i problemi di taglio MIN hanno gli stessi casi.
Ad esempio, vedere la Figura 15.1.a.
Postcondition: l'output è una soluzione con valore minimo e il valore di
quella soluzione.
Soluzioni per l'istanza: una soluzione per l'istanza è un taglio c = ⟨u, v⟩, che è un partizionamento dei nodi del grafico in due set u e v simili
Che la fonte s sia in u e il lavandino t è in V. per esempio, vedere la Figura 15.1.c.

---
layout: 
title: Pagina 216
level: 3
---


Problemi di ottimizzazione
200
Ad esempio, se G dà le strade, s è Toronto e T è Berkeley, un taglio
Potrebbe essere il confine canadese -USA.Perché i nodi in un grafico non hanno
Una posizione come fanno le città, non c'è motivo per la partizione dei nodi
geograficamente contiguo.Chiunque del numero esponenziale di partizioni
andrà bene.
Misura del successo: la capacità di un taglio è la somma delle capacità di tutte
bordi da u a v, vale a dire, cap (c) =
u∈U

V∈V C⟨u, v⟩.Nota che questo lo fa
non includere le capacità c⟨v, di ⟩of i bordi che tornano da V a U.
Nella sezione 15.1, progetteremo un algoritmo per il problema del flusso di rete.Noi
vedere che questo algoritmo è un esempio di algoritmo per l'arrampicata in collina e che non lo fa
lavorare necessariamente, perché potrebbe rimanere bloccato in un piccolo massimo locale.Nella sezione 15.2, modificheremo l'algoritmo e utilizzeremo il metodo primordiale, che utilizza un taglio minuto
per garantire che abbia trovato un massimo globale.Questo algoritmo, tuttavia, potrebbe averlo
Tempo di esecuzione esponenziale.Nella sezione 15.3, dimostriamo che la versione più ripida.
Di questo algoritmo di arrampicata in collina corre in tempo polinomiale.Infine, la sezione 15.4 si riferisce
Queste idee a un altro problema più generale chiamato programmazione lineare.
Esercizio 15.0.1 Supponiamo di aver assicurato che il flusso vada in una sola direzione tra
Tutti i due nodi, non richiedendo che il flusso in una direzione f⟨v, U⟩be zero, ma da
richiedendo quel f⟨v, u⟩ = −f⟨u, v⟩.Questo è meno coerente con l'intuizione e ne oscura alcuni
sottigliezze.Il cambiamento ha, tuttavia, ha il vantaggio di semplificare molti dei
equazioni.Ad esempio, il requisito senza fluide semplifica
v f⟨u, v⟩ = 0. come fa
Questa modifica tutte le altre equazioni in questa sezione?
15.1
Un algoritmo di arrampicata in collina con un piccolo massimo locale
Escursioni all'età di sette anni, ha dichiarato mio figlio Josh
che il modo per trovare la cima della collina è semplicemente
Per continuare a camminare in una direzione che ti prende e sai di essere lì quando non puoi andare
più.Non sapeva che questo è anche un
Tecnica comune per trovare la soluzione migliore
Per molti problemi di ottimizzazione.L'algoritmo
mantiene una soluzione per il problema e fa ripetutamente una piccola serie di prescritti
modifiche a questa soluzione in un modo che la rende
una soluzione migliore.Si ferma quando nessuno di questi
Le modifiche sembrano in grado di fare una soluzione migliore.
Ci sono due problemi con questa tecnica.
Innanzitutto, non è necessariamente chiaro per quanto tempo lo farà
Prendi fino a quando l'algoritmo si ferma.Secondo, a volte trova un piccolo massimo locale, cioè il

---
layout: 
title: Pagina 217
level: 3
---


Flussi di rete e programmazione lineare
201
T
C
B
UN
S
20/20
20/21
50/75
30/30
30/31
0/2
10
75
0/10
C
Fluire
Sentiero
Rete
20
30
Tasso = 50
S
UN
B
T
2
20
21
31
30
S
B
T
T
UN
S
C
C
Figura 15.2: una rete, con le sue capacità di bordo etichettate, è riportata a sinistra.Nel mezzo sono
Due percorsi attraverso i quali può essere spinto il flusso, con il flusso risultante a destra.Il primo
Il valore associato a ciascun bordo è il suo flusso e il secondo è la sua capacità.Il tasso totale del
Il flusso è 50.
Top di una piccola collina, anziché il massimo globale globale.Molti algoritmi di arrampicata in collina, tuttavia, sono ampiamente utilizzati anche se non sono garantiti
lavoro, perché in pratica sembrano funzionare bene.In questa sezione, descriviamo un algoritmo di Hillclimbing che è garantito per risolvere rapidamente il suo problema.
Idee di base: inizierò dando alcune idee che non funzionano.
Push From Fonte: la prima cosa ovvia da provare è semplicemente iniziare a spingere l'acqua
fuori da s.Se le capacità dei bordi vicino a S sono grandi, allora possono prendere un sacco di
flusso.Più in basso nella rete, tuttavia, le capacità possono essere più piccole, in cui
Caso Il flusso che abbiamo iniziato rimarrà bloccato.Per evitare di causare violazione della capacità
O perdite, dovremo ritirare il flusso che abbiamo iniziato.Ancora più in basso il
Network, un bordo può forchetta in bordi con capacità maggiori, nel qual caso lo faremo
È necessario decidere in quale direzione instrada il flusso.Tenere traccia di questo potrebbe
essere un mal di testa.
Pianifica il percorso per una goccia d'acqua: una soluzione sia per il problema del flusso
bloccato e il problema del flusso di routing lungo la strada è trovare un intero percorso
da s a t attraverso il quale il flusso può avvenire.Nell'esempio della Figura 15.2, l'acqua può fluttuare lungo il percorso ⟨s, b, c, t⟩: vedere il percorso centrale superiore.Quindi possiamo spingere
Il più possibile attraverso questo percorso.È facile vedere che il collo di bottiglia è il
Edge ⟨b, c⟩ con capacità 30. Quindi, aggiungiamo un flusso di 30 a ciascun bordo lungo questo
sentiero.Funzionando bene, possiamo provare ad aggiungere più acqua attraverso un altro percorso.Permettere
Ci proviamo il percorso ⟨s, a, c, t⟩.La prima cosa interessante da notare è che il bordo ⟨c, t⟩
In questo percorso ha già un flusso 30 attraverso di esso.Poiché questo bordo ha una capacità di 75, il flusso massimo che può essere aggiunto è 75 −30 = 45. Questo, tuttavia, gira
fuori per essere il collo di bottiglia, perché il bordo, è capacità 20. Aggiunta di un
Il flusso di 20 a ciascun bordo lungo questo percorso fornisce il flusso mostrato a destra nella Figura 15.2.Per ogni bordo, il valore sinistro dà il flusso e la destra dà la sua capacità.
Non ci sono più percorsi in avanti da S Tot, ora siamo bloccati.È questo il flusso massimo?
Un percorso tortuoso: l'acqua ha un modo divertente di filtrare da un posto all'altro.Esso
non ha bisogno di andare avanti solo.Sebbene il percorso ⟨s, b, a, c, t⟩winds all'indietro

---
layout: 
title: Pagina 218
level: 3
---


Problemi di ottimizzazione
202
B
Sentiero
(Difettoso) Grafico di aumento
Nuovo flusso
tasso = 51
T
C
B
UN
S
20/20
21/21
30/30
31/31
UN
1
1
C
S
T
20-20 = 0
20/21
20/20
S
UN
B
T
1/2
2−1 = 1
0/10
51/75
50/75
C
0/10
?
30/30
T
C
UN
S
B
30−30 = 0
31−31 = 0
21-21 = 0
75-51 = 24
Nessun percorso
Tasso = 50
Fluire
30/31
0/2
?
2−0 = 2
75-50 = 25
31−30 = 1
21-20 = 1
20-20 = 0
T
C
UN
S
B
30−30 = 0
Figura 15.3: la parte superiore sinistra è lo stesso flusso indicato nella Figura 15.2, il primo valore associato a
ogni bordo è il suo flusso e il secondo è la sua capacità.Il mezzo superiore è un primo tentativo di
Un grafico di aumento per questo flusso.Ogni bordo è etichettato con la quantità di più flusso che esso
può gestire, vale a dire C⟨u, v⟩ - f⟨u, v⟩.L'alto a destra è il percorso in questo grafico di aumento attraverso
quale flusso è aumentato.La parte inferiore a sinistra è il flusso risultante.Il mezzo inferiore è il suo (difettoso)
Grafico di aumento.Non è possibile aggiungere più flusso attraverso di esso.
Più flusso può essere spinto attraverso di esso.Un altro modo per vedere che il concetto di "forward" non è rilevante per questo problema.Il collo di bottiglia nell'aggiungere il flusso attraverso questo
Il percorso è il bordo ⟨a, c⟩.Avendo già un flusso 20, il suo flusso può aumentare solo di 1.
L'aggiunta di un flusso di 1 lungo questo percorso fornisce il flusso mostrato in basso a sinistra nella Figura 15.3.Anche se questo esempio ci ricorda che dobbiamo considerare tutto possibile
percorsi da s tot, sappiamo che la ricerca di percorsi attraverso un grafico è facile usando entrambi
Ricerca prima o profondità o profondità (sezioni 14.2 e 14.4).Tuttavia, inoltre, vogliamo assicurarci che il percorso che troviamo sia tale da poter aggiungere un diverso zero
quantità di flusso attraverso di esso.Per questo, introduciamo l'idea di un aumento
grafico.
Il grafico di aumento (difettoso): prima di poter trovare un percorso attraverso il quale
È possibile aggiungere più flusso, dobbiamo calcolare per ogni bordo la quantità di flusso
Questo può essere aggiunto attraverso di esso.Per tenere traccia di queste informazioni, costruiamo da
L'attuale flusso di un grafico indicato da G f e chiamato grafico di aumento.
(Aumento significa aggiungere. L'aumento è l'importo che aggiungi.) Questo
Il grafico inizialmente avrà gli stessi bordi diretti della nostra rete, G. ciascuno di questi
I bordi sono etichettati con la quantità per cui il suo flusso può essere aumentato.Chiameremo
Questo è la capacità di aumento di Edge.Supponendo che il flusso attuale
Il bordo è f⟨u, e la sua capacità è c⟨u, v⟩, questa capacità di aumento è data da
c⟨u, v⟩ - f⟨u, v⟩.Qualsiasi vantaggio per il quale questa capacità è zero viene eliminata dal grafico di aumento.Per questo motivo, il flusso diverso da zero può essere aggiunto lungo qualsiasi percorso trovato
Da S a T all'interno di questo grafico di aumento.Il percorso scelto sarà chiamato
Percorso di aumento.La capacità minima di aumento di uno qualsiasi dei suoi bordi è
L'importo di cui è aumentato il flusso in ciascuno dei suoi bordi.Per un esempio,

---
layout: 
title: Pagina 219
level: 3
---


Flussi di rete e programmazione lineare
203
Vedi Figura 15.3.In questo caso, l'unico percorso sembra essere ⟨s, b, a, c, t⟩, che è
il percorso che abbiamo usato.Il suo percorso è aumentato da un flusso di 1.
L'algoritmo (difettoso): ora abbiamo definito i passaggi di base e possiamo facilmente riempire
i restanti dettagli dell'algoritmo.
Il ciclo invariante: l'invariante in loop più ovvio è quello in cima al
Loop principale abbiamo un flusso legale.È possibile che qualche invariante più complesso
Sarà necessario, ma per il momento sembra essere sufficiente.
La misura del progresso: l'ovvia misura del progresso è quanto flusso
L'algoritmo è riuscito a ottenere tra S e T, cioè il tasso di velocità (F) del
flusso attuale.
I passaggi principali: dato un flusso legale attuale attraverso la rete G, l'algoritmo migliora il flusso come segue: costruisce il grafico di aumento G f
per il flusso;trova un percorso di aumento da s a t attraverso questo grafico usando
Ricerca di larghezza o profondità;trova il bordo nel percorso la cui capacità di aumento è la più piccola;e aumenta il flusso di questo importo attraverso ciascuno
bordo nel percorso.
Mantenimento dell'invariante in loop: dobbiamo dimostrare che il flusso appena creato è
un flusso legale per dimostrare che ⟨loop-invariant′⟩ & not⟨exit-conf⟩ & codeloop ⇒
⟨Loop-invariant ′ ′⟩.
Capacità del bordo: stiamo attenti ad aumentare mai il flusso di qualsiasi vantaggio di più
dell'importo c⟨u, v⟩ - f⟨u, v⟩.Quindi, il suo flusso non aumenta mai oltre la sua capacità C⟨u, v⟩.
Nessuna perdita: siamo attenti ad aggiungere la stessa quantità a ogni bordo lungo un percorso
da s tot.Quindi, per qualsiasi nodo u lungo il percorso, c'è un bordo ⟨v, u⟩into
il nodo il cui flusso cambia e un bordo ⟨u, v′⟩out del nodo il cui flusso
i cambiamenti.Perché questi cambiano della stessa quantità, il flusso nel nodo
rimane uguale a quello fuori, in modo che per tutti i nodi u ̸∈ {s, t} abbiamo
v f⟨v, u⟩ =

v f⟨u, v⟩.In questo modo, sosteniamo il fatto che l'attuale flusso non ha perdite.
Fare progressi: perché i bordi i cui flussi non potevano cambiare venivano eliminati
Dal grafico aumentato, sappiamo che il flusso attraverso il percorso che era
trovato può essere aumentato di un importo positivo.Ciò aumenta il flusso totale.Perché
Le capacità dei bordi sono numeri interi, possiamo dimostrare induttivamente che i flussi
sono sempre numeri interi e quindi il flusso aumenta di almeno uno.(Avere frazioni
Per quanto riguarda le capacità, ma avere irrazionali come capacità può causare l'algoritmo
correre per sempre.)
Codice iniziale: possiamo iniziare con un flusso di zero attraverso ogni bordo.Questo stabilisce
L'anello invariante, perché è un flusso legale.

---
layout: 
title: Pagina 220
level: 3
---


Problemi di ottimizzazione
204
Condizione di uscita: al momento, è difficile immaginare come sapremo se
o no abbiamo trovato il flusso massimo.Tuttavia, è facile vedere cosa
Perché il nostro algoritmo si blocca.Se il grafico di aumento per il nostro flusso attuale è
in modo tale che non vi sia alcun percorso da s a t, quindi a meno che non possiamo pensare a qualcosa
Meglio fare, dobbiamo uscire.
Terminatura: come al solito, dimostriamo che questo algoritmo iterativo alla fine termina perché ad ogni iterazione il tasso di flusso aumenta di almeno uno e
Perché il flusso totale non può certo superare la somma delle capacità di tutti i
bordi.
Questo definisce completamente un algoritmo.
Rimanere bloccati al massimo locale: gli algoritmi per l'arrampicata in collina si muovono fino a quando non
non può più salire.Il motivo per cui non sono autorizzati a scendere è lo stesso
Motivo che gli algoritmi iterativi devono fare progressi ogni iterazione, vale a dire
Assicurarsi che l'algoritmo alla fine si fermi.
Un grosso problema con questo è che a volte trovano un piccolo massimo locale, cioè la parte superiore di una piccola collina, anziché il massimo globale complessivo.Perché a
L'algoritmo per l'arco di Hill non è autorizzato a muoversi verso il basso, si blocca in un tale locale
massimo.
Questo è simile alla classe di algoritmi noti come algoritmi avidi, descritti
Nel capitolo 16. In questi, nessuna decisione presa viene revocata.Il nostro algoritmo di flusso di rete potrebbe essere considerato avido in quanto una volta che l'algoritmo decide di mettere il flusso
Attraverso un bordo, potrebbe in seguito aggiungere altro, ma non rimuove mai il flusso.Dato che il nostro obiettivo
è ottenere il più possibile flusso da s tot e che non importa come quel flusso
Ci arriva, ha senso che un approccio così avido funzionerebbe.Tuttavia, lo faremo
Vedi che non funziona.
Un controesempio: dimostrando che un determinato algoritmo funziona per ogni istanza di input
Può essere una grande sfida.Tuttavia, al fine di dimostrare che non funziona, solo noi
È necessario dare un'istanza di input in cui fallisce.La Figura 15.4 fornisce un tale esempio.
Traccia l'algoritmo sulla stessa istanza dalla Figura 15.2 che abbiamo fatto prima.
Tuttavia, questa volta l'algoritmo ha scelto percorsi diversi.Innanzitutto mette un
flusso di 2 attraverso il percorso ⟨s, b, a, c, t⟩, seguito da un flusso da 19 a ⟨s, a, c, t⟩, seguito da un flusso da 29 a ⟨s, b, c, t⟩.A questo punto, siamo bloccati perché il
Il grafico di aumento non contiene un percorso da s a t.Questo è un problema perché il
Il flusso attuale è solo 50, mentre abbiamo già visto che il flusso per questa rete
può essere 51. Nella terminologia dell'arco di collina, questo flusso è un piccolo massimo locale, perché
Non possiamo migliorarlo usando i passaggi che abbiamo permesso;Ma non è un massimo globale, perché esiste una soluzione migliore.
Dove abbiamo sbagliato: dal punto di vista dell'arco di collina, abbiamo fatto un passo in un
direzione arbitraria che ci prende, ma con il nostro primo tentativo ci siamo capiti
Attraversa la grande collina e nel secondo ci è capitato di salire sulla piccola collina.

---
layout: 
title: Pagina 221
level: 3
---


Flussi di rete e programmazione lineare
205
S
30–0 = 30
30–0 = 30
T
C
B
UN
S
S
UN
B
C
T
2/31
2/2
21/21
0/30
B
C
T
UN
20–19 = 1
20–19 = 1
29/30
21/21
19/20
75–50 = 25
?
?
75–21 = 54
21/75
0/10
0/10
50/75
10
UN
S
UN
B
C
T
31
20
2
75
21
30
Rete
29
21–21 = 0
Tasso = 21
2/2
B
S
S
UN
B
C
T
31–2 = 29
31–2 = 29
21–2 = 19
0/20
S
19
tasso = 2
Sentiero
Fluire
Sentiero
B
T
UN
2
Nessun percorso
(Difettoso) Grafico di aumento
S
C
C
31/31
T
C
B
UN
S
S
UN
B
C
T
31–31 = 0
2–2 = 0
2–2 = 0
2–2 = 0
30–29 = 1
19/20
Tasso = 50
21–21 = 0
20–0 = 20
UN
T
C
B
0/30
2/21
2/2
2/31
T
?
75–2 = 73
0/10
2/75
Figura 15.4: l'algoritmo difettoso è rintracciato sull'istanza dalla Figura 15.2.I nodi in questo
I grafici sono disposti in modo diverso per enfatizzare il primo percorso scelto.Il flusso attuale è indicato
la sinistra, il corrispondente grafico di aumento nel mezzo, il percorso di aumento sul
a destra e il flusso risultante nella riga successiva.L'algoritmo rimane bloccato in un locale non ottimale
massimo.
Il flusso di 51 che abbiamo ottenuto prima si rivela essere la soluzione massima unica (spesso ci sono più di una possibile soluzioni massime).Quindi, noi
Può confrontarlo con la nostra soluzione attuale per vedere dove abbiamo sbagliato.Nel primo
Step, mettiamo un flusso di 2 attraverso il bordo ⟨b, a⟩;Tuttavia, alla fine risulta
Che mettere più di 1 attraverso è un errore.
Correzione dell'algoritmo: i seguenti sono possibili modi per fissare il tipo di bug
abbiamo trovato.
Prendi decisioni migliori: se iniziamo mettendo il flusso attraverso il percorso ⟨s, b, c, t⟩, allora l'algoritmo funziona, ma se iniziamo con il percorso ⟨s, b, a, c, t⟩, non lo fa.
Un modo per fissare il bug è trovare un modo per scegliere quale percorso aggiungi il flusso
al prossimo in modo da non rimanere bloccati in questo modo.Dal punto di vista dell'algoritmo avido, se vogliamo impegnarci a una scelta, è meglio che facciamo un bene
uno.Non conosco il modo di trovare l'algoritmo di flusso di rete in questo modo.
Backtrack: il capitolo 17 descrive un'altra classe di algoritmi, nota come ricorsiva
Algoritmi di backtracking, che notano continuamente quando hanno fatto un errore
e quel backtrack, provando altre opzioni, fino a quando una corretta sequenza di scelte è
fatto.In questo esempio, dobbiamo trovare un modo per ridurre il flusso attraverso il
Edge ⟨b, a⟩from da 2 a 1. Un pericolo generale di algoritmi di backtracking rispetto agli algoritmi avidi è che l'algoritmo avrà una corsa molto più lunga
tempo se continua a cambiare idea.

---
layout: 
title: Pagina 222
level: 3
---


Problemi di ottimizzazione
206
Fai passi più grandi: un modo per evitare di rimanere bloccato in cima a una piccola collina è
per fare un passo abbastanza grande in modo da salire sulla valle sul pendio di
la collina più grande e un po 'più in alto.In questo modo è necessario ridimensionare la tua definizione
di un passo.Questo è l'approccio che adotteremo.Dobbiamo trovare un modo per ridurre il flusso attraverso il bordo ⟨b, a⟩from da 2 a 1 mantenendo il ciclo
invariante che abbiamo un flusso legale e aumentando il flusso complessivo da s tot.IL
Posizionare nell'algoritmo in cui consideriamo come è consentito cambiare il flusso attraverso un bordo è dove definiamo il grafico di aumento.Nella sezione successiva
Riconsideriamo questa definizione.
15.2
Il metodo di blocco delle colline primordiali
Ora definiremo un passo più grande che l'algoritmo per l'arrampica
evitando un massimo locale.
L'algoritmo (corretto):
Il grafico di aumento: come prima, il grafico di aumento esprime come il
Il flusso in ogni bordo è in grado di cambiare.
Bordi in avanti: come prima, quando un bordo ⟨u, v⟩has flow f⟨u, v⟩ e capacità
c⟨u, v⟩, mettiamo il bordo corrispondente ⟨u, contro il grafico di aumento con
capacità di aumento c⟨u, v⟩ -f⟨u, v⟩to indicano che ci è permesso aggiungere
questo flusso da u a v.
Bordi inversi: ora vediamo che esiste la possibilità che potremmo volere
diminuire il flusso da u a v. dato che il suo flusso attuale è f⟨u, v⟩, questo è il
importo per cui può essere ridotto.In effetti, è lo stesso che aumentare
il flusso da V a U di questa stessa quantità.Inoltre, se il bordo inverso ⟨v, u⟩
è anche nel grafico e ha la capacità c⟨v, u⟩, quindi siamo in grado di aumentare il
fluire da v a u con questo secondo importo c⟨v, u⟩as bene.Pertanto, quando il
Edge ⟨u, v⟩has flow f⟨u, v⟩ e il bordo inverso ⟨v, capacità u⟩has c⟨v, u⟩, noi
75
0
–10
–10
0
75
21
so camminare
75−21 = 54 a destra o
21+10 = 31 a sinistra.
10 a sinistra.
75 a destra o
so camminare
Figura 15.5: Supponiamo che da casa mia posso camminare 75 km a destra o 10 a sinistra.Se io
sono già 21 km a destra, quindi posso camminare 75 −21 = 54 km a destra o 21 + 10 = 31 a
la sinistra.Inoltre, camminare 31 a sinistra e -31 a destra sono gli stessi.Allo stesso modo, supponiamo
Che il mio conto bancario possa contenere solo $ 75 o andare in scoperto fino a $ 10.Se ho già $ 21
Nell'account, quindi sono in grado di aggiungere 75 −21 = $ 54 o rimuovere 21 + 10 = $ 31.Rimozione di $ 31
E anche l'aggiunta di - $ 31 sono uguali.

---
layout: 
title: Pagina 223
level: 3
---


Flussi di rete e programmazione lineare
207
tasso = 2
Sentiero
S
B
C
T
UN
2
Fluire
Sentiero
20
30
19
30
B
2+10 = 12
S
2
UN
2
19
S
19/20
Tasso = 50
UN
T
C
B
0/30
2/21
2/2
2/31
T
C
B
S
UN
B
C
T
0/20
S
29
29
2
UN
2
0
60
29
75–2 = 73
75–21 = 54
21+10 = 31
cap = 51 = velocità
V
U
Taglio
Nessun percorso
tasso = 51
51/75
30/30
1/2
20/20
21/21
31/31
T
B
1
0
21
19
1
2–2 = 0
2–0 = 2
2
0
21
0
1
19
0
31
S
UN
C
T
1
25
C
S
S
UN
B
C
T
2/31
2/2
21/21
0/30
B
C
T
UN
29/30
21/21
2/2
31/31
T
C
B
C
B
UN
S
Grafico di aumento
1
UN
T
C
B
S
21/75
0/10
0/10
50/75
UN
Rete
29
Tasso = 21
19/20
S
T
30
21
75
2
20
2/75
1
1
0
30
21
0
0
0
31
61
24
20
S
UN
C
T
B
31
C
T
31
20
2
75
21
30
B
T
C
B
UN
S
10
10
S
UN
0/10
Figura 15.6: una traccia dell'algoritmo corretto sull'istanza dalla Figura 15.4.L'attuale flusso
è dato a sinistra, il grafico di aumento corrispondente nel mezzo, l'aumento
Percorso a destra e il flusso risultante nella riga successiva.Si ottiene il flusso ottimale.IL
Il diagramma inferiore mostra un taglio minimo c = ⟨u, v⟩.
Metti anche il bordo inverso ⟨v, nel grafico di aumento con capacità di aumento f⟨u, v⟩+ c⟨v, u⟩.Per ulteriori intuizioni, vedi Figura 15.5 e per un
Esempio Vedi Edge ⟨C, nel secondo grafico di aumento nella Figura 15.6.
I passaggi principali: poco altro cambia nell'algoritmo.Dato alcuni legali attuali
fiorire attraverso la rete g, l'algoritmo migliora il flusso come segue: esso
Costruisce il grafico di aumento G F per il flusso;trova un percorso di aumento
da s a t attraverso questo grafico usando la prima ricerca di larghezza o profondità;trova il
bordo nel percorso la cui capacità di aumento è la più piccola;e aumenta il
fluire con questa quantità attraverso ogni bordo nel percorso.Se il bordo nel grafico di aumento è nella direzione opposta a quello nel grafico del flusso, ciò comporta
diminuendo il flusso di questo importo.Questo perché l'aumento del flusso da v a u è
In effetti lo stesso della riduzione da u a v.

---
layout: 
title: Pagina 224
level: 3
---


Problemi di ottimizzazione
208
Funziona sul controesempio?: La Figura 15.6 traccia questo nuovo algoritmo
Lo stesso esempio della Figura 15.4.I nuovi grafici di aumento includono bordi
nella direzione inversa.Ogni passaggio è uguale a quello nella Figura 15.4, fino all'ultimo
Step, in cui questi bordi inversi forniscono il percorso, a, b, c, t⟩from da t.IL
Il collo di bottiglia in questo percorso è 1. Quindi, aumentiamo il flusso di 1 in ogni bordo nel
sentiero.L'effetto è che il flusso attraverso il bordo ⟨b, a⟩decreases da 2 a 1, dando il flusso ottimale che avevamo ottenuto prima.
Passaggio più grande: i bordi inversi che sono stati aggiunti al grafico di aumento
potrebbe non essere necessario.Dopotutto lo fanno già aggiunto che è già stato aggiunto
attraverso un bordo.D'altra parte, avere più bordi nell'aumento
Il grafico può solo aumentare la possibilità che ci sia un percorso da S a T attraverso di esso.
Mantenimento dell'invariante in loop e fare progressi: vedere l'esercizio 15.2.1.
Condizioni di uscita: come prima dell'algoritmo esce quando si blocca perché il grafico di aumento per il nostro flusso attuale è tale che non vi è alcun percorso da s a t.
Tuttavia, con più bordi nel nostro grafico di aumento, ciò potrebbe non verificarsi non appena.
Codice:
Algoritm Network Flow (G, S, T)
⟨Pre-Cond⟩: G è una rete fornita da un grafico diretto con capacità sul
bordi.S è il nodo di origine.T è il lavandino.
⟨Post-Cond⟩: F specifica un flusso massimo attraverso G e C specifica un taglio minimo.
inizio
F = il flusso zero
ciclo continuo
⟨Loop-invariant⟩: f è un flusso legale.
G f = il grafico di aumento per F, dove
Edge ⟨u, v⟩has Ammagnation Capacity C⟨u, v⟩ - f⟨u, v⟩ e
Edge ⟨v, capacità di aumento di U⟩has c⟨v, u⟩+ f⟨u, v⟩.
uscita quando s non è collegato a t in g f
P = un percorso da s a t in g f
w = la capacità di aumento minima in p
Aggiungi w al flusso f in ogni bordo in p
End Loop
U = nodi raggiungibili da s in g f
V = nodi non raggiungibili da s in g f
C = ⟨u, v⟩
restituzione (f, c)
Algoritmo di fine

---
layout: 
title: Pagina 225
level: 3
---


Flussi di rete e programmazione lineare
209
Fine: il prossimo passo è dimostrare che questo algoritmo migliorato riesce sempre
Un massimo globale senza rimanere bloccato a un piccolo massimo locale.Usando il
Notazione di algoritmi iterativi, dobbiamo dimostrare che ⟨loop-invariant⟩ & ⟨exit-conf⟩
& CODEPOST-Loop ⇒⟨post-Cond⟩.Dall'anda invariante sappiamo che l'algoritmo
ha un flusso legale.Perché siamo usciti, sappiamo che il grafico che aumenta
non contenere un percorso da S a T e quindi siamo a un massimo locale.Dobbiamo dimostrare
che non ci sono piccoli massimi locali e quindi dobbiamo essere al massimo globale
e quindi hanno un flusso ottimale.Il metodo utilizzato è chiamato metodo Primal -Dual.
Calcola primordiale per collina: supponiamo che sopra le colline su cui stiamo arrampicando
Ci sono un numero esponenziale di tetti, uno sopra l'altro.Come prima, il nostro
Il problema è trovare un posto dove stare sulle colline con altezza massima.Noi chiamiamo
Questo è il problema di ottimizzazione primordiale.Un problema altrettanto impegnativo è trovare
il tetto più basso.Chiamiamo questo il problema della doppia ottimizzazione.La situazione è tale
che ogni tetto è sopra ogni luogo dove stare.Segue banalmente che il più basso e
Quindi il tetto ottimale è al di sopra del luogo più alto e quindi ottimale per stare in piedi, ma
Non sappiamo quanto sia al di sopra.
Diciamo che un algoritmo per arrampicarsi in collina si blocca quando non è in grado di fare un passo
In un modo che lo sposta in un posto più alto dove stare.Un arricchi di collina primordiale
L'algoritmo è in grado di dimostrare che l'unica ragione per rimanere bloccata è che il posto
È in piedi viene premuto contro un tetto.Questo è dimostrato dimostrando che da
qualsiasi posizione, può passare a una posizione più alta o specificare un tetto a cui
Questa posizione è adiacente.Vedremo ora come queste condizioni sono sufficienti
dimostrando quello che vogliamo.
Lemma: trova ottimale.È garantito un algoritmo di blocco delle colline primordiali.
i problemi.
Prove: dalla progettazione dell'algoritmo, si ferma solo quando ha una posizione
L e un tetto R con altezza altezza corrispondente (L) = altezza (R).Questa posizione
deve essere ottimale, perché ogni altra posizione l ′ deve essere al di sotto di questo tetto
e quindi non può essere superiore a questa posizione, cioè ∀l ′, altezza (l ′) ≤
altezza (r) = altezza (l).Diciamo che questa doppia soluzione è testimone del fatto
La soluzione primordiale L è ottimale.Allo stesso modo, L è testimone del fatto che r sia ottimale, cioè ∀r ′, altezza (r ′) ≥height (l) = altezza (r).Questo è chiamato il principio della dualità.
Taglia come limiti superiori: per applicare queste idee al problema del flusso di rete, dobbiamo trovare alcuni limiti superiori sul flusso tra S e T.Attraverso un
Percorso singolo, la capacità di ciascun bordo funge da limite superiore, perché il flusso
attraverso il percorso non può superare la capacità di nessuno dei suoi bordi.Il bordo con
La più piccola capacità, essendo il limite superiore più basso, è il collo di bottiglia.In una rete generale (vedi Figura 15.1), un singolo bordo non può fungere da collo di bottiglia, perché
Il flusso potrebbe essere in grado di aggirare questo bordo attraverso altri bordi.Un approccio simile,

---
layout: 
title: Pagina 226
level: 3
---


Problemi di ottimizzazione
210
Tuttavia, funziona.Supponiamo che volessimo legare il traffico tra Toronto
e Berkeley.Sappiamo che tale flusso deve attraversare il confine canadese -USA.
Quindi, non è necessario preoccuparsi di ciò che il flusso potrebbe fare in Canada
o all'interno degli Stati Uniti.Possiamo tranquillamente dire che il flusso da Toronto a Berkeley è
delimitato sopra dalla somma delle capacità di tutti gli attraversamenti di frontiera.Naturalmente, ciò non significa che quel flusso possa essere raggiunto.Altri limiti superiori possono essere
Ottenuto sommando la traversata di frontiera per altre regioni.Ad esempio, tu
potrebbe legare il traffico lasciando Toronto, lasciando l'Ontario, entrando in California o
Entrando in Berkeley.Questo ci porta alla seguente definizione.
Taglia di un grafico: un taglio c = ⟨u, v⟩of Un grafico è un partizionamento dei nodi di
il grafico in due set u e v in modo tale che la sorgente s sia in u e il lavandino t
è in V. La capacità di un taglio è la somma delle capacità di tutti i bordi da u
a v, vale a dire, cap (c) =
u∈U

V∈V C⟨u, v⟩.
Perché i nodi in un grafico non hanno una posizione come fanno le città, lì
non è motivo per cui la partizione dei nodi sia geograficamente contigui.
Qualsiasi numero esponenziale di partizioni farà.
Fluire su un taglio: essere in grado di confrontare la velocità di flusso da s a t
Capacità di un taglio, avremo prima bisogno di definire il flusso attraverso un taglio.
tasso (f, c): tasso definito (f, c) per essere il flusso corrente f attraverso il taglio C, che è il totale di tutto il flusso nei bordi che attraversano da u a v meno il
totale di tutto il flusso che ritorna, cioè tasso (f, c) =
u∈U

V∈V [f⟨u, v⟩−
F⟨v, u⟩].
rate (f) = rate (f, ⟨{s}, g - {s}⟩): abbiamo definito il flusso da s a t essere
Il flusso totale che lascia S senza tornare, vale a dire, velocità (f) =

v [f⟨s, v⟩ - f⟨v, s⟩].Questa è proprio l'equazione per il flusso attraverso il
Cut che mette tutto da solo, vale a dire velocità (f) = rate (f, ⟨{s}, g - {s}⟩).
Lemma: velocità (f, c) = velocità (f).Intuitivamente questo ha senso.Perché no
perdite d'acqua o viene creata tra la sorgente s e il lavandino t, il flusso
da S uguali al flusso attraverso qualsiasi taglio tra S e T, che a sua volta
è uguale al flusso in t.È perché questi sono gli stessi che semplicemente
Chiama questo il flusso da s a t.Poiché il flusso in un nodo è uguale a
quello fuori dal nodo, se si sposta il nodo da un lato del taglio al
Altro questo non cambia il flusso totale attraverso il taglio.Quindi possiamo
Cambia il nodo tagliato alla volta dall'essere quello contenente solo s
Essere il taglio a cui siamo interessati.
Più formalmente questo viene fatto per induzione sulla dimensione di U.
caso base, rate (f) = rate (f, ⟨{s}, g - {s}⟩) ci dà che la nostra ipotesi
La velocità (f, c) = velocità (f) è vera per ogni taglio che ha un solo nodo in U.
Supponiamo ora che, a titolo di induzione, supponiamo che sia vero per
ogni taglio che ha i nodi in U. ora lo dimostreremo per quei tagli che
avere nodi I + 1 in esso.Lascia che c = ⟨u, sia un taglio di questo tipo.Scegli un nodo

---
layout: 
title: Pagina 227
level: 3
---


Flussi di rete e programmazione lineare
211
u
C'
X
v
C
X
Figura 15.7: i bordi attraverso il taglio che non si annullano nella velocità (F, C) −Rate (F, C ′).
X (altro allora S) da U e spostalo attraverso il confine.Questo ci dà un
Nuovo taglio c ′ = ⟨u - {x}, v ∪ {x}⟩, dove il lato u - {x} contiene solo
I nodi.La nostra ipotesi ci dà quindi che il flusso attraverso questo taglio è
uguale al flusso di f: velocità (f, c ′) = velocità (f).Quindi, per dimostrarlo
tasso (f, c) = velocità (f), dobbiamo solo dimostrare che il tasso (f, c) = velocità (f, c ′).
Lo faremo dimostrando che la differenza tra questi è zero.Di
Definizione, velocità (f, c) −rate (f, c ′)
=

u∈U

V∈V
F⟨u, v⟩ - f⟨v, u⟩

-
⎡
⎣

u∈U− {x},
V∈V∪ {x}
F⟨u, v⟩ - f⟨v, u⟩
⎤
⎦
(La Figura 15.7 mostra i termini che non si annullano)
=

V∈V
F⟨x, v⟩ - f⟨v, x⟩

-

u∈U
F⟨u, x⟩ - f⟨x, u⟩

=

V∈V
F⟨x, v⟩ - f⟨v, x⟩

+

v∈U
F⟨x, v⟩ - f⟨v, x⟩

=

v
F⟨x, v⟩ - f⟨v, x⟩

= 0
Questo è il flusso totale fuori dal nodo, x meno il flusso totale nel
nodo, che è zero in base al requisito che non perde nodo.Questo dimostra
Quella velocità (f, c) = velocità (f) per ogni taglio che ha i + 1 nodi in U.
induzione, allora è vero per tutti i tagli per ogni dimensione di U. questo formalmente
dimostra che il tasso di un determinato flusso è lo stesso in qualsiasi taglio C.
Lemma: velocità (f) ≤cap (c): ora è facile dimostrare quella velocità (f) di qualsiasi flusso f
è al massimo la capacità di qualsiasi taglio C. nell'analogia primordiale
che ogni tetto è sopra ogni luogo dove stare.Dato tasso (f) = velocità (f, c), lo è
sufficiente per dimostrare che il flusso attraverso un taglio è al massimo la capacità del
taglio.Questo segue facilmente dal tasso di definizione (f, c) =
u∈U

V∈V [f⟨u, v⟩−
F⟨v, u⟩] ≤
u∈U

v∈V [f⟨u, v⟩], perché avere un flusso positivo all'indietro attraverso
Il taglio da V a U riduce solo il flusso.Allora questa somma è al massimo

---
layout: 
title: Pagina 228
level: 3
---


Problemi di ottimizzazione
212

u∈U

V∈V [c⟨u, v⟩], perché nessun bordo può avere flusso che supera la sua capacità.Questo
è la definizione del limite di capacità (c) del taglio.Questo dimostra il richiesto
tasso (f) ≤cap (c).
Fai un passo o trova un taglio: il metodo Primal -Dual richiede che da qualsiasi posizione sia possibile passare a una posizione più alta o specificare un tetto a cui questa posizione è adiacente.Nel problema del flusso di rete, questo si traduce in: dato qualsiasi legale
fiorire, o trovare un flusso migliore o trovare un taglio la cui capacità è uguale alla velocità
dell'attuale flusso.Il grafico di aumento G F include quei bordi attraverso
quale può essere aumentato il tasso di flusso.Quindi, i nodi raggiungibili da s in questo
I grafici sono i nodi a cui si potrebbe spingere più flusso.Lascia che ti denoti questo set
di nodi.Al contrario, l'insieme rimanente di nodi, che indicheremo per V, sono
quelli a cui non può essere spinto più flusso.Vedi il taglio nella parte inferiore della Figura 15.6.Nessun flusso può essere spinto attraverso il confine tra U e V, perché tutto
I bordi che attraversano sono in capacità.Se t è in u, allora c'è un percorso da s a t
attraverso il quale il flusso può essere aumentato.D'altra parte, Ift è in v, quindi c =
⟨U, è un taglio che separa s e t.Ciò che resta è formalizzare la prova che il
La capacità di questo taglio è uguale alla velocità del flusso corrente.(Per un altro esempio, vedi
Il taglio nella Figura 15.1.C.Sebbene cap (c) = velocità (f), questo taglio non è stato formato come
descritto qui perché il nodo I non è raggiungibile da s nell'aumento
grafico.)
Poiché sappiamo il tasso (f, c) = velocità (f), rimane solo per dimostrare il tasso (f, c) =
Cap (c), cioè che l'attuale flusso attraverso il taglio C è uguale alla capacità di
il taglio.
Lemma: velocità (f, c) = cap (c): per dimostrarlo, è sufficiente dimostrare che ogni
bordo ⟨u, v⟩crossing da u a v ha flusso in f a capacità (f⟨u, v⟩ = c⟨u, v⟩) e
ogni bordo ⟨v, che si interrompe da v a u non ha flusso zero in F. Questi lo danno
tasso (f, c) =
u∈U

V∈V [f⟨u, v⟩ - f⟨v, u⟩] =
u∈U

V∈V [c⟨u, v⟩ - 0] = cap (c).
F⟨u, v⟩ = c⟨u, v⟩: considera qualsiasi bordo ⟨u, v⟩crossing da u a v. se f⟨u, v⟩ <
c⟨u, v⟩, quindi il bordo ⟨u, v⟩ con capacità di aumento c⟨u, v⟩ - f⟨u, v⟩
verrebbe aggiunto al grafico di aumento.Tuttavia, avere un tale
bordo nel grafico di aumento contraddice il fatto che u è raggiungibile
da S nel grafico di aumento e V non lo è.
F⟨v, u⟩ = 0: se f⟨v, u⟩> 0, quindi il bordo ⟨u, v⟩ con capacità di aumento
c⟨u, v⟩+ f⟨v, dovrebbe essere aggiunto al grafico di aumento.Ancora una volta, avendo
Un tale vantaggio è una contraddizione.
Ciò dimostra che il tasso (F, C) = Cap (C).
Lemma: cap (c) = velocità (f): cap (c) = velocità (f, c) = velocità (f), cioè il flusso
Abbiamo scoperto equivale alla capacità del taglio, come richiesto.
Fine: questo algoritmo di flusso di rete migliorato trova sempre un massimo globale
senza rimanere bloccato a un piccolo massimo locale.In ogni iterazione o trova a

---
layout: 
title: Pagina 229
level: 3
---


Flussi di rete e programmazione lineare
213
percorso nel grafico di aumento attraverso il quale può migliorare il flusso corrente o
trova un taglio che testimonia il fatto che non ci sono flussi migliori.
Principio di dualità massimo-flusso-minimo: i problemi di taglio massimo e minimo erano
definito all'inizio di questo capitolo, entrambi sono interessanti problemi
Giusto.Ora vediamo che i tagli possono essere usati come soffitti sui flussi.
Max Flow = Min Cut: abbiamo dimostrato che, dato qualsiasi rete come input, l'algoritmo di flusso di rete trova un flusso massimo e, quasi come un incidente, trova a
taglio minimo anche.Ciò dimostra che il flusso massimo attraverso qualsiasi rete
è uguale al suo taglio minimo.
Dual Problems: diciamo che il doppio del problema del flusso massimo è il taglio Min
problema, e al contrario che il doppio del problema del taglio minimo è il massimo flusso
problema.
Crediti: questo algoritmo è stato sviluppato da Ford e Fulkerson nel 1962.
Tempo di esecuzione esponenziale?Supponiamo che il grafico della rete abbia m bordi, ciascuno
con una capacità rappresentata da un numero di bit O (ℓ).Ogni capacità potrebbe essere come
Grande come O (2ℓ) e il flusso massimo totale potrebbe essere grande quanto O (M · 2ℓ).Inziando
Come zero e aumentando di circa una iterazione, l'algoritmo avrebbe bisogno di O (M ·
2ℓ) iterazioni fino a quando non si trova il flusso massimo.Questo tempo di esecuzione è polinomiale in
Il numero di bordi, m.Tuttavia, la dimensione dell'istanza di input, che in questo caso
è il numero di bit (o cifre) necessari per rappresentare tutti i valori, è O (M · ℓ).Se ℓ
è grande, quindi il numero di iterazioni, O (M · 2ℓ), è esponenziale di queste dimensioni.Questo è un
Problema comune con gli algoritmi per l'arrampicata in collina.
Esercizio 15.2.1
Dimostra che l'algoritmo di flusso di rete presentato in questa sezione
Mantiene l'invariante invariante che detiene sempre un flusso legale.Fallo dimostrandolo
Le modifiche al flusso non violano alcuna capacità di bordo o creano perdite sui nodi.Anche
Dimostra che i progressi sono fatti perché il flusso totale aumenta.Devi stare attento con
I tuoi segni più e meno.
Esercizio 15.2.2
A partire dal flusso indicato di seguito, completa il flusso di rete
algoritmo.
0/2
4/4
4/10
0/3
0/2
2/3
0/4
2/9
4/4
2/2
7/7
T
S
T
S

---
layout: 
title: Pagina 230
level: 3
---


Problemi di ottimizzazione
214
Esercizio 15.2.3 In algoritmi di blocco delle colline Ci sono passi che fanno molti progressi
E passi che fanno pochissimi progressi.Ad esempio, la prima iterazione sull'input
dato nella Figura 15.2 potrebbe trovare un percorso attraverso il grafico di aumento attraverso il quale
È possibile aggiungere un flusso di 30.Potrebbe, tuttavia, trovare il percorso attraverso il quale solo un flusso di
2 può essere aggiunto.Quanto potrebbe essere brutto il tempo di esecuzione quando il calcolo è sfortunato
Abbastanza da fare sempre il peggior passo legale consentito dall'algoritmo?Inizia prendendo il
Passaggio che aumenta il flusso di 2 per l'ingresso indicato nella Figura 15.2.Quindi continua a prendere
il peggior passo possibile.Potresti estrarre ogni passo, ma è meglio usare
Questa opportunità di utilizzare invarianti a loop.Che aspetto ha il flusso dopo le iterazioni?
Ripeti questo processo sullo stesso grafico, tranne per il fatto che i quattro bordi formano il quadrato
ora hanno le capacità 1.000.000.000.000.000 e il crossover Edge ha la capacità 1. (anche
Sposta T a C o dare a quell'ultimo vantaggio una grande capacità.)
1. Qual è il numero peggiore di iterazioni di questo algoritmo di flusso di rete come
Funzione del numero di bordi M nella rete di input?
2. Qual è la "dimensione" ufficiale di una rete?
3. Qual è il numero peggiore di iterazioni di questo algoritmo di flusso di rete come
funzione della dimensione della rete di input?
Esercizio 15.2.4 Se tutte le capacità nella rete data sono numeri interi, dimostra che il
L'algoritmo restituisce sempre una soluzione in cui il flusso attraverso ogni bordo è un numero intero.
Per alcune applicazioni, questo fatto è cruciale.
Esercizio 15.2.5 (vedi soluzione nella parte cinque.) Fornisci un algoritmo per risolvere il min
tagliare il problema.Data una rete ⟨g, s, t⟩ con capacità sui bordi, trova un minimo
Cut c = ⟨u, v⟩where s ∈U e t ∈V.Il costo del taglio è il suo limite di capacità (c) =

u∈U

V∈V C⟨u, v⟩.(Suggerimento: ti è già stato detto come farlo.)
15.3
L'algoritmo per l'arrampicata più ripido
Tutti abbiamo sperimentato che arrampicarsi su una collina può richiedere molto tempo se torni indietro
e fuori, aumentando a malapena la tua altezza.Al contrario, ci arrivi molto più velocemente
Se ti dirigi energicamente dritto su per la collina.Questo metodo, che chiama il metodo
Di ascesa più ripida, è fare sempre il passo che aumenta di più la tua altezza.Se tu
Sappi già che l'algoritmo per arrampicarsi in collina in cui fai un passo su per la collina
Opere, quindi anche questo nuovo algoritmo più specifico.Tuttavia, se sei fortunato, esso
trova la soluzione ottimale più velocemente.
Nel nostro algoritmo di flusso di rete, la scelta di quale passo prendi coinvolge
Scegliere quale percorso nel grafico di aumento.La quantità che aumenta il flusso è la più piccola capacità di aumento di qualsiasi bordo in questo percorso.Ne consegue che
La scelta che ci darebbe il più grande miglioramento è il percorso il cui bordo più piccolo è il più grande per qualsiasi percorso da s a t.Il nostro flusso di rete più alto
L'algoritmo aumenterà un percorso così migliore per ogni iterazione.Ciò che resta da fare

---
layout: 
title: Pagina 231
level: 3
---


Flussi di rete e programmazione lineare
215
è dare un algoritmo che trova un tale percorso e dimostra che questo trova un massimo
flusso all'interno di un numero polinomiale di iterazioni.
Trovare il percorso di aumento con il più grande vantaggio: l'input
è costituito da un grafico diretto con pesi per bordi positivi e con nodi speciali e.
L'output è costituito da un percorso da s a t attraverso questo grafico il cui più piccolo ponderato
Edge è il più grande possibile.
Problema più semplice: prima di tentare di sviluppare un algoritmo per questo, consideriamo un problema più semplice ma correlato.Oltre al grafico diretto, l'input
Al problema più semplice fornisce un peso di peso, indicato.O produce un percorso
da s a t il cui bordo ponderato più piccolo è almeno grande come wmin, o afferma che
Non esiste tale percorso.
Usando il problema più semplice: supponendo che possiamo risolvere questo problema più semplice, noi
Risolvi il problema originale eseguendo il primo algoritmo con Wmin.
Peso del bordo nel grafico, fino a trovare il peso per il quale c'è un percorso con
Un peso più piccolo, ma non c'è percorso con un peso più piccolo.Questo è
la nostra risposta.(Vedi Esercizio 15.3.1.)
Risolvere il problema più semplice: un percorso il cui bordo ponderato più piccolo è almeno
grande come wmin ovviamente non conterrà alcun bordo il cui peso è più piccolo di
Wmin.Quindi, la risposta a questo problema più semplice non cambierà se eliminiamo
Il grafico tutti i bordi il cui peso è più piccolo.Qualsiasi percorso da s tot nel restante
Il grafico soddisferà le nostre esigenze.Se non esiste un percorso del genere, allora sappiamo anche che non ci sono
Tale percorso nel nostro grafico originale.Questo risolve il problema.
Dettagli dell'implementazione: per trovare un percorso da s a t in un grafico, l'algoritmo si dirama da s usando la prima o la prima ricerca, marcatura di profondità o profondità
ogni nodo raggiungibile da s con il predecessore del nodo nel percorso verso di esso
da s.Se nel processo T è contrassegnato, allora abbiamo il nostro percorso.(Vedi Sezione 14.1.)
Sembra una perdita di tempo per dover rifare questo lavoro per ogni wmin, quindi usiamo un
Algoritmo iterativo.L'invariante in loop sarà che il lavoro per il precedente WMIN
è stato fatto ed è memorizzato in modo utile.Il ciclo principale sarà quindi completato
Il lavoro per l'attuale WMIN, riutilizzando il più possibile del lavoro precedente.Questo può essere implementato come segue.Ordina i bordi dal più grande al più piccolo
(Breaking ties arbitrariamente).Considerali uno alla volta.Quando si considera WI, noi
deve costruire il grafico formato eliminando tutti i bordi con pesi più piccoli
di Wi.Denota questo da Gwi.Dobbiamo contrassegnare ogni nodo raggiungibile da s in questo
grafico.Supponiamo di aver già fatto queste cose nel grafico GWI - 1.Noi
Formare GWI da GWI - 1 aggiungendo il bordo singolo con peso WI.Let ⟨u, v⟩denote
Questo bordo.I nodi sono raggiungibili da S in GWI che non erano raggiungibili in GWI - 1
Solo se sei stato raggiungibile e V no.Questo nuovo vantaggio consente quindi a V di essere raggiungibile.I nodi non contrassegnati ora raggiungibili da s via v possono essere tutti marcati
Avviando una prima ricerca da v. L'algoritmo si fermerà al primo bordo
Ciò consente di raggiungere T.Il bordo con il peso più piccolo in questo percorso verso t

---
layout: 
title: Pagina 232
level: 3
---


Problemi di ottimizzazione
216
sarà il bordo con il peso Wi aggiunto durante questa iterazione.Non c'è percorso da
S a t nel grafico di ingresso con un bordo ponderato più piccolo, perché T non lo era
Raggiungibile quando venivano aggiunti solo i bordi più grandi.Quindi, questo percorso è un percorso per
T nel grafico il cui bordo ponderato più piccolo è il più grande.Questo è il richiesto
Output di questa subroutine.
Tempo di esecuzione: anche se l'algoritmo per trovare il percorso con il più grande
Il bordo più piccolo esegue la profondità, la prima ricerca per ogni peso WI, perché il lavoro svolto
prima viene riutilizzato, nessun nodo nel processo è contrassegnato più di una volta e
Quindi nessun bordo viene attraversato più di una volta.Ne consegue che questo processo richiede
Solo o (m) tempo, dove m è il numero di bordi.Questa volta, tuttavia, è dominato dal tempo O (mlogm) per ordinare i bordi.
Codice:
Algoritmo più grande di pesi (G, S, T)
⟨Pre-Cond⟩: G è un grafico diretto (aumento) ponderato.s è la fonte
nodo.T è il lavandino.
⟨Post-Cond⟩: p specifica un percorso da s a t il cui peso più piccolo è come
grande possibile.⟨U, è il suo bordo ponderato più piccolo.
inizio
Ordina i bordi in peso dal più grande al più piccolo
G ′ = grafico senza bordi
Mark s raggiungibile
ciclo continuo
⟨Loop-invariant⟩: ogni nodo raggiungibile da s in g ′ è contrassegnato
raggiungibile.
uscita quando t è raggiungibile
⟨U, v⟩ = il prossimo bordo ponderato in G
Aggiungi ⟨u, v⟩to g ′
Se (u è marcato raggiungibile e V non lo è)
Fai una prima ricerca da V, segnando tutti i nodi raggiungibili
non contrassegnato prima.
finisci se
End Loop
P = percorso da s a t in g ′
return (p, ⟨u, v⟩)
Algoritmo di fine
Tempo di esecuzione della salita più ripida: quante volte l'algoritmo di flusso di rete deve aumentare il flusso in un percorso quando il percorso scelto è quello di cui aumento
La capacità è la più grande possibile?
Diminuire la distanza rimanente di un fattore costante: il flusso inizia come
zero e potrebbe essere necessario aumentare per essere grande come O (M · 2ℓ) quando ci sono m bordi

---
layout: 
title: Pagina 233
level: 3
---


Flussi di rete e programmazione lineare
217
con capacità ℓbit.Vorremmo che il numero di passaggi non fosse esponenziale
ma lineare in ℓ.Un modo per raggiungere questo obiettivo è garantire che l'attuale flusso raddoppiasse ogni iterazione.Questo, tuttavia, non è probabile che accada.Un'altra possibilità è
Per girare la misura del progresso.Dopo l'ith ith, lascia che RI denoti il
Importo rimanente che il flusso deve aumentare.Più formalmente, supponiamo che il
Il flusso massimo è RATEMAX e che il tasso del flusso corrente è la velocità (F).La distanza rimanente è quindi ri = ratemax −rate (f).Mostreremo che l'importo
wmin con cui aumenta il flusso è almeno una frazione costante di RI.
Cimilendo la distanza rimanente: la cosa divertente di questa misura di
Il progresso è che l'algoritmo non sa quale sia il massimo di flusso
È.È necessario solo come parte dell'analisi.Dobbiamo legare quanto sia grande la distanza rimanente, ri = ratemax −rate (f).Ricordiamo che il grafico di aumento per
L'attuale flusso è costruito in modo che la capacità di aumento di ciascun bordo
dà la quantità che il flusso attraverso questo bordo può essere aumentato.Quindi, solo
come la somma delle capacità dei bordi attraverso qualsiasi taglio c = ⟨u, nella rete
Agisce come una parte superiore del flusso totale possibile, la somma dell'aumento
capacità dei bordi attraverso qualsiasi taglio c = ⟨u, contro il grafico di aumento
come una parte superiore legata all'importo totale, il flusso corrente può essere aumentato.
Scegliere un taglio: dobbiamo scegliere quale taglio useremo.(Questo non fa parte di
L'algoritmo.) Come prima, il taglio naturale da usare viene fuori dall'algoritmo che
trova il percorso da s a t.Lascia che WMIN = WI denoti la più piccola capacità di aumento nel percorso la cui più piccola capacità di aumento è maggiore.Lascia che Gwi - 1 sia
Il grafico creato dal grafico di aumento eliminando tutti i bordi le cui capacità di aumento sono più piccole o uguali a WMIN.Questo è l'ultimo grafico che
L'algoritmo che trova il percorso di aumento considera prima di aggiungere il bordo
con peso Wmin che collega S e T.Sappiamo che non esiste un percorso da
s to t in gwi - 1, altrimenti ci sarebbe un percorso nel grafico aumentato di cui
La più piccola capacità di aumento era maggiore di Wmin.Forma il taglio c = ⟨u, v⟩by
Lasciando che tu sia l'insieme di tutti i nodi raggiungibili da S in Gwi - 1 e lascia che V sia
quelli che non lo sono.Ora considera qualsiasi vantaggio nel grafico aumentante che attraversa
questo taglio.Questo bordo non può essere nel grafico GWI - 1, altrimenti si attraverserebbe
un nodo in u che è raggiungibile da s a un nodo che non è raggiungibile da s, che
è una contraddizione.Poiché questo bordo è stato eliminato in GWI - 1, sappiamo che è
La capacità di aumento è al massimo WMIN.Il numero di bordi attraverso questo taglio è
Al massimo il numero di bordi nella rete, che è stato indicato da m.Esso
segue che la somma delle capacità di aumento dei bordi attraverso questo taglio
C = ⟨u, v⟩is al massimo m · wmin.
CONTROLLARE L'aumento, WMIN ≥1
MRI: Abbiamo stabilito che il restante
quantità che il flusso deve essere aumentato, ri = ratemax −rate (f), è al massimo il
Somma delle capacità di aumento attraverso il taglio C, che è al massimo m · wmin, cioè ri ≤m · wmin.Riorganizzare questo dà quel WMIN ≥1
M ri.

---
layout: 
title: Pagina 234
level: 3
---


Problemi di ottimizzazione
218
Il numero di iterazioni: se il flusso aumenta ogni iterazione di almeno 1
m volte
l'importo rimanente RI, riduce l'importo rimanente, dando quel ri+1 ≤
Ri −1
M ri.Potresti pensare che ne consegue che il flusso massimo è ottenuto in
Solo m iterazioni.Questo sarebbe vero se ri+1 ≤ri −1
M R0.Tuttavia, non lo è, perché il RI più piccolo ottiene, minore è la quantità che diminuisce.Un modo per
Legare il numero di iterazioni necessarie è notare che ri ≤ (1 −1
m) I r0 e poi
o per vincolare i logaritmi alla base 1 −1
m o per notare che limm → ∞ (1 −1
m) m = 1
E ≈
1
2.17.Tuttavia, preferisco il seguente metodo.Finché RI è grande, lo sappiamo
diminuisce di molto.Dopo una certa ith ith, dì che RI è ancora grande quando è fermo
Almeno 1
2 ri.Finché questo è il caso, RI diminuisce di almeno 1
M ri ≥
1
2m ri.Dopo m tali iterazioni, RI diminuirebbe da RI a 1
2 ri.L'unica ragione per cui
Non continuerebbe a diminuire questo digiuno sarebbe che fosse già diminuito molto.Ad ogni modo, sappiamo che ogni m iterazioni, RI diminuisce
da un fattore due.Questo processo può farti pensare ai paradossi di Zeno.Se
tagli la distanza rimanente a metà e poi di nuovo a metà e così via
Anche se ti avvicini molto velocemente, non ci arrivi mai.Tuttavia, se
Tutte le capacità sono numeri interi, quindi tutti i valori saranno numeri interi, e quindi quando
RI diminuisce a meno di uno, deve in effetti essere zero, dandoci il massimo
flusso.
Inizialmente, la quantità rimanente RI = RATEMAX −Rate (F) è al massimo O (M · 2ℓ).
Quindi, se diminuisce di almeno un fattore di 2 ciascuno
MJ iterazioni, questo importo è al massimo O (M · 2ℓ/2J).Questo raggiunge uno quando j =
O (log2 (m · 2ℓ)) = o (ℓ+ logm) o in o (mℓ+ mlogm).Se le tue capacità sono numeri reali, sarai in grado di approssimare il flusso massimo a
all'interno di ℓ bit di precisione in altre iterazioni Mℓ ′.
CONDURE IL TEMPO DI RUNDARE: abbiamo determinato che ogni iterazione prende
Sono richiesti il ​​tempo di mlogm e che sono richieste solo iterazioni O (Mℓ+ mlogm).Segue
Che questo algoritmo di flusso di rete più ripido funziona nel tempo O (ℓm2 logm +
M2 log2 m).
Tempo completamente polinomiale: molto lavoro è stato svolto da un algoritmo che è
ciò che è noto come completamente polinomiale.Ciò richiede che il numero di iterazioni sia
Polinomio nel numero di valori e non dipende affatto dai valori stessi.Quindi, se si carica solo un passo temporale per l'aggiunta e la sottrazione, anche
Se le capacità sono cose strane come
√
2, quindi l'algoritmo fornisce la risposta esatta (almeno simbolicamente) nel tempo polinomiale.Mio padre, Jack Edmonds e un
Il collega, Richard Karp, ha sviluppato un tale algoritmo nel 1972. È una versione di
L'algoritmo Ford -Fulkerson originale.In esso, tuttavia, in ogni iterazione, il percorso
Da S a T nel grafico di aumento con il più piccolo numero di bordi è aumentato.Questo algoritmo scorre al massimo i tempi (nm), dove n è il numero di
nodi e m il numero di bordi.In pratica, questo è più lento di O (Mℓ)-Time
Algoritmo più alto-alimenziale.

---
layout: 
title: Pagina 235
level: 3
---


Flussi di rete e programmazione lineare
219
Esercizio 15.3.1
Potremmo usare la ricerca binaria sui pesi wmin per trovare il critico
Peso (vedere la sezione 1.4) e, in tal caso, sarebbe più veloce?Perché?
15.4
Programmazione lineare
Quando ero universitario, avevo un lavoro estivo con un'azienda alimentare.Il nostro obiettivo era
per fare hot dog economici.Ogni mattina abbiamo ottenuto i prezzi di migliaia di ingredienti:
cuori di maiale, segatura, ecc. Ogni ingrediente aveva una variabile associata che indica come
Gran parte di esso da aggiungere agli hot dog.Ci sono migliaia di vincoli lineari su questi
Variabili: così tanta carne, così tanta umidità e così via.Insieme questi vincoli
Specificare quali combinazioni di ingredienti costituiscono un hot dog.Il costo del caldo
Il cane è una funzione lineare delle quantità che metti in esso e dei loro prezzi.L'obiettivo è
Per determinare cosa mettere negli hot dog quel giorno per ridurre al minimo il costo.Questo è un
Esempio di una classe generale di problemi indicati come programmi lineari.
Specificazione formale: un programma lineare è un problema di ottimizzazione i cui vincoli e funzioni oggettive sono funzioni lineari.L'obiettivo è trovare un'impostazione di
Variabili che ottimizzano la funzione obiettivo, rispettando tutti i vincoli.
Precondizionismo: ci viene data una delle seguenti istanze.
Istanze: un'istanza di input è costituita da (1) un insieme di vincoli lineari su a
Set di variabili e (2) una funzione obiettiva lineare.
Postcondition: l'output è una soluzione con il costo minimo e il costo
soluzione.
Soluzioni ad esempio: una soluzione per l'istanza è un'impostazione di tutte le variabili che soddisfano i vincoli.
Misura del successo: il costo o il valore di una soluzioni è dato dall'obiettivo
funzione.
Esempio 15.4.1: esempio di istanza
massimizzare
7x1 −6x2 + 5x3 + 7x4
soggetto a
3x1 + 7x2 + 2x3 + 9x4 ≤258
6x1 + 3x2 + 9x3 −6x4 ≤721
2x1 + 1x2 + 5x3 + 5x4 ≤524
3x1 + 6x2 + 2x3 + 3x4 ≤411
4x1 −8x2 −4x3 + 4x4 ≤685

---
layout: 
title: Pagina 236
level: 3
---


Problemi di ottimizzazione
220
Soluzione iniziale
2
1
X
Soluzione ottimale
Algoritmo per l'arco di collina
X
Funzione obiettivo
Figura 15.8: la rappresentazione dello spazio euclideo di un programma lineare con n = 2.
Rappresentazione della matrice: un programma lineare può essere espresso in modo molto compatto usando
Algebra Matrix.Lascia che n denoti il ​​numero di variabili e m il numero di vincoli.Lascia che una riga di n coefficienti nella funzione obiettivo indichi m denotare
La matrice con le righe e le colonne di coefficienti sul lato sinistro dei vincoli, lascia che B denota la colonna di coefficienti m sul lato destro dei vincoli e infine lasciano x denotare la colonna di variabili N.Quindi l'obiettivo del lineare
Il programma è massimizzare a · x soggetto a m · x ≤b.
Flussi di rete: il problema di flusso di rete può essere espresso come istanze di lineare
programmazione.Vedi Esercizio 15.4.1.
L'interpretazione dello spazio euclideo: ogni possibile soluzione, dando valori al
Variabili x1 ,..., XN, può essere visto come un punto nello spazio n-dimensionale.Questo spazio è
più facile da vedere quando ci sono solo due o tre dimensioni, ma le stesse idee tengono
per qualsiasi numero di variabili.
Vincoli: ogni vincolo specifica un limite nello spazio, su un lato del quale
Una soluzione valida deve mentire.Quando n = 2, questo vincolo è una linea unidimensionale.
Vedi Figura 15.8.Quando n = 3, è un piano bidimensionale, come il lato di una scatola.
In generale, è uno spazio (n −1)-dimensionale.Lo spazio delimitato da tutti i
I vincoli sono chiamati poliedrici.
Vertici: il confine del poliedrico è definito dai vertici in cui un numero
di vincoli si intersecano.Quandon = 2, le coppie di vincoli di linea si intersecano su un vertice.
Vedi Figura 15.8.Per n = 3, tre lati di una scatola definiscono un vertice (angolo).Generalmente,

---
layout: 
title: Pagina 237
level: 3
---


Flussi di rete e programmazione lineare
221
Richiede n vincoli per intersecare per definire un singolo vertice.Questo perché dicendo che la soluzione è sul vincolo sta dicendo che l'equazione lineare tiene
con uguaglianza e non con "meno o uguale a".Quindi ricorda che n equazioni lineari con n incognite sono sufficienti per specificare una soluzione unica.
La funzione obiettivo: la funzione obiettivo fornisce una direzione in euclideo
spazio.L'obiettivo è trovare un punto nel poliedrico limitato che è il più lontano
in questa direzione.Il modo migliore per visualizzare questo è ruotare lo spazio euclideo
in modo che la funzione obiettivo punta direttamente.L'obiettivo è trovare un punto in
poliedrico limitato che è il più alto possibile.
Un vertice è una soluzione ottimale: come puoi immaginare guardando la Figura 15.8, se esiste una soluzione unica, sarà su un vertice in cui si incontreranno vincoli.Se ci
è un'intera regione di soluzioni equivalentemente ottimali, quindi almeno una di esse lo farà
essere un vertice.La nostra ricerca di una soluzione ottimale si concentrerà su questi vertici.
L'algoritmo per l'arrampicata in collina: l'ovvio algoritmo sale semplicemente la collina
formato dall'esterno del poliedrico limitato fino a raggiungere la parte superiore.Nel definire
Un algoritmo di arricchi di collina per la programmazione lineare dobbiamo solo escogitare un modo per trovare
una soluzione valida iniziale e per definire ciò che costituisce un passo per una soluzione migliore.
Un passo: supponiamo, dall'anda invariante, abbiamo una soluzione che, oltre a
Essere validi, è anche un vertice del poliedrico delimitante.Più formalmente, la soluzione soddisfa tutti i vincoli e soddisfa N dei vincoli con l'uguaglianza.
Un passo comporterà l'arrampicata lungo il bordo (linea monodimensionale) tra due
vertici adiacenti.Ciò implica rilassare uno dei vincoli che si incontrano
l'uguaglianza, in modo che non si incontrasse più con l'uguaglianza e stringe uno dei vincoli che non sono stati accolti con l'uguaglianza in modo che ora sia accolta con l'uguaglianza.Questo è
Chiamato si chiama pivot out un'equazione e in un'altra.La nuova soluzione lo farà
Sii la soluzione unica che soddisfa l'uguaglianza delle equazioni di N attualmente selezionate.Naturalmente, ad ogni iterazione tale passo può essere fatto solo se continua a farlo
Soddisfa tutti i vincoli e migliora la funzione obiettivo.Ci sono veloci
modi per trovare un buon passo da fare.Tuttavia, anche se non si conosci, lì
sono solo n · m scelte di passaggi da provare, quando ci sono n variabili ed equazioni M.
Trovare una soluzione valida iniziale: se siamo fortunati, l'origine sarà una soluzione valida.Tuttavia, in generale, trovare una soluzione valida è essa stessa un problema impegnativo.Il nostro algoritmo per farlo sarà un algoritmo iterativo che include i vincoli uno alla volta.Supponiamo di avere una soluzione di vertice che soddisfa tutto
vincoli nell'esempio 15.4.1 tranne l'ultimo.Tratteremo quindi il negativo
di questo prossimo vincolo come funzione obiettivo, vale a dire −4x1 + 8x2 + 4x3 −4x4.
Gestiamo il nostro algoritmo per l'arrampicata in collina, a partire dal vertice che abbiamo, fino a
Abbiamo una soluzione di vertice che massimizza questa nuova funzione oggettiva soggetta a
Le prime equazioni.Ciò equivale a ridurre al minimo l'obiettivo 4x1 −8x2 -
4x3 + 4x4.Se il suo minimo è inferiore a 685, allora abbiamo trovato una soluzione di vertice

---
layout: 
title: Pagina 238
level: 3
---


Problemi di ottimizzazione
222
Ciò soddisfa le prime equazioni I + 1.In caso contrario, abbiamo determinato che no
esiste tale soluzione.
Non è massimo il massimo locale: per dimostrare che l'algoritmo alla fine trova un globale
Massimo, dobbiamo dimostrare che non rimarrà bloccato in un piccolo massimo locale.
Convesso: perché il poliedrico limitato è l'intersezione di tagli dritti, esso
è ciò che chiamiamo convesso.Più formalmente, ciò significa che la linea tra due
I punti nel poliedrico sono anche nel poliedrico.Ciò significa che non ci può
essere due punti massimi locali, perché tra queste due colline ci sarebbe bisogno
Essere una valle e una linea tra due punti attraverso questa valle sarebbe fuori
il poliedrico.
Il metodo primordiale -duale: il metodo primordiale dimostra formalmente che a
si troverà il massimo globale.Dato qualsiasi programma lineare, definito da una funzione di ottimizzazione e da una serie di vincoli, esiste un modo per formare il suo programma lineare a doppia minimizzazione.Ogni soluzione a questo doppio funge da tetto o limite superiore
su quanto può essere alta la soluzione primordiale.Quindi ogni iterazione trova una migliore
soluzione per il primal o fornisce una soluzione per il programma Dual Linear con a
valore corrispondente.Questa doppia soluzione è testimone del fatto che nessuna soluzione primordiale lo è
più grande.
Formando il doppio: se il programma lineare primordiale deve massimizzare a · x soggetto a mx ≤b, allora il doppio è ridurre al minimo Bt · y soggetto a mt · y ≥a t, dove bt, mt e a t sono i traspostiformato da righe intrecciate e
colonne.Il doppio dell'esempio 15.4.1 è
minimizzare
258 + 721y2 + 524y3 + 411y4 + 685y5
soggetto a
3y1 + 6y2 + 2y3 + 3y4 + 4y5 ≥7
7y1 + 3y2 + 1y3 + 6y4 −8y5 ≥ -6
2y1 + 9y2 + 5y3 + 2y4 −4y5 ≥5
9y1 −6y2 + 5y3 + 3y4 + 4y5 ≥7
Il doppio avrà una variabile per ciascun vincolo nel primal e un vincolo per ciascuna delle sue variabili.I coefficienti della funzione oggettiva diventano i numeri sui lati di destra delle disuguaglianze e i numeri sui lati di destra delle disuguaglianze diventano i coefficienti di
la funzione obiettivo.Infine, "massimizzare" diventa "minimizza".Il doppio è
Lo stesso dell'originale primordiale.
CONSIGLIO UST: Dimostriamo che il valore di qualsiasi soluzione al lineare primordiale
Il programma è al massimo il valore di qualsiasi soluzione al programma Dual Linear.IL
Il valore della soluzione primordiale x è a · x.I vincoli mt · y ≥a t possono essere

---
layout: 
title: Pagina 239
level: 3
---


Flussi di rete e programmazione lineare
223
Girato per dare un ≤yt · M. Questo dà che a · x ≤yt · m · x.Usando il
vincoli mx ≤b, questo è al massimo · b.Questo può essere girato per dare
Bt · y, che è il valore della doppia soluzione y.
Tempo di esecuzione: l'algoritmo primordiale per l'arco di collina è garantito per trovare il
soluzione ottimale.In pratica, funziona rapidamente (anche se per il mio lavoro estivo, i computer si sarebbero fatti a pezzi per ore).Tuttavia, non esiste un algoritmo di blocco delle colline conosciuto
Ciò è garantito per funzionare in tempo polinomiale.
C'è un altro algoritmo che risolve questo problema, chiamato ellissoide
metodo.Praticamente, non è così veloce, ma teoricamente funziona in polinomio
tempo.
Esercizio 15.4.1
Esprimi l'istanza di flusso di rete nella Figura 15.2 come lineare
programma.
15.5
Esercizi
Esercizio 15.5.1 (vedi soluzione nella parte cinque.) Sia g = (l ∪r, e) un grafico bipartito
con i nodi L a sinistra e R a destra.Una corrispondenza è un sottoinsieme dei bordi come
che ogni nodo appare al massimo una volta.Per qualsiasi A ⊆l, lascia che n (a) sia il set di quartiere
di a, vale a dire n (a) = {v ∈R |∃u ∈A tale che (u, v) ∈E}.Dimostrare il teorema di Hall, che
afferma che esiste una corrispondenza in cui ogni nodo in L è abbinato se e solo se
∀a ⊆l, | a |≤ | n (a) |.
1.
Per ciascuno dei seguenti due grafici bipartiti, dai un breve testimone al
Il fatto che abbia una corrispondenza perfetta o al fatto che non lo fa.Usa il teorema di Hall
Nella tua spiegazione perché un grafico non ha una corrispondenza.Non c'è bisogno di menzionare
fluisce o tagli.
1
5
4
3
2
UN
B
C
D
E
1
5
4
3
2
UN
B
C
D
E
2.
⇒: Supponiamo che esista una corrispondenza in cui è abbinato ogni nodo in L.Foru ∈L, Sia m (u) ∈r specificare uno di questi abbinamento.Dimostrare che ∀a ⊆l, | a |≤ | n (a) |.
3.
La sezione 20.4 descrive una rete con nodi {s} ∪l ∪r ∪ {t} con un bordo diretto
Da S a ciascun nodo in L, i bordi da L a R nel grafico bipartito diretto
da L a R e un bordo diretto da ciascun nodo in r tot.Le note danno ogni vantaggio
Capacità 1. Tuttavia, i bordi ⟨u, v⟩across Il grafico bipartito potrebbe anche essere
Data capacità ∞.Considera un po 'di taglio (u, v) in questa rete.Nota che u contiene
S, alcuni nodi di L e alcuni nodi di R, mentre V contiene i nodi rimanenti

---
layout: 
title: Pagina 240
level: 3
---


Problemi di ottimizzazione
224
di L, i restanti nodi di r e t.Supponiamo che ∀a ⊆l, | a |≤ | n (a) |.Dimostrare
che la capacità di questo taglio, cioè Cap (u, v) =
u∈U

V∈V c⟨u, v⟩, è almeno | l |.
4.
⇐: Supponiamo che ∀a ⊆l, | a |≤ | n (a) |è vero.Dimostrare che esiste una corrispondenza
che ogni nodo in L è abbinato.(Suggerimento: usa tutto ciò che sai sulla rete
flussi.)
5.
Supponiamo che ci sia un numero intero k ≥1 in modo tale che ogni nodo in l abbia una laurea
almeno K e ogni nodo in R ha una laurea al massimo k.Dimostrare che esiste una corrispondenza
in cui è abbinato ogni nodo in L.

---
layout: 
title: Pagina 241
level: 3
---


225
16 algoritmi avidi
Ogni due anni conosce l'algoritmo avido.Per ottenere quello che vuoi, inizia
Afferrare ciò che sembra migliore.
16.1
Astrazioni, tecniche e teoria
Specifiche: un numero molto selezionato di problemi di ottimizzazione può essere risolto utilizzando
Un algoritmo avido.La maggior parte di questi ha la seguente forma.
Precondizionismo: ci viene data una delle seguenti istanze.
Istanze: un'istanza è costituita da un insieme di oggetti e una relazione tra
loro.Pensa agli oggetti come a premi che devi scegliere.
Postcondition: data un'istanza, l'obiettivo è trovare una delle soluzioni valide per
questa istanza con ottimale (minimo o massimo come può essere) misura)
di successo.(La soluzione da produrre non deve essere unica.)
Soluzioni ad esempio: una soluzione richiede l'algoritmo per fare una scelta
Informazioni su ciascuno degli oggetti nell'istanza.A volte, questa scelta è complessa, ma di solito è semplicemente se mantenerla.In questo caso, una soluzione è il
sottoinsieme degli oggetti che hai mantenuto.La cattura è che alcuni sottoinsiemi lo sono
Non consentiti perché questi oggetti si confondono in qualche modo tra loro.
Misura del successo: ogni soluzione viene assegnata un costo o una misura del successo.
Spesso, quando una soluzione è costituita da un sottoinsieme non ombelico degli oggetti, questo

---
layout: 
title: Pagina 242
level: 3
---


Problemi di ottimizzazione
226
La misura è il numero di oggetti nel sottoinsieme o la somma dei costi
singoli oggetti.A volte la misura è una funzione più complessa.
L'algoritmo della forza bruta (esponenziale
Tempo): l'algoritmo della forza bruta per un problema di ottimizzazione considera ogni possibile soluzione
Per la data istanza, calcola il suo costo e
Output il più economico.Perché ogni istanza
ha un numero esponenziale di soluzioni, questo
L'algoritmo richiede tempo esponenziale.
La scelta avida: il passo avido è il primo che mi viene in mente quando si progette un algoritmo per un problema.Dato l'insieme di oggetti specificati nell'ingresso
Ad esempio, il passo avido sceglie e si impegna a uno di questi oggetti perché, secondo alcuni semplici criteri, sembra essere il migliore.Quando si dimostra che l'algoritmo funziona, dobbiamo essere in grado di dimostrare che questa scelta localmente avida non ha
conseguenze globali negative.
Esempio 16.1.1
Lo spettacolo di gioco
Supponiamo che l'istanza specifichi un insieme di premi e
un intero m e consente di scegliere m del
Premi.Il criterio, secondo il quale alcuni
Di questi premi sembrano essere migliori di altri, potrebbe essere il suo prezzo in dollari, la quantità di gioia che farebbe
Portati, quanto è pratico o quanto
impressionerebbe i vicini.All'inizio sembra ovvio che dovresti scegliere il tuo primo premio usando l'approccio avido.Tuttavia, alcuni di questi
i premi si confondono tra loro e (come lo è spesso
il caso della vita) devono essere fatti compromessi.Ad esempio, se prendi la piscina, allora
Il tuo cortile è troppo pieno per poter prendere molti degli altri premi.Un leone potrebbe impressionare
I tuoi vicini, ma potrebbe mangiare il tuo cane.Come è vero anche nella vita, a volte è difficile
Guarda nel futuro e prevedi le rami ﬁ che delle scelte fatte oggi.
Esempio 16.1.2
Apportare modifiche
L'obiettivo di questo problema di ottimizzazione è quello di trovare il numero minimo di trimestri, dam, nichel e centesimi che vanno in totale a un determinato importo.Un'istanza è composta da
un insieme di oggetti e una relazione tra loro.Qui, il set è una grande pila di
Le monete e la relazione è che le monete scelte devono totale all'importo dato.
Il costo di una soluzione, che deve essere minimizzato, è il numero di monete in
soluzione.

---
layout: 
title: Pagina 243
level: 3
---


Algoritmi avidi
227
Esempio 16.1.2
Apportare modifiche (cont.)
La scelta avida: la moneta che sembra essere meglio prendere è un quarto, perché è
fa più progressi per rendere il nostro importo richiesto incorrendo solo a
costo di uno.
Una scelta valida: prima di impegnarci in un quarto, dobbiamo assicurarci che non lo faccia
conflitto con la possibilità di arrivare a una soluzione valida.Se la somma da ottenere
capita di essere inferiore a $ 0,25, quindi questo trimestre dovrebbe essere respinto, anche se questo
Appare al primo posto per essere il migliore.D'altra parte, se l'importo è almeno $ 0,25, allora noi
può impegnarsi nel trimestre senza invalidare la soluzione che stiamo costruendo.
Porta a una soluzione ottimale: una domanda molto più difficile e sottile è
Il fatto che impegnarci in un quarto ci porta o meno a ottenere una soluzione ottimale.In questo caso, succede che lo fa, anche se questo non è affatto ovvio.
Andare storto: supponiamo che il problema sia generalizzato per includere come parte dell'input
L'insieme di denominazioni di monete disponibili.Quindi l'algoritmo avido non funziona.Per
Esempio, supponiamo di avere monete da 4, 3- e 1 centesimi.Se l'importo dato è 6, rispetto al
La soluzione ottimale contiene due monete da 3 centesimi.Andiamo storti impegnandoci avidamente in un
Moneta da 4 centesimi.
Prova della correttezza usando loop invarianti: impegnarsi nel pool, al
Il leone, o alla moneta a 4 centesimi, sebbene sembri localmente essere gli oggetti migliori, non lo fa
portare a una soluzione ottimale.Tuttavia, per alcuni problemi e per alcune definizioni
Di "Best", l'algoritmo avido funziona.Quando non funziona, lo dimostreremo
Usando un semplice controesempio come abbiamo fatto sopra.Quando funziona, lo dimostreremo
Usando lo stesso metodo con cui dimostriamo tutti gli algoritmi iterativi corretti: loop
invarianti.
Passaggi principali: ogni iterazione l'algoritmo sceglie l'oggetto migliore tra
Quelli non considerati finora e si impegnano o lo rifiuta.
Fai progressi: è stato considerato un altro oggetto.
Condizione di uscita: tutti gli oggetti sono stati considerati.
Loop Invariant: ricorda che un ciclo invariante fa una dichiarazione ogni volta che l'algoritmo è in cima al ciclo su ciò che ha realizzato.Finora l'algoritmo ha fatto un'iterazione, durante la quale si è impegnata in uno dei
oggetti.Quale affermazione vogliamo fare su questa azione?
Tipi di invarianti ad anello: per trovare un buon ciclo invarianti, iniziamo da
Considerando i tipi di invarianti ad anello considerati nella sezione 1.4.Si scopre che
Il nostro loop invariante prescelto sarà del tipo di spazio restrittivo.
Più output: ricorda che gli stati invarianti del loop più output
che sono stati prodotti i primi elementi dell'output e l'output

---
layout: 
title: Pagina 244
level: 3
---


Problemi di ottimizzazione
228
Costruito finora è corretto.Nel caso di algoritmi avidi, l'output è un
Decisione su ciascun oggetto e l'algoritmo prende un'altra decisione ogni iterazione.Pertanto, la prima parte dell'invariante in loop viene facilmente mantenuta.Tuttavia, cosa significa anche per l'output costruito finora per essere corretto?
Nessun conflitto ancora: se il nostro obiettivo è ottenere una soluzione che non ha conflitti, a
Il buon ciclo invariante potrebbe essere che negli impegni presi finora non ci sono conflitti.Il problema è che gli impegni assunti
Finora potrebbe aver appoggiato l'algoritmo in un angolo in modo che futuri conflitti
sono inevitabili.Vedi Esercizio 16.1.3.
La postcondition come invariante in loop: la postconditazione è che l'algoritmo si è impegnato in una soluzione ottimale.Tuttavia, a questo punto non possiamo parlare della "soluzione" dell'algoritmo perché prima che l'algoritmo lo completasse potrebbe aver già preso alcuni impegni, ma questo lavoro parziale
non costituisce ancora una soluzione valida.
Ottimale finora: l'invariante in loop potrebbe essere “ciò che ha fatto l'algoritmo
Finora è ottimale. "Tuttavia, essere ottimale è una proprietà di soluzioni complete e
Non ne abbiamo ancora uno.
Più dell'input: ricorda che l'invariante invariante del loop più del settore afferma che se
Facciamo finta che il prefinito dell'input letta finora dall'algoritmo sia l'intero input, quindi l'algoritmo abbia una soluzione ottimale.Anche se questo è allettante, lo fa
non funziona.Quello che hai è ottimale all'interno di questa parte dell'istanza è solo
una proprietà locale.Non garantirà necessariamente l'ottimalità globale.Ad esempio, se
L'input del gioco del gioco mostrava solo un leone, quindi ottimale
La soluzione sarebbe quella di prendere il leone.Tuttavia, quando ci sono anche più oggetti, il leone non fa parte della soluzione.Allo stesso modo, nel cambiamento del cambiamento con
Monete da 4, 3- e 1 centesimi, se l'ingresso deve rendere l'importo 4, allora si dovrebbe
prendere un 4;Ma non se l'input deve rendere l'importo 6.
Restringendo lo spazio di ricerca: richiamare il tipo di spazio di resistenza di ricerca
Loop invariant.Mentre cerca qualcosa, l'algoritmo restringe la ricerca
spazio.L'anda invariante è "se la cosa che viene cercata è ovunque, allora
è in questo spazio di ricerca ristretto. "Gli algoritmi avidi sono in realtà alla ricerca di un
Soluzione ottimale dallo spazio di ricerca di tutte le possibili soluzioni.Ogni volta il
L'algoritmo si impegna a qualcosa, l'insieme di possibili soluzioni che potrebbe ancora
L'output si restringe a coloro che sono coerenti con le decisioni prese finora.Un invariante a loop naturale sarebbe quindi “se la soluzione ottimale viene cercata
Ovunque, allora è coerente con le decisioni prese finora. "
"La" soluzione ottimale contiene l'oggetto "migliore": prima di impegnarsi
l'oggetto apparentemente migliore o prendere la prima decisione, dobbiamo dimostrarlo
Non andiamo male facendo così.Come primo tentativo, potremmo provare a dimostrare
quello per ogni insieme di oggetti che potrebbero essere dati come istanza, il "migliore" di

---
layout: 
title: Pagina 245
level: 3
---


Algoritmi avidi
229
Questi oggetti sono definitivamente nella sua soluzione ottimale.Il problema con questo è
che potrebbe esserci più di una soluzione ottimale.Potrebbe non essere il caso
che tutti contengono l'oggetto scelto.
Almeno una soluzione ottimale rimanente: invece di richiedere tutto ottimale
soluzioni per contenere l'oggetto "migliore", ciò che dobbiamo dimostrare è almeno
uno fa.L'effetto di questo è che, sebbene si impegni con l'oggetto "migliore"
può eliminare la possibilità di alcune delle soluzioni ottimali, non lo fa
eliminarli tutti.C'è il detto: "Non bruciare i ponti dietro
Voi."Il messaggio qui è leggermente diverso.Va bene.per bruciare alcuni dei tuoi
Bridges fintanto che non li bruci tutti.
Se esiste una soluzione ottimale: per la maggior parte dei problemi, è chiaro che un'istanza ha almeno una soluzione (forse una soluzione banale) e quindi lì
è una soluzione migliore.Quindi, questa prima parte condizionale dell'invariante loop è
di solito lasciato cadere.Sii consapevole, tuttavia, che a volte è necessario.Vedi Esercizio 16.1.3.
Il loop invariante prescelto: per ricapitolare, l'invariante è che non siamo andati
sbagliato.Se esiste una soluzione, allora esiste almeno una soluzione ottimale coerente con
Le scelte fatte finora.
Il secondo passo: dopo che l'oggetto "migliore" è stato scelto e impegnato, il
L'algoritmo deve continuare e scegliere gli oggetti rimanenti per la soluzione.Puoi
Pensa a questo processo all'interno del paradigma iterativo o ricorsivo.Anche se
L'algoritmo risultante è (di solito) uguale, con i diversi paradigmi al tuo
lo smaltimento può essere utile.
Iterativo: nella versione iterativa, c'è un ciclo principale.Ad ogni iterazione, tu
Scegli il meglio tra gli oggetti che non sono ancora stati considerati.
L'algoritmo si impegna quindi a una scelta su questo oggetto.Di solito, ciò implica decidere se impegnarsi a mettere questo oggetto scelto nella soluzione
o per impegnarsi a rifiutarlo.
Una scelta valida: il motivo più comune è che si confonde con gli oggetti
impegnato in precedenza.Un altro motivo è che l'oggetto non riesce a requisiti che non sono già riempiti dagli oggetti già impegnati.
Non può prevedere il futuro: ad ogni passo, la scelta che viene fatta può dipendere
sulle scelte che sono state fatte in passato, ma non può dipendere dal
scelte che verranno fatte in futuro.Per questo motivo, nessun backtracking lo è
necessario.
Esempio di cambiamento: l'algoritmo avido per trovare il minimo
Il numero di monete sommando a un determinato importo è il seguente.Impegnarsi a

---
layout: 
title: Pagina 246
level: 3
---


Problemi di ottimizzazione
230
Quarto fino al trimestre successivo aumenta la somma corrente al di sopra dell'importo richiesto.Quindi rifiutare i quarti rimanenti.Quindi fai lo stesso con
i Dimes, i nichel e i penny.
Ricorsivo: un algoritmo avido ricorsivo fa una prima scelta avida e poi si riprende una o due volte per risolvere la subinstance rimanente.
Esempio di modifica: dopo esserci impegnati in un quarto, potremmo sottrarre
$ 0,25 dall'importo richiesto e chiedi a un amico di trovare il numero minimo di monete per effettuare questo nuovo importo.La nostra soluzione sarà la sua soluzione Plus
Il nostro quartiere originale.
Esempio di albero di ricerca binaria: la versione ricorsiva di un algoritmo avido è
Più utile quando è necessario ricorrere più di una volta.Ad esempio, supponiamo di voler costruire un albero di ricerca binario per una serie di chiavi che minimizzano l'altezza totale dell'albero, cioè un albero equilibrato.L'algoritmo avido
si impegnerà per la chiave centrale alla radice.Quindi si riprenderà una volta per
la sottostruttura sinistra e una volta per la destra.
Per saperne di più su come ricorrere dopo che è stata fatta la scelta avida, vedi
Gli algoritmi ricorsivi di backtracking nel capitolo 17.
Prova della correttezza: gli stessi algoritmi avidi sono molto facili da capire
e per codificare.Se la tua intuizione è che non dovrebbero funzionare, allora la tua intuizione lo è
corretto.Per la maggior parte dei problemi di ricerca di ottimizzazione, nessun algoritmi avidi che vengono provati
lavoro.Per qualche miracolo, tuttavia, per alcuni problemi c'è un algoritmo avido che
lavori.La prova che funzionano, tuttavia, è molto sottile e difficile.Come per tutti gli algoritmi iterativi, dimostriamo che funzionano usando invarianti loop.
Una prova formale: il capitolo 1 dimostra che un algoritmo iterativo funziona se l'invariante ad anello può essere stabilito e mantenuto e da esso la postconditazione può essere
dimostrato.L'anello invariante qui è che l'algoritmo non è andato storto: c'è
Almeno una soluzione ottimale coerente con le scelte fatte finora.Questo è stabilito (⟨pre⟩ → ⟨li⟩) rilevando che inizialmente non sono state fatte scelte e
Quindi tutte le soluzioni ottimali sono coerenti con queste scelte.Il ciclo invariante
viene mantenuto (⟨li ′⟩ & not ⟨exit⟩ & codeloop → ⟨li ′ ′⟩) come segue.Se è vero quando
Nella parte superiore del ciclo, quindi Lascia che Optsli denoti una di queste soluzione.codeloop durante
La prossima iterazione si impegna o rifiuta il prossimo oggetto migliore.La prova
descrive un metodo per modificare Optsli in Optsours e dimostra che questo è un
Soluzione valida, è coerente sia con le scelte fatte in precedenza dall'algoritmo e con questa nuova scelta ed è ottimale.L'esistenza di un tale opzione
dimostra che l'invariante in loop è stato mantenuto.L'ultimo passo è dimostrarlo
Alla fine, l'algoritmo ha una soluzione ottimale concreta (⟨li⟩ & ⟨exit⟩ → ⟨post⟩).
I progressi vengono compiuti ad ogni passo impegnandosi o rifiutando un altro oggetto.Quando
Ogni oggetto è stato preso in considerazione, l'algoritmo esce.Queste scelte specificano un file

---
layout: 
title: Pagina 247
level: 3
---


Algoritmi avidi
231
soluzione.Gli stati invarianti in loop esiste una soluzione ottimale coerente con
queste scelte.Pertanto, la soluzione ottenuta deve essere ottimale.
Ora rifaremo la prova in modo più intuitivo, divertente e dettagliato.
Il ciclo invariante: il ciclo invariante mantenuto è che non siamo andati
sbagliato.Esiste almeno una soluzione ottimale coerente con le scelte fatte
Finora, cioè contenente gli oggetti impegnati finora e non contenenti il
Oggetti respinti finora.
Tre giocatori: per aiutare a capire questa prova, racconteremo una storia che coinvolge tre
Personaggi: l'algoritmo, il Prover e una fata madrina.
L'algoritmo: ad ogni iterazione, l'algoritmo sceglie l'oggetto migliore da
Tra quelli non considerati finora e si impegnano o lo rifiuta.
The Prover: il compito di Prover è quello di dimostrare che l'invariante in loop è mantenuto.Avere un prover separato sottolinea questo fatto che le sue azioni sono
non una parte dell'algoritmo e quindi non è necessario essere codificati o eseguiti.
La fata madrina: invece del Prover che finge di aver e lo è
Manipolando un'ipotetica soluzione ottimale optsli, può fingere che lui
ha una fata madrina che detiene e manipola una per lui.Lo diciamo
Questa soluzione assiste al fatto che esiste una tale soluzione.Avere una fata separata
Godmother sottolinea che né l'algoritmo né il Prover effettivamente
conosce la soluzione.
Inizialmente (⟨pre⟩ → ⟨li⟩): inizialmente, l'algoritmo non ha fatto scelte, né
Impegnarsi in né rifiutare alcun oggetto.Il prover sta quindi stabilisce il ciclo
invariante come segue.Supponendo che esista almeno una soluzione legale, lo sa
Che deve esserci una soluzione ottimale.Continua notando che questa soluzione ottimale per impostazione predefinita è coerente con le scelte fatte finora, perché nessuna scelta
sono stati fatti finora.Sapendo che esiste una tale soluzione, chiede gentilmente il Prover
Sua fata madrina per trovarne una.Lei, essendo onnipotente, non ha problemi a fare

---
layout: 
title: Pagina 248
level: 3
---


Problemi di ottimizzazione
232
Questo.Se ci sono più di una soluzioni ottimali altrettanto buone, allora sceglie
uno arbitrariamente.
Mantenimento dell'invariante in loop (⟨li′⟩ & non ⟨exit⟩ & codeloop → ⟨li′′⟩): ora considera un'iterazione arbitraria.
Quello che sappiamo: all'inizio di questa iterazione, l'algoritmo ha un set
Commettere oggetti impegnati finora, e un set rifiuto di oggetti respinti
lontano.Il prover sa che l'invariante in loop è vero, cioè che c'è a
almeno una soluzione ottimale coerente con queste scelte fatte finora;Tuttavia, non ne conosce uno.Testimoniando che ce n'è uno, la fata madrina
sta trattenendo una soluzione ottimale.Useremo Optsli per indicare la soluzione che detiene.Oltre a contenere quegli oggetti in commit e
non quelli in rifiuto, questa soluzione può contenere oggetti che ha l'algoritmo
non ancora considerato.
Facendo un passo: durante l'iterazione, l'algoritmo procede a scegliere il
migliore oggetto tra quelli non considerati finora e si impegnano a
lo rifiuta o lo rifiuta.Al fine di dimostrare che l'invariante in loop è stato mantenuto, il prover deve dimostrare che esiste almeno una soluzione ottimale coerente
Con entrambe le scelte fatte in precedenza e questa nuova scelta.Lui sta per
Fai questo ottenendo la sua fata madrina per assistere a questo fatto passando a una soluzione così ottimale.
Debolezza nella comunicazione: sarebbe bello se il prover potesse semplicemente
Chiedi alla fata madrina se esiste una tale soluzione.Tuttavia, non può
Chiedile di trovare una soluzione del genere se non è già convinto che esiste, perché non vuole chiederle di fare nulla di impossibile.
Modifica le istruzioni: il Prover svolge il suo compito dando la sua fata
Istruzioni dettagliate della madrina.Comincia dicendo: "Se capita
Il caso che la soluzione ottimale che si dispone è coerente con questo nuovo
Scelta che è stata fatta, allora abbiamo finito, perché questo testimonia il fatto
che esiste almeno una soluzione ottimale coerente con entrambe le scelte
fatto in precedenza e questa nuova scelta. ""Altrimenti", dice, "devi modificare la soluzione ottimale che hai nei seguenti modi."La fata madrina segue le istruzioni dettagliate che le dà, ma non gli dà no
Feedback su come vanno.Useremo Optsours per indicare ciò che costruisce.
Esempio di modifica: se l'importo rimanente richiesto è almeno
$ 0,25, quindi l'algoritmo si impegna a un altro trimestre.Escluso il
monete impegnate, la soluzione ottimale della fata madrina Optsli deve
inventare lo stesso importo rimanente.Questo importo deve contenere
O un ulteriore trimestre, tre dimagni, due dimagni e un nichel, uno
Dime e tre nichel, cinque nichel o combinazioni con almeno cinque anni

---
layout: 
title: Pagina 249
level: 3
---


Algoritmi avidi
233
Pennie.Il prover le dice di sostituire i tre digni con il nuovo
impegnato nel trimestre e nichel e le altre opzioni con solo il
trimestre.Se l'algoritmo, d'altra parte, rifiuta il successivo (e successivamente
tutti rimanenti) quarti perché l'importo rimanente richiesto è inferiore
di $ 0,25, quindi il prover è convinto che una soluzione ottimale detenuta da
Anche la sua fata madrina non può contenere ulteriori alloggi.
Dimostrando che ha un testimone: è compito di Prover dimostrare che il
la cosa si oppone che la sua fata madrina ora detiene è valida, coerente e
soluzione ottimale.
Dimostrando una soluzione valida: perché sa che era stata
Holding, Optsli, all'inizio dell'iterazione era una soluzione valida, sa che gli oggetti in essa non si confondevano in alcun modo.Quindi, tutto lui
bisogna fare è dimostrare che non ha introdotto alcun conflitto che ha fatto
non ﬁ x.
Esempio di cambiamento: il prover è stato attento che i cambiamenti lui
Made non ha modificato l'importo totale che stava tenendo.
Dimostrando coerenza: deve anche dimostrare che la soluzione è ora
La detenzione è coerente sia con le scelte fatte in precedenza dall'algoritmo e con questa nuova scelta.Perché sa che quello che aveva
in possesso era coerente con le scelte precedenti, ne deve solo farlo
dimostrare che lo ha modificato per essere coerente con le nuove scelte senza
incasinare quelli precedenti.
Esempio di modifica: sebbene il prover possa aver rimosso un po '
delle monete che l'algoritmo non ha ancora considerato, non era sicuro
per farla rimuovere una qualsiasi delle monete precedentemente impegnate.Ha anche
gestito ad aggiungere il quartiere appena impegnato.
Dimostrare ottimale: potresti pensare che dimostrare che la soluzione si oppone
è ottimale sarebbe difficile, dato che non sappiamo nemmeno il costo di
una soluzione ottimale.Tuttavia, il Prover può essere assicurato che è ottimale fintanto che il suo costo è lo stesso della soluzione ottimale, Optsli, da
che derivava.Se ci fosse un caso in cui il prover è gestito
Per migliorare la soluzione, allora ciò contraddice il fatto che Optsli sia
ottimale.Questa contraddizione dimostra solo che tale caso non si verificherà.
Tuttavia, il Prover non ha bisogno di preoccuparsi di questo problema.
Esempio di cambiamento: ogni cambiamento che il prover istruisce la sua fata
Madrina per rendere lo stesso il numero di monete o diminuisce il numero.Quindi, poiché Optsli è ottimale, lo è anche Optsours.

---
layout: 
title: Pagina 250
level: 3
---


Problemi di ottimizzazione
234
Questo completa la prova di Prover che la sua fata madrina ora ha una soluzione ottimale coerente sia con le scelte precedenti che con le ultime
scelta.Ciò assiste al fatto che esiste una tale soluzione.
Ciò dimostra che l'invariante in loop è stato mantenuto.
Continua: questo completa i requisiti di tutti per questa iterazione.IL
Il processo viene ripetuto più e più volte.Ogni iterazione, l'algoritmo si impegna
di più sulla soluzione e la soluzione della fata madrina è cambiata per essere
coerente con questi impegni.
Usciondo loop (⟨li⟩ & ⟨exit⟩ → ⟨post⟩): dopo che l'algoritmo ha considerato tutti
oggetto in istanza e ciascuno è stato impegnato o rifiutato, il
Algoritmo esce.Sappiamo ancora che l'invariante in loop è vero.Quindi, il Prover
sa che esiste un programma ottimale optsli coerente con tutti questi
scelte.In precedenza, questa soluzione ottimale era immaginata solo.Tuttavia, ora noi
Sappi concretamente che questa soluzione immaginata è costituita da quegli oggetti commessi
A.Quindi, l'algoritmo può restituire questo set come soluzione.
Tempo di esecuzione: gli algoritmi avidi sono molto veloci, perché prendono solo un piccolo
quantità di tempo per oggetto nell'istanza.
Priorità fissa vs. adattativa: gli algoritmi avidi iterativi sono disponibili in due pavimenti, fissati
priorità e priorità adattativa.
Priorità fissa: un algoritmo avido a priorità fissata inizia ordinando gli oggetti in
L'istanza di input dal migliore al peggiore secondo un criterio avido fisso.Per
Esempio, potrebbe ordinare gli oggetti in base al costo dell'oggetto o all'arrivo
tempo dell'oggetto.L'algoritmo quindi considera gli oggetti uno alla volta in questo
ordine.
Priorità adattiva: con una priorità adattiva algoritmo avido, il criterio avido
non è fisso, ma dipende da quali oggetti sono stati impegnati finora.A
Ogni passo, l'oggetto migliore successivo viene scelto secondo l'attuale criterio avido.La ricerca cieca all'elenco rimanente di oggetti ogni iterazione per l'oggetto successivo sarebbe troppo dispendioso in termini di tempo.Così ribatterebbe gli oggetti ciascuno
iterazione secondo il nuovo criterio avido.Un'implementazione più efficace utilizza una coda prioritaria per mantenere i restanti oggetti danno la priorità secondo gli attuali criteri avidi.Questo può essere implementato utilizzando un heap.(Vedere
Sezione 10.4.)
Codice:
Algoritm AdaptiveGreedy (insieme di oggetti)
⟨Pre-Cond⟩: l'input è costituito da un insieme di oggetti.
⟨Post-Cond⟩: l'output è costituito da un sottoinsieme ottimale di essi.

---
layout: 
title: Pagina 251
level: 3
---


Algoritmi avidi
235
inizio
Metti gli oggetti in una coda prioritaria secondo l'avido iniziale
criterio
Commit = ∅% set di oggetti precedentemente impegnati
ciclo continuo
⟨Loop-Invariant⟩: esiste almeno una soluzione ottimale
coerente con le scelte fatte finora
Esci quando la coda prioritaria è vuota
Rimuovere l'oggetto "migliore" dalla coda prioritaria
Se questo oggetto non si confonde con quelli che sono commessi e lo è
necessario, quindi
Aggiungi oggetto per commettere
finisci se
Aggiorna la coda prioritaria per riflettere il nuovo criterio avido
Questo viene fatto modificando le priorità degli oggetti effettuati.
End Loop
restituzione (impegno)
Algoritmo di fine
Esempio: può essere l'algoritmo di percorso più corto di Dijkstra (Sezione 14.3)
considerato un algoritmo avido con criteri prioritari adattivi.Esso
Sceglie il bordo successivo da includere nell'albero ottimale del ponte più corto
Sulla base di quale nodo sembra attualmente il più vicino a s.Quelli ancora da essere
scelti sono organizzati in una coda prioritaria.Anche la prima e la profondità
La ricerca può essere considerata algoritmi avidi adattivi.In effetti, loro
Assomigliano da vicino all'algoritmo minimo-scansione di Prim (sezione 16.2.3), nel modo in cui un albero viene coltivato da un nodo di origine.Sono adattivi in ​​questo come il
L'algoritmo procede, il set da cui viene scelto il bordo successivo.
Esercizio 16.1.1 Abbiamo dimostrato che l'algoritmo avido non funziona per la realizzazione
Problema di cambiamento quando le denominazioni delle monete sono 4, 3 e 1 cent, ma lo fa
Lavora quando le denominazioni sono 25, 10, 5 e 1. Funziona quando le denominazioni sono 25, 10 e 1, senza nichel?
Esercizio 16.1.2 Supponiamo che le denominazioni della moneta siano C1> C2> · ·> Cr nell'ordine preso dall'algoritmo avido.Un problema interessante è determinare se il
L'algoritmo avido funziona.Una risposta completa a questa domanda è troppo difficile.Tuttavia, cosa
Le restrizioni sulle denominazioni di monete sono sufficienti per garantire che l'algoritmo avido funzioni?
Supponiamo, per ogni i, ogni moneta CI è un multiplo intero del prossimo CI+1 più piccolo, ad esempio, 120, 60, 12, 3, 1. Se questo è vero, sappiamo che l'algoritmo avido funziona?Se è
Non è vero, sappiamo che l'algoritmo avido non funziona?

---
layout: 
title: Pagina 252
level: 3
---


Problemi di ottimizzazione
236
R Supponiamo, per ogni i, ogni moneta sia più del doppio del precedente, cioè CI ≥2ci+1.
Sappiamo che l'algoritmo avido funziona?Se questo non è vero, lo sappiamo
L'algoritmo avido non funziona?
R altre caratteristiche interessanti?
Esercizio 16.1.3
Il problema a 2 colori è il seguente: dato qualsiasi grafico Nnode non indirizzato, colora i nodi con due colori in modo che nessun bordo collega due nodi di
Lo stesso colore (cioè i nodi adiacenti hanno sempre colori diversi) o riferiscono che lo è
impossibile.
1.
Un ciclo allettante invariante è “Non ci sono nodi adiacenti dello stesso colore in
la mia soluzione parziale. "Affinché questo sia un buon ciclo invariante, si deve essere
in grado di arrivare da Marte, non sapendo nulla di ciò che ha fatto l'algoritmo
Finora, tranne per il fatto che l'invariante in loop è vero.Da qui quell'algoritmo deve essere
in grado di continuare fino all'ottenimento della postcondizionamento.Dimostra che questo è un cattivo ciclo
invariante come segue:
(a) Fornire un grafico che ha un 2-color valido.
(b) Fornire una colorazione parziale valida che un algoritmo (difettoso) può prevedere
che detiene l'invariante in loop.
(c) Dimostra che l'algoritmo è andato storto perché non ci sono coloranti validi
coerente con questa soluzione parziale.
2.
Questo è un esempio in cui un'istanza potrebbe non avere alcuna soluzione valida.Uno
La possibile tecnica algoritmica è verificare la validità della soluzione dopo tutto il
I nodi sono stati colorati.Un altro è verificare mentre procede, per assicurarsi che il
La colorazione creata non ha errori.(Quale tecnica viene utilizzata nel binario
Algoritmo di ricerca?) Per ciascuna di queste due tecniche, dare un loop invariante e
Quindi dimostrare ⟨pre-Cond⟩ & codealg ⇒⟨post-conf⟩.
3.
Descrivi Brie un algoritmo avido.L'algoritmo dovrebbe essere in grado di gestire i grafici
che non sono connessi.
4.
Il criterio avido è usato adattativo o non adattativo?Deve essere?
5.
Dimostra che viene mantenuto l'invariante in loop.(⟨Loop-invariant ′⟩ & not⟨exit-conf⟩
& Codeloop ⇒⟨Loop-Invariant ′ ′⟩).Assicurati di gestire le condizioni al contorno, ad esempio il
Prima iterazione e grafici che non sono collegati.
6.
Qual è il tempo di esecuzione del tuo algoritmo?
16.2
Esempi di algoritmi avidi
16.2.1 Esempio: il problema di pianificazione del lavoro/eventi
Supponiamo che molte persone vogliano usare la tua sala conferenze per eventi e te
deve programmare il maggior numero possibile di questi.(La versione in cui sono alcuni eventi
Data una priorità più elevata è considerata nella sezione 19.3.) Esaminiamo una priorità fissa
Algoritmo avido.

---
layout: 
title: Pagina 253
level: 3
---


Algoritmi avidi
237
Specifiche:
Precondizionismo: ci viene data una delle seguenti istanze.
Case: un'istanza è ⟨⟨s1, f1⟩, ⟨s2, f2⟩ ,..., ⟨Sn, fn⟩⟩, dove sono 0 ≤Si ≤fi
I tempi di partenza e di conclusione per l'evento ITH.
Postcondition: l'output è una soluzione con il numero massimo di eventi programmati.
Soluzioni: una soluzione per un'istanza è un programma S. Questo è costituito da un sottoinsieme
S ⊆ [1..n] degli eventi che non si confondono da sovrapposizioni nel tempo.
Misura del successo: il successo di una soluzione è il numero di eventi
programmato, cioè | s |.
Possibili criteri per definire "Best":
L'evento più corto Fi -si: sembra che sarebbe meglio programmare eventi brevi
prima, perché aumentano il numero di eventi programmati senza prenotare il
spazio per un lungo periodo di tempo.Questo approccio avido non funziona.
Controesempio: supponiamo che le seguenti righe indichino l'inizio e
Completamento dei tempi di tre eventi da programmare.
Saremo storto per programmare il breve evento nel mezzo, perché
L'unico programma ottimale non lo include.
Il primo orario di inizio Si o l'ultimo tempo di finitura FI: Primo arrivo per la prima volta, che è un algoritmo di programmazione comune, non funziona neanche.
Controesempio:
Il lungo evento è sia il primo che l'ultimo.Impegnarsi nella programmazione
Sarebbe un errore.
L'evento che si confonde con il minor numero di altri eventi: pianificare un evento che conflitte con altri eventi ti impedisce di pianificare questi eventi.Quindi un criterio ragionevole sarebbe quello di programmare il primo evento con il minor numero di conflitti.
Controesempio: nell'esempio seguente, l'evento centrale sarebbe impegnato a prima.Ciò elimina la possibilità di pianificare quattro eventi.

---
layout: 
title: Pagina 254
level: 3
---


Problemi di ottimizzazione
238
Commettere
Figura 16.1: una serie di eventi e quelli impegnati dal primo tempo avido
algoritmo.
Primo tempo di finitura Fi: questo criterio può sembrare un po 'strano al primo posto, ma esso
ha senso.Dice di programmare l'evento che libererà la tua stanza per qualcun altro il prima possibile.Vedremo che questo criterio funziona per ogni serie di
eventi.
Esempio: puoi tracciare questo algoritmo sull'esempio mostrato nella Figura 16.1.
Codice: un algoritmo avido per il problema della pianificazione degli eventi.
Pianificazione dell'algoritmo (⟨⟨s1, f1⟩, ⟨s2, f2⟩,.., ⟨sn, fn⟩⟩)
⟨Pre-Cond⟩: l'input è costituito da un insieme di eventi.
⟨Post-Cond⟩: l'output è costituito da un programma che massimizza il numero di
eventi programmati.
inizio
Ordina gli eventi in base ai loro tempi di finitura Fi
Commit = ∅
% Il set di eventi impegnati per essere nel programma
Loop i = 1...N
% Considera gli eventi in ordine ordinato.
if (evento che non conflitto con un evento in commit)
Commit = commit ∪ {i}
End Loop
restituzione (impegno)
Algoritmo di fine
Il ciclo invariante: l'invariante in loop è che non abbiamo sbagliato: c'è a
almeno una soluzione ottimale coerente con le scelte fatte finora, cioè contenenti
Gli oggetti impegnati finora e non contenenti gli oggetti respinti finora.
Codice iniziale (⟨pre⟩ → ⟨li⟩): inizialmente non sono state fatte scelte e quindi banalmente tutte le soluzioni ottimali sono coerenti con queste scelte.
j≥i
j <i
Commettere
Li
opti
io
Figura 16.2: una serie di eventi, quelli impegnati nell'attuale momento, quelli respinti, quelli della soluzione ottimale che si presume esista e l'evento successivo da considerare.

---
layout: 
title: Pagina 255
level: 3
---


Algoritmi avidi
239
Mantenimento dell'invariante in loop (⟨li′⟩ & non ⟨exit⟩ & codeloop → ⟨li′′⟩): noi
sono in cima al ciclo dell'algoritmo.Considera l'esempio nella Figura 16.2.
Ipotetica soluzione ottimale: Lascia che Optsli denoti uno degli ipotetici programmi ottimali che si presume esistano dall'invariante in loop.
Azioni dell'algoritmo: se l'evento che confondo con un evento in commit, allora l'algoritmo lo rifiuta.Optsli contiene tutti gli eventi in commit e quindi non può
contenere eventi neanche.Quindi, l'invariante in loop viene mantenuto.Da qui in poi, lascia
Supponiamo che non mi conflitto con qualsiasi evento in commit e quindi lo sarò
aggiunto ad esso.
Modifica di soluzioni ottimali: se siamo fortunati, il programma Optsli contiene già l'evento i.In questo caso, abbiamo finito.Altrimenti, modificheremo il programma
optsli in un altro programma optsours aggiungendo I e rimuovendo qualsiasi evento che
conflitto con esso.Questa modifica non fa parte dell'algoritmo, come in realtà non lo facciamo
avere ancora un programma ottimale.
Una soluzione valida: il nostro set modificato Optsours non contiene conflitti, perché optsli
non contenuto nessuno e siamo stati attenti a non introdurli nessuno.
Coerentemente con le scelte fatte: Optsli era coerente con le scelte precedenti.
Abbiamo aggiunto l'evento I per rendere Optsours coerente con queste scelte.Non abbiamo rimosso alcun evento dal commit, perché questi non si confondono con l'evento I.
Ottimale: per dimostrare che Optsours ha il numero ottimale di eventi in esso, abbiamo bisogno
Solo per dimostrare che ha almeno altrettanti Optsli.Abbiamo aggiunto un evento al
programma.Quindi, dobbiamo dimostrare che non abbiamo rimosso più di uno.Lascia che j
denotare un evento cancellato.Essere in optsli e non in impegno, deve essere un evento
non ancora considerato.Poiché gli eventi sono ordinati in base al loro tempo di rifinitura, implica che l'evento si mette in discussione dopo l'evento che ho finito, cioè FJ ≥fi.Se l'evento j
Conflitti con eventi, ne consegue che inizia anche prima che finisca, cioè s j ≤fi.(In
Figura 16.2, ci sono tre eventi futuri che confondono con i.) Combinando FJ ≥Fi
e s j ≤fi dà che un tale evento j è in esecuzione al momento della conclusione
io.Quindi, tutti di questi eventi si confondono tra loro.Pertanto, non possono
Entrambi sono nel programma optsli, perché contiene conflitti.
Il ciclo invariante è stato mantenuto: in conclusione, abbiamo costruito a
Programma ottimale valido Optsours che contiene gli eventi in commit ∪ {i} e no
eventi respinti.Ciò dimostra che viene mantenuto l'invariante loop.
Uscire loop (⟨li⟩ & ⟨exit⟩ → ⟨post⟩): per li, c'è un programma ottimale optsli
contenente gli eventi in commit e non contenenti gli eventi precedenti non in
Commettere.Poiché tutti gli eventi sono eventi precedenti, ne consegue che commit = optsli è
In un programma ottimale per la nostra istanza.

---
layout: 
title: Pagina 256
level: 3
---


Problemi di ottimizzazione
240
Figura 16.3: un'istanza di esempio del
Problema di copertura a intervalli.Gli intervalli in
Viene evidenziata una soluzione ottimale.
Tempo di esecuzione: il ciclo è iterato una volta per ciascuno degli eventi N.L'unico lavoro è
Determinazione se l'evento che conflivo con un evento all'interno del commit.A causa del
Ordine degli eventi, evento che finisce dopo tutti gli eventi in commit.Quindi, si confonde con un evento in commit se e solo se inizia prima dell'ultimo tempo di risoluzione di
un evento al suo interno.È facile ricordare quest'ultimo tempo di risoluzione, perché è semplicemente il
Il tempo di risoluzione dell'ultimo evento da aggiungere alla commissione.Quindi, il ciclo principale è in funzione
(n) tempo.Il tempo totale dell'algoritmo è quindi dominato dal tempo per ordinare il
eventi.
16.2.2 Esempio: il problema della copertura dell'intervallo
Per questo problema, svilupperemo una priorità adattativa algoritmo avido.
Specifiche: data una serie di punti e intervalli, l'obiettivo è quello di trovare un ottimale
copertura, cioè un sottoinsieme degli intervalli che copre tutti i punti e che contiene il
Numero minimo di intervalli.
Precondizionismo: ci viene data una delle seguenti istanze.
Istanze: un'istanza consiste in un set di punti e un set di intervalli
la vera linea.Un intervallo è costituito da un tempo di avvio e di finitura ⟨si, fi⟩.Vedere
L'esempio nella Figura 16.3.
Postcondition: l'output è una soluzione con il costo minimo e il costo
soluzione.
Soluzioni: una soluzione per un'istanza è un sottoinsieme di intervalli che copre
Tutti i punti.È definitivo se gli intervalli si sovrappongono.
Misura del successo: il costo di una soluzione è | s |, il numero di intervalli
necessario.Avere intervalli più lunghi o più brevi non ha importanza.Coprendo il
I punti più di una volta non importa.Coprendo parti della linea senza
i punti non importa.È importante solo il numero di intervalli.
Il criterio adattivo avido: l'algoritmo ordina i punti e li copre
in ordine da sinistra a destra.Se gli intervalli impegnati finora coprono tutti i punti
In p, quindi l'algoritmo si ferma.Altrimenti, lascia P
Indico il punto più a sinistra in p che è
non coperto da commit.L'intervallo successivo impegnato deve coprire questo prossimo punto scoperto, p
io.Degli intervalli che iniziano a sinistra del punto, l'algoritmo avidamente
prende quello che si estende il più possibile alla destra.La speranza nel farlo è quella
L'intervallo scelto, oltre a coprire P
Io coprirò il maggior numero possibile di altri punti.Lascia che IJ denoti questo intervallo.Se non esiste un tale intervallo IJ o non si estende a

---
layout: 
title: Pagina 257
level: 3
---


Algoritmi avidi
241
il destro abbastanza lontano da coprire il punto, p
Io, quindi nessun intervallo copre questo punto e il
L'algoritmo riporta che nessun sottoinsieme degli intervalli copre tutti i punti.Altrimenti, l'algoritmo si impegna a questo intervallo aggiungendolo per impegnarsi.Questo avido criterio
con cui selezionare l'intervallo successivo cambia come punto p
per essere coperto modifiche.
Il ciclo invariante: l'invariante in loop è che non abbiamo sbagliato: c'è a
almeno una soluzione ottimale coerente con le scelte fatte finora, cioè contenenti
Gli oggetti impegnati finora e non contenenti gli oggetti respinti finora.
Mantenimento dell'invariante in loop (⟨li′⟩ & not ⟨exit⟩ & codeloop → ⟨li′′⟩): assumi
che siamo in cima al ciclo e che il ciclo invariante è vero, in modo che lì
Esiste una copertura ottimale che contiene tutti gli intervalli di commit.Lascia che Optsli denoti
Tale copertura che si presume esista.Se siamo fortunati e Optsli contiene già il
Interval IJ Essere impegnato in questa iterazione, allora lo sappiamo automaticamente
esiste una copertura ottimale che contiene tutti gli intervalli di commit ∪ {ij} e
Quindi il ciclo invariante è stato mantenuto.Se, d'altra parte, l'intervallo IJ
Essere impegnati non è in OPT SLI, quindi dobbiamo modificare questa soluzione ottimale in
Un'altra soluzione ottimale che la contiene.
Modifica di Optsli in Optsours: la soluzione ottimale Optsli deve coprire il punto
P
io.Lascia che ij ′ denoti uno degli intervalli in optsli che copre p
io.La nostra soluzione si oppone
è lo stesso di Optsli, tranne per il fatto che IJ ′ viene rimosso e viene aggiunto IJ.Lo sappiamo
Ij ′ non è in impegno, perché il punto p
Non sono coperto dal commit.Quindi, come
Costruito, Optsours contiene tutti gli intervalli di commit ∪ {ij}.
Optsours è una soluzione ottimale: poiché Optsli è una copertura ottimale, possiamo dimostrare
che si oppongono a una copertura ottimale, dimostrando che copre tutti i punti coperti
da optsli e che contiene lo stesso numero di intervalli.
L'algoritmo considerava il punto p
Io perché era il più a sinistra scoperto
punto.Ne consegue che gli intervalli di commit coprono tutti i punti a sinistra di p
io.
L'intervallo ij ′, perché copre p
Io, devo iniziare a sinistra di P
io.Quindi il
L'algoritmo deve averlo considerato quando ha scelto IJ.Ora ij, essendo l'intervallo
che si estende il più a destra possibile di quelli che iniziano a sinistra di P
devo
estendere almeno fino a destra come ij ′, e quindi IJ copre lo stesso punto
La destra come ij ′ copre.Ne consegue che Optsours copre tutti i punti coperti da
optsli.
Perché Optsours è una soluzione ottimale contenente commit ∪ {ij}, abbiamo
ha dimostrato che esiste una tale soluzione.Quindi, l'invariante in loop è stato mantenuto.
Mantenere il criterio avido: come il punto p
per essere coperto cambiamenti, il
criterio avido secondo il quale viene scelto l'intervallo successivo.Ciecamente
Alla ricerca dell'intervallo che è meglio secondo l'attuale criterio avido
essere troppo richiesto.Le seguenti strutture di dati aiutano a creare l'algoritmo
più efficiente.

---
layout: 
title: Pagina 258
level: 3
---


Problemi di ottimizzazione
242
Una coda di eventi: il progresso dell'algoritmo può essere visto come un marcatore di eventi
muovendosi lungo la linea reale.Un evento nell'algoritmo si verifica quando questo marcatore
Raggiunge l'inizio di un intervallo o un punto da coprire.Questo è implementato non con un indicatore reale, ma con una coda di eventi.La coda è costruita inizialmente ordinando gli intervalli in base all'ora di inizio e
Punti in base alla loro posizione e unendo queste due liste insieme.L'algoritmo rimuove ed elabora questi eventi uno alla volta.
Ulteriori invarianti ad anello: i seguenti invarianti ad anello aggiuntivi mettono in relazione il
Marcatori di eventi di posizione attuale con l'attuale criterio avido.
Li1, punti coperti: tutti i punti a sinistra del marcatore dell'evento sono stati
coperto da intervalli di commit.
LI2, The Priority Code: una coda prioritaria contiene tutti gli intervalli (tranne forse quelli che sono impegnati) che iniziano a sinistra del marcatore dell'evento.La priorità
Secondo la quale sono organizzati è quanto si estende FJ a destra l'intervallo.Questa coda prioritaria può essere implementata utilizzando un heap.(Vedi la Sezione 10.4.)
Li3, ultimo posto coperto: un ultimo variabile indica il luogo più a destra coperto da un intervallo di commit.
Mantenimento degli invarianti ad anello aggiuntivi:
Un evento di intervallo di inizio: quando il marcatore dell'evento passa all'ora di inizio s j di
Un intervallo IJ, questo intervallo da allora in poi inizierà a sinistra dell'evento
Marker e quindi viene aggiunto alla coda prioritaria, la sua priorità è il suo tempo di finitura FJ.
Un evento di intervallo di fine: quando il marcatore dell'evento passa il tempo di finitura FJ
di un intervallo IJ, apprendiamo che questo intervallo non sarà in grado di coprire il futuro
Punti p
io.Sebbene l'algoritmo non voglia più considerare questo intervallo, l'algoritmo sarà pigro e lo lascerà nella coda prioritaria.La sua priorità lo farà
Sii inferiore a quelli che coprono effettivamente P
io.L'algoritmo non considera
Questi eventi, non c'è niente di utile a che fare con loro.
Un evento di punto: quando il marcatore dell'evento raggiunge un punto p
I in p, l'algoritmo
usa l'ultimo ≥p
Per verificare se il punto è già coperto da un intervallo
in commit.Se è coperto, allora non è necessario fare nulla.In caso contrario, allora li1
Ci assicura che questo punto è il punto più scoperto.Li2 lo garantisce
La coda prioritaria è organizzare gli intervalli secondo l'attuale avido
Il criterio, vale a dire, contiene tutti gli intervalli che iniziano a sinistra del punto P
Io, ordinato in base a quanto lontano si estende l'intervallo.Lascia che IJ denoti il
Intervallo di priorità più alta nella coda prioritaria.Supponendo che copra p
Io, il
L'algoritmo si impegna ad esso.Inoltre, se copre P
Io, quindi deve estendersi ulteriormente a
Il diritto rispetto ad altri intervalli di commit, e quindi l'ultimo viene aggiornato a FJ.(IL

---
layout: 
title: Pagina 259
level: 3
---


Algoritmi avidi
243
L'algoritmo può rimuovere l'intervallo IJ impegnato dalla priorità
fila o no.Quell'intervallo non si estenderà abbastanza lontano al diritto di coprire
il prossimo punto scoperto, e quindi la sua priorità sarà bassa nella coda.)
Codice: copertura del punto di intervallo.
Algoritm IntervalPointCover (P, I)
⟨Pre-Cond⟩: P è un insieme di punti e I è un insieme di intervalli su una linea.
⟨Post-Cond⟩: l'output è costituito dalla più piccola serie di intervalli che copre tutti
i punti.
inizio
Ordina p = {p1 ,..., Pn} in ordine crescente di Pi.
Ordina I = {⟨s1, f1⟩ ,..., ⟨Sm, fm⟩} in ordine crescente di s j.
Eventi = unione (p, i)
% ordinato in ordine crescente
considerati = ∅
% La coda prioritaria degli intervalli in considerazione
Commit = ∅
% Set di soluzione: sottoinsieme di copertura di intervalli
ultimo = −∞
% punto più a destra coperto da intervalli di commit
Per ogni evento e ∈Events, in ordine crescente
if (e = ⟨s j, fj⟩) quindi
Inserire l'intervallo ⟨s J, fj⟩into La coda prioritaria considerata con
priorità fj
else (e = p
io)
Se (p
i> ultimo) quindi % p
Non sono coperto da commit
⟨S j, fj⟩ = extractmax (considerato)% fj è massimo in considerati
Se (considerato era vuoto o p
I> fj) allora
restituzione (p
Non posso essere coperto)
altro
Commit = commit ∪ {j}
Last = fj
finisci se
finisci se
finisci se
fine per
restituzione (impegno)
Algoritmo di fine
Tempo di esecuzione: l'ordinamento iniziale richiede tempo O ((n + m) log (n + m)).Il ciclo principale
iterate N + m volte, una volta per evento.Poiché H contiene un sottoinsieme di I, la priorità
Operazioni di coda inserisci ed estrattoMax ciascuno richiede tempo O (logm).Il resto
Le operazioni del ciclo richiedono tempo (1) per iterazione.Quindi, il ciclo richiede un totale
di O ((n + m) logm) tempo.Pertanto, il tempo di esecuzione dell'algoritmo è O ((n + m)
log (n + m)).

---
layout: 
title: Pagina 260
level: 3
---


Problemi di ottimizzazione
244
16.2.3 Esempio: il problema del minimo-scansione
Supponiamo che tu stia costruendo una rete di computer.Devi decidere quale
coppie di computer per eseguire una linea di comunicazione tra.Vuoi che tutti i computer siano collegati tramite la rete.Vuoi farlo in modo da minimizzare
i tuoi costi.Questo è un esempio del problema del minimo-scansione.
Definizioni: considera un sottoinsieme S dei bordi di un grafico non orientato G.
Si dice che un albero: S sia un albero se non contiene cicli ed è collegato.
Set di spanning: si dice che S estende il grafico se ogni coppia di nodi è collegata da
Un percorso attraverso i bordi in S.
Albero che spinge: s si dice che sia un albero che si spinge di g iff è un albero che si estende
grafico.I cicli causeranno percorsi ridondanti tra coppie di nodi.
Albero di spanning minimo: s si dice che sia un albero di spanning minimo di g iff è un
Spanning Tree con peso minimo del bordo totale.
Foresta di spanning: se il grafico G non è collegato, allora non può avere una durata
albero.Si dice che S sia una foresta che attraversa G iff è una raccolta di alberi che si estende
ciascuno dei componenti collegati del grafico.In altre parole, coppie di nodi
che sono collegati da un percorso in G sono ancora collegati da un percorso se consideriamo solo
I bordi in S.
Specifica: l'obiettivo del problema con il minimo-scanning (-forest) è trovare a
albero di spanning minimo (foresta) per un determinato grafico.
Precondizionismo: ci viene data una delle seguenti istanze.
Istanze: un'istanza è costituita da un grafico non indirizzato G. Ogni bordo {u, v} è
Etichettato con un peso (forse negativo) con valorizzazione reale w {u, v}.
Postcondition: l'output è una soluzione con il costo minimo e il costo
soluzione.
Soluzioni: una soluzione per un'istanza è un albero che si spinge (foresta)
Grafico G.
Misura del successo: il costo di una soluzione S è la somma dei suoi pesi per bordi.
Possibili criteri per definire "Best":
Edge più economico (algoritmo di Kruskal): l'ovvio algoritmo avido semplicemente
Si impegna al bordo più economico che non crea già un ciclo con i bordi impegnati.Vedi l'esempio nella Figura 16.4.

---
layout: 
title: Pagina 261
level: 3
---


Algoritmi avidi
245
Verificare un ciclo: un'attività che questo algoritmo deve essere in grado di fare rapidamente
è determinare se il nuovo Edge I crea un ciclo con i bordi in
Commettere.Come compito in sé, questo richiederebbe del tempo.Tuttavia, se manteniamo
Una struttura di dati aggiuntiva, questa attività può essere eseguita molto rapidamente.
Componenti connessi del commit: partizioniamo i nodi nel grafico
In set in modo che tra due nodi nello stesso set, commit fornisca un percorso tra loro e tra due nodi in set diversi, il commit non li collega.Questi set sono indicati come componenti del sottografo indotti dai bordi nel commit.L'algoritmo
può determinare se il nuovo Edge I crea un ciclo con i suoi bordi in
Impegna controllando se gli end point del bordo i = {u, v} sono
contenuto nello stesso componente.Le operazioni richieste sui componenti sono gestite dalla seguente struttura di dati sindacali.
Sistema di set Union -Find: questa struttura dei dati mantiene una serie di set disgiunti di elementi e consente tre operazioni: (1) market (v), che
crea un nuovo set contenente l'elemento specificato V;(2) Trova (V), che
determina il nome del set contenente un elemento specificato;e (3)
Union (u, v), che unisce i set contenenti gli elementi specifici u
e v. In media, per tutti gli scopi pratici, ciascuna di queste operazioni
può essere gareggiato in una quantità costante di tempo.Vedere la Sezione 3.1.
Codice: l'algoritmo di Kruskal con la struttura dei dati sindacale incorporata è il seguente.
Algoritmo Kruskalmst (G)
⟨Pre-Cond⟩: G è un grafico non indirizzato.
⟨Post-Cond⟩: l'output è costituito da un albero di spanning minimo.
inizio
Ordina i bordi in base ai loro pesi w {u, v}.
Commit = ∅% Il set di bordi impegnati
Loop per ogni V
% Senza bordi nel commit, ogni nodo è in un componente
da solo.
Maket (v)
fine per
Loop i = 1...M
% Considera i bordi in ordine ordinato.
u e v sono punti finali del bordo i.
if (find (u) ̸ = find (v))
% I punti finali di Edgeti sono in componenti diversi
e quindi non creare un ciclo con bordi nel commit.
Commit = commit ∪ {i}

---
layout: 
title: Pagina 262
level: 3
---


Problemi di ottimizzazione
246
Union (U, V) % Edge I collega i due componenti:
Quindi vengono uniti in uno
componente.
finisci se
End Loop
restituzione (impegno)
Algoritmo di fine
Tempo di esecuzione: l'ordinamento iniziale richiede il tempo O (mlogm) quando G ha m
bordi.Il ciclo principale itera m volte, una volta per bordo.Controllare un ciclo
richiede tempo α (n) ≤4 in media.Pertanto, il tempo di esecuzione dell'algoritmo
è O (mlogm).
Bordo più economico Connected (Algoritmo di Prim): il seguente algoritmo avido
Si espande un albero di bordi da un nodo di origine come fatto nella ricerca generica
Algoritmo della sezione 14.1.Ad ogni iterazione si impegna al bordo più economico di
quelli che espandono questo albero, cioè il più economico tra quei bordi che
sono collegati al commit dell'albero e tuttavia non creano un ciclo con esso.Vedere il
Esempio nella Figura 16.4.
Vantaggio: se, ad esempio, stai cercando di trovare un albero di spanning minimo
del World Wide Web, allora potresti non conoscere un vantaggio fino a quando non hai
ampliato ad esso.
S
97 99 95
97 89 99 95
97 89 84 85 99 95 81
97 16 89 84 85 99 95 81
97 75 84 85 99 95 81
97 75 67 84 64 85 99 95 81
56 67 84 64 85 99 95 81
61 67 84 64 85 99 95 81
53 61 67 84 64 85 99 95 81
53 61 12 64 85 99 95 81
53 61 27 95 81
53 61 42 81
Algoritmo di Prim: coda prioritaria
Grafico di input:
12 16 27 42 53 56 61 64 67 75 81 84 85 89 95 97 99
L'algoritmo di Kruskal:
84
64
67
95
53
12
61
81
16
97
27
56
85
89
75
99
42
Figura 16.4: Sia gli algoritmi di Kruskal che Prim sono eseguiti sul grafico dato.Per Kruskal
Algoritmo viene mostrato l'ordine ordinato dei bordi.Per l'algoritmo di Prim il contenuto in esecuzione di
Viene mostrata la coda prioritaria (i bordi non sono in ordine particolare).Ogni iterazione, il miglior vantaggio è
considerato.Se non crea un ciclo, viene aggiunto all'albero di spanning minimo.Questo è mostrato
Circlendo il peso del bordo e oscurando il bordo grafico.Per l'algoritmo di Prim, le linee fuori
Dei cerchi indicano come viene aggiornata la coda prioritaria.Se il bordo migliore crea un ciclo, il peso del bordo viene interrotto.

---
layout: 
title: Pagina 263
level: 3
---


Algoritmi avidi
247
Adattivo: questo è un algoritmo Adaptive Greedy, perché quali sono i bordi
Considerato cambiamenti man mano che l'algoritmo procede.Una coda prioritaria viene mantenuta con i bordi consentiti, con priorità data dai loro pesi w {u, v}.
Poiché i bordi consentiti sono quelli che sono collegati al commit dell'albero, quando viene aggiunto un nuovo vantaggio per commit, vengono aggiunti i bordi connessi a I
alla coda.
Codice: Algoritmo MST di Prim.
Algoritmo Primmst (G)
⟨Pre-Cond⟩: G è un grafico non indirizzato.
⟨Post-Cond⟩: l'output è costituito da un albero di spanning minimo.
inizio
Sia S Il nodo iniziale in G.
Commit = ∅
% Il set di bordi impegnati
Coda = bordi adiacenti a s
% Coda prioritaria
Loop fino a coda = ∅
i = bordo più economico in coda
if (Edgeti non crea un ciclo con i bordi in commit)
Commit = commit ∪ {i}
Aggiungi ai bordi della coda adiacenti al bordo che non sono stati
Aggiunto prima
finisci se
End Loop
restituzione (impegno)
Algoritmo di fine
Verificare un ciclo: come nell'algoritmo di ricerca generico della sezione 14.1, poiché un albero viene coltivato, un'estremità del bordo sarò già trovato.
Creerà un ciclo se l'altra estremità è già stata trovata.
Tempo di esecuzione: il loop principale itera m volte, una volta per bordo.La priorità
Operazioni di coda inserisci ed estrattoMax ciascuno richiede tempo O (logm).Pertanto, il tempo di esecuzione dell'algoritmo è O (mlogm).
Un algoritmo più generale: quando si progetta un algoritmo è meglio lasciare come
molti dettagli di implementazione non specificati possibile.Questo dà più libertà
a chiunque possa voler implementare o modificare il tuo algoritmo.Inoltre, fornisce una migliore intuizione sul perché funziona l'algoritmo.Quello che segue è un avido
criterio abbastanza generale.
Bordo più economico connesso di alcuni componenti: partizione i nodi del
grafico G in componenti collegati di nodi che sono raggiungibili da ciascuno
Altro solo attraverso i bordi in commit.I nodi senza bordi adiacenti lo faranno
essere in un componente da solo.Ogni iterazione, l'algoritmo è gratuito

---
layout: 
title: Pagina 264
level: 3
---


Problemi di ottimizzazione
248
Scegli uno di questi componenti per qualsiasi motivo che gli piace.Indica questo componente di C. (C può essere l'unione di un numero di componenti diversi.)
Quindi l'algoritmo si impegna avidamente al bordo più economico di quelli che espandono questo componente, cioè il più economico tra quei bordi che
sono collegati al componente e tuttavia non creano un ciclo con esso.Ogni volta che gli piace, l'algoritmo ha anche la libertà di buttare via non impegnata
bordi che creano un ciclo con i bordi in commit.
Generalizzazione: questo criterio avido è abbastanza generale da includere entrambi
Gli algoritmi di Kruskal e Prim.Pertanto, se dimostriamo che questo avido algoritmo funziona, non importa come viene implementato, allora lo dimostriamo automaticamente
Che sia gli algoritmi di Kruskal che Prim funzionano.
Edge più economico (algoritmo di Kruskal): questo algoritmo generale può scegliere il componente collegato al bordo più eliminato più economico
Ciò non crea un ciclo.Quindi quando sceglie il bordo più economico fuori
Di questo componente, ottiene il vantaggio generale più economico.
Bordo più economico connesso (algoritmo di Prim): questo
generale
algoritmo
Può sempre scegliere il componente che contiene il nodo di origine s.
Ciò equivale all'algoritmo di Prim.
L'anello invariante: l'invariante in loop è che non siamo andati storti.C'è a
almeno una soluzione ottimale coerente con le scelte fatte finora.
Mantenimento dell'invariante in loop (⟨li′⟩ & non ⟨exit⟩ & codeloop → ⟨li′′⟩): vedi il
Esempio nella Figura 16.5.Se siamo sfortunati e l'albero di spanning minimo ottimale
Optsli che si presume esista dall'invariante loop non contiene l'essere Edgeti
Impegnato a questa iterazione, quindi dobbiamo modificare questa soluzione ottimale optsli in
Un altro Optsours che contiene tutti i bordi in commit ∪ {i}.Questo lo dimostra
L'anello invariante è stato mantenuto.
Modifica di Optsli in Optsours: alla soluzione ottimale Optsli aggiungiamo il bordo
i = {u, v} è impegnato in questa iterazione.Poiché Optsli attraversa il grafico G, c'è un percorso P al suo interno dal nodo U al nodo v. Questo percorso insieme al
Edgeti = {u, v} crea un ciclo, che deve essere rotto rimuovendo un bordo da
P. Let C indica la componente del commit che l'algoritmo generale avido
Scegli il bordo I da.Perché espando il componente senza creare un
Cycle con esso, uno e solo uno dei nodi di Edge I e V rientrano nel componente.Quindi, questo percorso P inizia entro C e termina al di fuori di C. quindi, lì
Deve essere un bordo J nel percorso che lascia C. elimineremo questo bordo dal nostro
albero di spanning minimo ottimale: optsours = optsli ∪ {i} - {j}.

---
layout: 
title: Pagina 265
level: 3
---


Algoritmi avidi
249
Bordi da cui scegliere io
Bordi in optli
io
J
C
Bordi in commit
Altri bordi
Legate dei componenti
non mostrato
Figura 16.5: C è uno dei componenti del grafico indotto dai bordi nel commit.Bordo
I è il più economico di C. Edge J è un vantaggio in Optsli che è fuori da C. Infine, si forma Optsours
rimuovendo J e aggiungendo i.
Optsours è una soluzione ottimale:
Optsours non ha cicli: poiché Optsli non ha cicli, creiamo solo un ciclo aggiungendo Edge I e distruggiamo questo ciclo eliminando Edge J.
Optsours si estende g: poiché Optsli si estende, Optsours lo attraversa.Qualsiasi percorso
tra due nodi che attraversano Edge J in Optsli ora seguirà il
Rimanendo bordi del percorso P insieme a Edge I in Optsours.
Optsours ha un peso minimo: perché Optsli ha un peso minimo, lo è
Sufficace per dimostrare che il bordo I è almeno economico di Edge J.Nota che da
bordo di costruzione j foglie componente c e non crea un ciclo con
Esso.Perché Edge sono stato scelto perché era il più economico tali bordi (o a
almeno uno dei più economici) è vero che il bordo I è almeno economico di Edge J.
Esercizio 16.2.1 Mostra come funziona il primo criterio del tempo di finitura sui tre
controesette nella sezione 16.2.1 e nell'esempio nella Figura 16.1.
Esercizio 16.2.2 (vedi soluzione nella parte cinque.) Per l'esempio nella sezione 16.2.2, considera il criterio avido che seleziona l'intervallo che copre il maggior numero di punti scoperti.funziona?In caso contrario, dai un controesempio.
Esercizio 16.2.3 Nella Figura 16.4, supponiamo che decidiamo di cambiare il peso 56 in alcuni
Altro numero reale da −∞To +∞.Qual è l'intervallo di valori che potrebbe essere
cambiato a per il quale il minimo albero di spanning rimane lo stesso?Spiega il tuo
risposta.Allo stesso modo per il peso 85.

---
layout: 
title: Pagina 266
level: 3
---


Problemi di ottimizzazione
250
Esercizio 16.2.4 Dai un grafico semplice con pesi per il bordo per i quali l'albero più corto
I percorsi ponderati dal nodo S non sono un albero di spanning minimo.
16.3
Esercizi
Esercizio 16.3.1 Un aspetto del gioco chiamato Magic (o Jugio) è il seguente.Voi
avere n carte di difesa, le cui, indicate da, vale la pena e l'abilità di difesa
di.Il tuo avversario ha n carte d'attacco, la cui JTH, indicato a J, ha una capacità di attacco
a j.Puoi vedere tutte le carte.Il tuo compito è definire una corrispondenza individuale tra
le carte attaccanti e le carte in difesa, cioè ogni carta di attacco è assegnata a
una carta di difesa unica.Se la carta DI si sta difendendo contro J e DI <a J, allora DII.
Il tuo obiettivo è massimizzare la somma dei valore delle tue carte che vivono.Dai il tuo
algoritmo.Quindi dimostra che funziona.
Esercizio 16.3.2 (Vedi soluzione nella quinta parte.) Rivedere il problema di pianificazione del lavoro/eventi dalla sezione 16.2.1.Questo problema è lo stesso tranne che hai room/processori
all'interno del quale programmare il set di posti di lavoro/eventi in due stanze o su due processori.
Un'istanza è ⟨R, ⟨S1, F1⟩, ⟨S2, F2⟩ ,..., ⟨Sn, fn⟩⟩, dove, come prima, 0 ≤Si ≤fi sono i tempi di partenza e di conclusione per l'evento di Theith.Ma ora l'input specifica anche il numero di
camere, r.Una soluzione per un'istanza è un programma S = ⟨s1 ,..., Sr⟩ per ciascuna delle stanze.
Ognuno di questi è costituito da un sottoinsieme sj ⊆ [1..n] degli eventi che non si confondono da sovrapposizioni nel tempo.Il successo di una soluzione è il numero di eventi programmati, cioè |∪j∈ [r] s |.Considera i seguenti quattro algoritmi:
1.
Trova la soluzione avida per la prima stanza.Quindi trovare la soluzione avida per il
Seconda stanza degli eventi rimanenti.Quindi per la terza stanza e così via.
2.
L'algoritmo inizia ordinando gli eventi in base ai loro tempi di finitura, proprio come in
custodia per una stanza.Quindi, guarda ogni evento a sua volta, pianificandolo se possibile.Se
Può essere programmato in più di una stanza, la assegniamo nella prima stanza in cui
Si adatta, cioè, prima prova la stanza 1, quindi la stanza 2 e così via, fino a quando non riesce.Se non può essere
Pianificato in qualsiasi stanza, quindi non è programmato.
3.
Lo stesso, tranne per il fatto che il prossimo evento è programmato nella stanza con l'ultimo tempo di conclusione di ultimo.Ad esempio, se l'ultimo evento previsto nella stanza 5 finisce al tempo 10 e l'ultimo evento programmato nella stanza 12 finisce al tempo 15 e nel
L'evento successivo inizia al tempo 17, quindi l'evento successivo potrebbe essere programmato in uno di
queste stanze.Questo algoritmo lo pianificherebbe, tuttavia, nella stanza 12.
4.
Lo stesso, tranne per il fatto che il prossimo evento è programmato nella stanza con il primo tempo di conclusione scadente.
Dimostrare che tre di questi algoritmi non portano a un programma ottimale e quello rimanente.

---
layout: 
title: Pagina 267
level: 3
---


251
17 Backtracking ricorsivo
L'algoritmo della forza bruta per un problema di ottimizzazione è semplicemente calcolare il costo
o valore di ciascuno del numero esponenziale di possibili soluzioni e restituire il meglio.
Un problema chiave con questo algoritmo è che ci vuole tempo esponenziale.Un altro problema (non ovviamente banale) è come scrivere codice che elenca su tutte le possibili soluzioni.Spesso il modo più semplice per farlo è il backtracking ricorsivo.L'idea è di progettare
una relazione di ricorrenza che dice come trovare una soluzione ottimale per un'istanza del
Problema da soluzioni ottimali per un certo numero di istanze più piccole dello stesso
problema.Le soluzioni ottimali per queste istanze più piccole si trovano ricordando.
Dopo aver srotolato l'albero di ricorsione, si vede quel backtracking ricorsivo in modo efficace
Enumera tutte le opzioni.Sebbene la tecnica possa sembrare confusa al primo posto, una volta che tu
Ottieni la sospensione della ricorsione, è davvero il modo più semplice per scrivere il codice
questo compito.Inoltre, con un po 'di intuizione si può significativamente migliorare la corsa
Tempo potando interi rami dell'albero di ricorsione.In pratica, se l'istanza
che bisogna risolvere è sufficientemente piccolo e ha abbastanza struttura che molto
La potatura è possibile, quindi è possibile trovare una soluzione ottimale per l'istanza ragionevolmente rapidamente.Per alcuni problemi, l'insieme di sottoinstanze che viene risolta nell'albero di ricorsione è sufficientemente piccolo e prevedibile che l'algoritmo di backtracking ricorsivo possa essere convertito meccanicamente in un rapido algoritmo di programmazione dinamica.
Vedi il capitolo 18. In generale, tuttavia, per la maggior parte dei problemi di ottimizzazione, per grandi peggiori
istanze del caso, il tempo di esecuzione è ancora esponenziale.
17.1
Algoritmi di backtracking ricorsivi
Un algoritmo come sequenza di decisioni: un algoritmo per trovare un ottimale
La soluzione per la tua istanza deve prendere una sequenza di piccole decisioni sulla soluzione: "Includiamo il primo oggetto nella soluzione o no?""Includiamo il secondo?""Il terzo?"...o "Al primo bivio della strada, andiamo a sinistra o a destra?""Al
Seconda forcella Che direzione andiamo? ""Al terzo?"....Come un telaio dello stack in
Algoritmo ricorsivo, il nostro compito è quello di affrontare solo la prima di queste decisioni.Un amico ricorsivo affronterà il resto.Abbiamo visto nel capitolo 16 che gli algoritmi avidi

---
layout: 
title: Pagina 268
level: 3
---


Problemi di ottimizzazione
252
Decisioni semplicemente impegnandosi all'opzione che sembra migliore al momento.Tuttavia, questo di solito non funziona.Spesso, in effetti, non abbiamo una tecnica di ispirazione
Sapere come prendere ogni decisione in un modo che porta a una soluzione ottimale (o persino su una buona).La difficoltà è che è difficile vedere le conseguenze globali
delle scelte locali che facciamo.A volte un sacrificio iniziale locale può guidare a livello globale
a una soluzione generale migliore.Invece, usiamo il sudore.Proviamo tutte le opzioni.
Esempio 17.1.1
Cerca un labirinto
Quando arriviamo a un bivio sulla strada, è necessario provare tutte le direzioni possibili.Per ognuno, facciamo cercare un amico in modo esaustivo, fare il backtrack alla forcella e segnalare i punti salienti.
Il nostro compito è determinare quale di queste risposte è meglio nel complesso.I nostri amici avranno
le loro forche per affrontare.Tuttavia, è meglio non preoccuparsi di questo, poiché il loro cammino
è la loro responsabilità, non la nostra.
Codice di alto livello: quanto segue è la struttura di base che il codice prenderà.
algoritmo alg (i)
⟨Pre-Cond⟩: I è un'istanza del problema.
⟨Post-Cond⟩: Optsol è una delle soluzioni ottimali per l'istanza I e
OptCost è il suo costo.
inizio
Se (io è piccolo) allora
restituzione (risposta alla forza bruta)
altro
% Si occupa della prima decisione provando ciascuna delle possibilità di K.

---
layout: 
title: Pagina 269
level: 3
---


Backtracking ricorsivo
253
per k = 1 a k
% Temporaneamente, impegnarsi a prendere la prima decisione in modo KTH.
⟨OptSolk, optcostk⟩ = affronta ricorsivamente tutte le decisioni rimanenti, e nel farlo trova la soluzione migliore
optsolk per la nostra istanza tra di quelli
coerente con questo modo KTH di realizzare il
prima decisione.OptCostk è il suo costo.
fine per
% Che ha il meglio, optsolk, per ogni possibilità k, manteniamo il meglio da
Questi migliori.
kmin = "a k che minimizza optcostk"
OptSol = Optsolkmin
optcost = optcostkmin
restituire ⟨optSol, optcost⟩
finisci se
Algoritmo di fine
Esempio 17.1.2
Alla ricerca del miglior animale
Supponiamo, invece di cercare attraverso un labirinto strutturato, stiamo cercando un
Grande set di oggetti, diciamo per il miglior animale allo zoo.Vedi Figura 17.1.Ancora una volta ci rompe
La ricerca in ricerche più piccole, ognuna delle quali delegiamo a un amico.Potremmo chiedere
Un amico per il miglior vertebrato e un altro per il miglior invertebrato.Prenderemo
Il meglio di questi come la nostra risposta.Questo algoritmo è ricorsivo.L'amico con il
Il compito vertebrato chiede a un amico di trovare il miglior mammifero, un altro per il miglior uccello e
Un altro per il miglior rettile.
Un albero di soluzioni di classificazione: questo algoritmo si svolge nell'albero di stack
cornici che rispecchiano direttamente l'albero di tassonomia che classifica gli animali.Ogni soluzione
è identificato con una foglia.
Iteratura attraverso le soluzioni per trovare quello ottimale: questo algoritmo immetti
all'utilizzo della prima ricerca (sezione 14.4) per attraversare questo albero di classificazione, iterato
attraverso tutte le soluzioni associate alle foglie.Sebbene questo algoritmo possa sembrare
Complesso, è spesso il modo più semplice per iterare tutte le soluzioni.
Accelerare l'algoritmo: questo algoritmo non è più veloce dell'algoritmo della forza bruta che confronta semplicemente ogni animale con l'uno all'altro.Tuttavia, la struttura
Che il backtracking ricorsivo aggiunge può essere sfruttato per accelerare l'algoritmo.Un ramo dell'albero può essere potato quando sappiamo che ciò non elimina tutte le soluzioni ottimali.Algoritmi avidi (Capitolo 16) poleggono da tutti i rami tranne un percorso lungo l'albero.Nella sezione 18.2, vedremo come la programmazione dinamica
Riutilizza la soluzione ottimale da una sottostruttura all'interno di un'altra sottostruttura.

---
layout: 
title: Pagina 270
level: 3
---


Problemi di ottimizzazione
254
ghepardo
Papà
Gamekeeper
orso
gatto
Gamekeeper
animale
invertebrato
vertebrato
uccello
rettile
serpente
polare
panda
nero
lucertola
mammifero
canino
Homo
H. sapiens
Figura 17.1: albero di classificazione degli animali.
The Little Bird Abstraction: mi piace usare un uccello
astrazione per aiutare a concentrarsi su due dei più difficili e
Parti creative della progettazione di un algoritmo di backtracking ricorsivo.
Quale domanda da porre: la differenza chiave tra
Cercare un labirinto e cercare l'animale migliore è che nel primo le forche sono fissati dal
problema, ma nel secondo il designer dell'algoritmo
è in grado di sceglierli.Invece di biforcare sui vertebrati vs invertebrati, noi
potrebbe forchetta su animali marroni contro animali verdi.Questa scelta è una parte difficile e creativa del processo di progettazione dell'algoritmo.Determina l'intera struttura del
L'algoritmo, che a sua volta impone quanto bene l'algoritmo possa essere accelerato.mi piace
Visualizza questo processo di biforcazione come una domanda a un uccello, “è il miglior animale
un vertebrato o un invertebrato? "o "è il miglior vertebrato, un mammifero, un uccello, un rettile o un pesce?"L'albero di classificazione diventa una strategia per il gioco di
venti domande.Ogni sequenza di possibili risposte (ad esempio, vertebrate–
Mammal - Cat - Cheetah) specifica in modo univoco un animale.Preoccuparsi solo del
Livello più alto di ricorsione, il progettista dell'algoritmo deve formulare una piccola domanda
sulla soluzione ottimale che viene cercata.La domanda dovrebbe essere
In tale che avere una risposta corretta riduce notevolmente la tua ricerca.
Costruire una subinstance per un amico: la seconda parte creativa della progettazione a
L'algoritmo di backtracking ricorsivo è come esprimere il problema “Trova il meglio
mammifero ”come istanza più piccola dello stesso problema di ricerca.L'uccello aiuta
Ancora.Fingiamo che lei abbia risposto "mammifero".Fidarsi (almeno temporaneamente) nella sua risposta ci aiuta a concentrarci sul fatto che ora stiamo solo considerando
Mammalli, e questo ci aiuta a progettare una sottoinstabilità che chiede la migliore.UN
La soluzione a questa sottoinstabilità deve essere tradotta prima che sia nella forma corretta
essere una soluzione alla nostra istanza.

---
layout: 
title: Pagina 271
level: 3
---


Backtracking ricorsivo
255
....
....
....
....
....
....
Dato un istanza
Insieme di soluzioni ad esempio
Albero di domande per imparare una soluzione
Possibili risposte
Tutte le soluzioni
....
....
....
....
....
...
Classificazione delle soluzioni
Scegli il meglio del meglio
Trova la migliore soluzione in ogni classe
Prima domanda
Classificazione delle basi di soluzioni sulla prima domanda
Basato sulla prima domanda
Figura 17.2: classificare le soluzioni e prendere il meglio del meglio.
Uno stormo di stupidi uccelli contro un piccolo uccello saggio: i seguenti due modi di pensare
Informazioni sull'algoritmo sono equivalenti.
Uno stormo di stupidi uccelli: supponiamo che la nostra domanda sul fatto che la soluzione ottimale sia un mammifero, un uccello o un rettile abbia k diverse risposte.Per
Ognuno, facciamo finta che un uccello ci abbia dato questa risposta.Dandole il beneficio di
dubbio, chiediamo a un amico di darci la soluzione ottimale tra quelli che
sono coerenti con questa risposta.Almeno uno di questi uccelli deve essere stato
dicendoci la verità.Lo abbiamo trovato prendendo il meglio dalle soluzioni ottimali ottenute in questo modo.Vedi la Figura 17.2 per un'illustrazione di queste idee.
Un uccellino saggio: se avessimo un uccello che avrebbe risposto alle nostre domande
correttamente, progettare un algoritmo sarebbe molto più semplice: chiediamo al uccellino
"L'animale migliore è un uccello, un mammifero, un rettile o un pesce?"Lei ci dice un
mammifero.Chiediamo al nostro amico il miglior mammifero.Fidarsi dell'uccello
E l'amico, diamo questo come il miglior animale.Proprio come le macchine Turing non determinanti non determinanti (NFA) e non determinanti non determinanti
Poiché poteri più alti che forniscono aiuto, il nostro uccellino può essere visto come un limitato
potenza superiore.È limitata in quanto possiamo solo porre le sue domande che lo fanno
non ho troppe risposte possibili, perché in realtà dobbiamo provare tutto questo
possibili risposte.

---
layout: 
title: Pagina 272
level: 3
---


Problemi di ottimizzazione
256
17.2
I passaggi nello sviluppo di un backtracking ricorsivo
Questa sezione presenta i passaggi che raccomando di utilizzare durante lo sviluppo di un ricorsivo
Algoritmo di backtracking.Per dimostrarli, svilupperemo un algoritmo per il
Problema delle regine.
Esempio 17.2.1
Il problema delle regine
Ottieni fisicamente (o crea su carta) una scacchiera e otto token per agire
regine.Più in generale, potresti prendere in considerazione una scheda N × N e N Queens.Una regina può
Muoviti fino a quanto piaccia, orizzontalmente, verticalmente o in diagonale.L'obiettivo è posizionare tutto
le regine sul tabellone in un modo tale che nessuna regina sia in grado di catturare nessun altro.
Provalo: prima di leggere, prova a posizionare le regine su una scheda 8 per 8.Come
vorresti farlo?
1) Specifica: il primo passo deve essere molto chiaro su quale problema deve essere
risolto.Per un problema di ottimizzazione, dobbiamo essere chiari su quale sia l'insieme di istanze;Per ogni istanza, qual è il suo set di soluzioni;E per ogni soluzione, cosa
il suo costo o valore è.
Queens: l'insieme di possibili soluzioni è l'insieme di modi in cui si posizionano le regine
il bordo.Non apprezziamo una soluzione su un'altra fintanto che è valida, cioè nessuna regina è in grado di catturare qualsiasi altra regina.Quindi, il valore di una soluzione può
Basta essere uno se è una soluzione valida e zero in caso contrario.Ciò che non è chiaro è cosa
Un'istanza di input per questo problema è, oltre la dimensione n.Dovremo farlo
Generalizzare il problema per includere più istanze per poter ricaricare.
Tuttavia, ci torneremo più tardi.
2) Progetta una domanda e le sue risposte per l'uccello: supponiamo il uccellino
conosce una delle soluzioni ottimali per la nostra istanza.Tu, il progettista dell'algoritmo, devi formulare una piccola domanda su questa soluzione e sull'elenco del suo possibile
Risposte.
Domanda sulla soluzione: la domanda dovrebbe essere tale che avere una risposta corretta riduce notevolmente la ricerca.Generalmente, chiediamo la prima parte del
soluzione.
Queens: Potremmo chiedere all'uccello: "Dove dovrei posizionare la prima regina?"
Le possibili risposte degli uccelli: insieme alla tua domanda, fornisci il piccolo
uccello con un elenco a 1, un 2 ,..., Una K di possibili risposte, e lei restituisce semplicemente il
indice k ∈ [1..k] della sua risposta.Per essere coerenti, useremo sempre la lettera k per
indicizzare le risposte degli uccelli.Affinché l'algoritmo finale sia efficace, è importante che il numero K di risposte diverse sia piccolo.

---
layout: 
title: Pagina 273
level: 3
---


Backtracking ricorsivo
257
Queens: Dato che ci sono n regine e n righe e che due regine non possono essere collocate nella stessa fila, la prima osservazione è che la prima regina
Deve essere nella prima riga.Quindi, ci sono k = n risposte diverse l'uccello
potrebbe dare.
3) Costruire le sottoinstanze: supponiamo che l'uccello ci dia il kth delle sue risposte.
Questo ci dà una parte della soluzione;Vogliamo chiedere a un amico ricorsivo per il resto
la soluzione.All'amico deve avere un'istanza più piccola dello stesso problema di ricerca.È necessario formulare SubInstance Sui per l'amico in modo che ci ritorni
informazioni che desideriamo.
Queens: inizio (almeno temporaneamente) fidandomi dell'uccello e metto una regina
dove dice nella prima fila.Per dare un'istanza all'amico, abbiamo bisogno
Per tornare al passaggio 1 e generalizzare il problema.Verrà specifica un'istanza di input
Le posizioni delle regine nelle prime righe.Una soluzione è un modo valido di mettere
le regine nelle righe rimanenti.Data tale istanza, la domanda per il
Bird è "Dove va la regina nella prossima fila?"Fidati dell'uccello, posizioniamo
una regina in cui dice lei.L'istanza, subi, diamo all'amico è il consiglio di amministrazione
Queste regine R + 1 collocate.
Fidati dell'amico: abbiamo dimostrato nella Sezione 8.7 che possiamo fidarci dell'amico per fornire una soluzione ottimale al SubInstance Subi, perché è davvero più piccolo
versione ricorsiva di noi stessi.
4) Costruire una soluzione per la mia istanza: supponiamo che l'amico ti dia un
Soluzione ottimale Opt Subsol per la sua istanza SUBI.Come si produce un ottimale
Soluzione Opt Sol per la tua istanza I dalla risposta dell'uccello K e dalla soluzione dell'amico
opt subsol?
Queens: The Bird ti dice dove nella regina r + la regina dovrebbe andare e
Il tuo amico ti dice dove dovrebbero andare su Rowsr + 2 tonnellate le regine.La tua soluzione combina questi per dire dove dovrebbero andare su Rowsr +1 a N the Queens.
Possiamo fidarci dell'amico per fornire una soluzione ottimale al subi di sottoinstabilità, perché è davvero una versione ricorsiva più piccola di noi stessi.Ricordiamo, nella Sezione 8.7, abbiamo usato una forte induzione per dimostrare che possiamo fidarci del nostro ricorsivo
amici.
5) Costi di soluzioni e subsoluzioni: dobbiamo anche restituire il costo del nostro
Soluzione Optsol.
Queens: le soluzioni in questo caso non hanno costi.
6) Il meglio del meglio: prova tutte le risposte dell'uccello e prendi il meglio del meglio.
Queens: Se ci fidiamo sia dell'uccello che dell'amico, concludiamo che questo processo
ci trova il miglior posizionamento delle regine.Se, tuttavia, il nostro uccellino ci ha dato il
Posizionamento sbagliato della regina nella fila r + 1, allora potrebbe non essere il migliore
posizionamento.Tuttavia, il nostro lavoro non è stato sprecato, perché siamo riusciti a trovare il miglior posizionamento tra quelli coerenti con la risposta di questo uccello.

---
layout: 
title: Pagina 274
level: 3
---


Problemi di ottimizzazione
258
Non fidandosi del piccolo uccello, ripetiamo questo processo, trovando un posizionamento migliore a partire da ciascuna delle possibili risposte degli uccelli.Poiché almeno una delle risposte agli uccelli deve essere corretta, uno di questi posizionamenti deve essere il migliore generale.Restituiamo il meglio di questi come il miglior posizionamento generale.
Per trovare il meglio di questi migliori posizionamenti, lascia che Optsolk e OptCostk denoti il
Soluzione ottimale per la nostra istanza I e il suo costo che abbiamo formato quando abbiamo temporaneamente fidato della risposta dell'uccello KTH.Cerca attraverso questo elenco di costi optcost1, optcost2 ,..., optcostk, trovando il migliore.Denotare l'indice di quello prescelto
Kmax.La soluzione ottimale che torneremo è quindi optSol = opttsolkmax e il suo costo
è optcost = optcostkmax.
7) Casi di base: le istanze del caso di base sono istanze del tuo problema che sono piccoli
abbastanza da non poter essere risolti usando i passaggi 2-6, ma possono essere risolti facilmente in a
Way di forza bruta.Quali sono questi casi di base e quali sono le loro soluzioni?
Queens: se tutte le regine sono state collocate, allora non c'è nulla da fare.
8) Codice: il seguente codice potrebbe essere reso leggermente più semplice, ma per essere coerente useremo sempre questa stessa struttura di base.
Queens algoritmo (C, N, R)
⟨Pre-Cond⟩: C = ⟨⟨1, C1⟩, ⟨2, C2⟩ ,..., ⟨R, cr ⟩⟩place la jth regina nella fila jth
e la colonna CJTH.Le file rimanenti non hanno regina.
⟨Post-Cond⟩: restituito, se possibile, è un Optsol di posizionamento delle Nine in coerente con questo posizionamento iniziale delle Queens Firstr.Un collocamento è legale se non ci sono due
Le regine possono catturarsi a vicenda.Se questo è possibile è in volo con OptCost
uguale a uno o zero.
inizio
% Base di base: se tutte le regine sono già state collocate, allora il
Il problema è facile da risolvere.
if (r = n) allora
if (c è legale) quindi optsol = c & optcost = 1 altro optcost = 0
restituire ⟨optSol, optcost⟩
altro
% Caso generale:
% Prova ogni possibile risposta per uccelli.
Loop K = 1...N
% L'algoritmo di uccelli e amicizia: l'uccello ci dice la colonna K
in cui mettere la R + 1st Queen.Chiediamo all'amico di posizionare il
regine rimanenti.Questa sarà la nostra migliore soluzione optsolk tra
Coloro coerenti con la risposta di questo uccello.
C ′ = C ∪⟨R + 1, K⟩% Posizionare una regina in questa posizione.
⟨OptSolk, optcostk⟩ = Queens

C ′, N, R + 1

fine per

---
layout: 
title: Pagina 275
level: 3
---


Backtracking ricorsivo
259
% Che ha il meglio, optsolk, per la risposta di ogni uccello k, manteniamo il
Il meglio di questi.
kmax = a k che massimizza optcostk, % cioè se possibile k per il quale optcostk = 1
optsol = optsolkmax
optcost = optcostkmax
restituire ⟨optSol, optcost⟩
finisci se
Algoritmo di fine
9) Relazioni di ricorrenza: al centro di ogni backtracking ricorsivo e dinamico
L'algoritmo di programmazione è una relazione di ricorrenza.Questi definiscono un elemento di una sequenza in funzione di elementi precedenti nella stessa sequenza.I seguenti sono
esempi.
La sequenza Fibonacci: se Fib (i) è l'elemento ith nella famosa sequenza di fibonacci, quindi fib (n) = fib (n −1) + fib (n −2).I casi di base Fib (0) = 0 e
Sono necessari anche FIB (1) = 1.
Tempo di esecuzione: se t (n) è il tempo di esecuzione dell'ordinamento di unione su un input di n numeri, allora abbiamo t (n) = 2t (n
2) + n.È inoltre necessario il caso di base T (1) = 1.
Soluzione ottimale: supponiamo che la soluzione [i] sia definita una soluzione ottimale per
L'istanza i di un problema e il costo [i] è il suo costo.Questa non è una sequenza di elementi come gli esempi precedenti, perché non sono in intero.Tuttavia, nel capitolo 18 le istanze saranno indicizzate da Integersi in modo che la soluzione [i] e il costo [i] siano
sequenze.Ma anche quando sono un'istanza di input arbitraria, una relazione di ricorrenza
Può essere sviluppato come segue dall'algoritmo di Bird - Friend.
Soluzione [la mia istanza]
= Mink∈ [K] [una soluzione ottimale alla mia istanza da quelle che
sono coerenti con la risposta di Kth Bird]
= Mink∈ [K] [Combina la risposta dell'uccello e la risposta dell'amico]
= Mink∈ [K] [Combina la risposta e la soluzione di Bird [istanza dell'amico]]
Costo [la mia istanza]
= Mink∈ [K] [costo della soluzione ottimale alla mia istanza da quelli che
sono coerenti con la risposta di Kth Bird]
= Mink∈ [K] [combina il costo dell'uccello e il costo dell'amico]
= Mink∈ [K] [Combina il costo e il costo dell'uccello [istanza dell'amico]]
Sono inoltre necessari casi di base "Soluzione [piccola istanza] = soluzione".

---
layout: 
title: Pagina 276
level: 3
---


Problemi di ottimizzazione
260
Regine: per il nostro esempio di regine questo diventa
Queens (C, N, R) = Mink∈ [N] queen (C ∪⟨R + 1, K⟩, N, R + 1)
Questo è un po 'un esempio sciocco, perché qui tutto il lavoro viene svolto nei casi di base.
Tempo di esecuzione: un algoritmo di backtracking ricorsivo elenca fedelmente tutte le soluzioni per la tua istanza e quindi richiede tempo esponenziale.Lo vedremo
Il tempo può essere ridotto per potatura dei rami dell'albero di ricorsione.
17.3
Rami di potatura
Sono i motivi tipici per cui un intero ramo della classificazione della soluzione
L'albero può essere potato.
Soluzioni non valide: ricorda che in un algoritmo di backtracking ricorsivo, The Little Bird
racconta all'algoritmo qualcosa sulla soluzione e quindi l'algoritmo si ripresenta
fare una domanda a un amico.Quindi questo amico riceve maggiori informazioni sulla soluzione dal suo uccellino e così via.Quindi, seguendo un percorso lungo l'albero ricorsivo
specifica sempre di più su una soluzione fino a quando una foglia dell'albero specifica completamente una
soluzione particolare.A volte succede che a parte l'albero, l'algoritmo
ha già ricevuto informazioni sufficienti sulla soluzione per determinare che contiene un conflitto o un difetto che rende tale soluzione non valida.L'algoritmo può fermarsi
ricorrendo a questo punto e backtrack.Questo elimina efficacemente l'intera sottosca
soluzioni radicate su questo nodo nell'albero.
Queens: Prima di provare a posizionare una regina sul quadrato ⟨r + 1, k⟩, dovremmo controllare
Per assicurarsi che ciò non si confonda con le posizioni di nessuna delle regine
su ⟨⟨1, c1⟩, ⟨2, c2⟩ ,..., ⟨R, cr ⟩⟩.In tal caso, non abbiamo bisogno di chiedere aiuto da questo
amico.L'esercizio 17.5.4 limita il tempo di esecuzione risultante.
Tempo risparmiato: i risparmi di tempo possono essere enormi.Ricordiamo che per esempio 9.2.1 nella sezione 9.2, riducendo il numero di chiamate ricorsive da due a una diminuita
tempo di esecuzione da (n) a (log n) e come nell'esempio 9.2.2 riducendo il
Numero di chiamate ricorsive da quattro a tre hanno diminuito il tempo di esecuzione
(N2) a (N1.58 ...).
Nessuna soluzioni molto apprezzate: allo stesso modo, quando l'algoritmo arriva alla radice di a
subtree, potrebbe rendersi conto che nessuna soluzione all'interno di questa sottostruttura è valutata sufficiente
alto per essere ottimale, forse perché l'algoritmo ha già trovato una soluzione
Provevolmente meglio di tutti questi.Ancora una volta, l'algoritmo può potare l'intera sottostruttura
Dalla sua ricerca.
Algoritmi avidi: gli algoritmi avidi sono algoritmi di backtracking effettivamente ricorsivi con potatura estrema.Ogni volta che l'algoritmo ha una scelta su quale poco

---
layout: 
title: Pagina 277
level: 3
---


Backtracking ricorsivo
261
La risposta di Bird da prendere, cioè quale percorso lungo l'albero ricorsivo da prendere, invece di ripetere tutte le opzioni, va solo per quello che sembra meglio secondo
Ad qualche criterio avido.In questo modo l'algoritmo segue solo un percorso lungo il
albero ricorsivo.Gli algoritmi avidi sono coperti nel capitolo 16.
Modifica delle soluzioni: ricordiamo perché gli algoritmi avidi sono in grado di potare, così
Possiamo usare lo stesso ragionamento con algoritmi di backtracking ricorsivi.In ogni passaggio
In un avido algoritmo, l'algoritmo si impegna a una decisione sulla soluzione.
Questo brucia efficacemente alcuni dei suoi ponti, perché elimina alcune soluzioni da
considerazione.Tuttavia, questo è infinito fintanto che non brucia tutti i suoi ponti.IL
Prover dimostra che esiste una soluzione ottimale coerente con le scelte fatte da
Modificare qualsiasi possibile soluzione che non è coerente con l'ultima scelta in una sola
Ciò ha almeno un buon valore ed è coerente con questa scelta.Allo stesso modo, un ricorsivo
L'algoritmo di backtracking può potare i rami nel suo albero quando sa che questo lo fa
Non eliminare tutte le soluzioni ottimali rimanenti.
Queens: per simmetria, qualsiasi soluzione che ha la regina nella seconda metà del
La prima fila può essere modificata in una che ha questa regina nella prima metà, semplicemente
fluttuando la soluzione da sinistra a destra.Quindi, quando si posiziona una regina nella prima fila, non è necessario provare a posizionarla nella seconda metà della riga.
Ricerca profondità-prima: la prima ricerca ricorsiva (sezione 14.5) è un ricorsivo
Algoritmo di backtracking.Una soluzione al problema di ottimizzazione della ricerca a
Il labirinto per il formaggio è un percorso nel grafico a partire da s.Il valore di una soluzione
è il peso del nodo alla fine del percorso.L'algoritmo segna i nodi
che ha visitato.Quindi, quando l'algoritmo rivisita un nodo, sa che può
Pota questa sottostruttura in questa ricerca ricorsiva, perché sa che è già raggiunto qualsiasi nodo raggiungibile dal nodo corrente.Nella Figura 14.9, il percorso
⟨S, c, u, v⟩is potato perché può essere modificato nel percorso ⟨s, b, u, v⟩, che è
altrettanto bene.
17.4
Abilità di Satis
Un famoso problema di ottimizzazione si chiama SATIS ﬁ capacità o SAT in breve.È uno dei
Problemi di base derivanti in molti campi.L'algoritmo di backtracking ricorsivo dato
Qui è indicato come l'algoritmo Davis -Putnam.È un esempio di algoritmo
il cui tempo di esecuzione è esponenziale per gli input del caso peggiore, ma in molte situazioni pratiche può funzionare bene.Questo algoritmo è uno degli algoritmi di base alla base del teorema automatizzato e della pianificazione del percorso dei robot, tra le altre cose.
Il problema di ﬁ capacità di Satis:
Istanze: un'istanza (input) è costituita da un insieme di vincoli nell'assegnazione
alle variabili binarie x1, x2 ,..., xn.Un vincolo tipico potrebbe essere ⟨x1 o x3 o x8⟩,

---
layout: 
title: Pagina 278
level: 3
---


Problemi di ottimizzazione
262
Significato (x1 = 1 o x3 = 0 o x8 = 1) o equivalentemente che x1 è vero, x3 è
Falso, o X8 è vero.Più in generale un'istanza potrebbe essere un circuito più generale
Costruito con e, o, e non cancelli, ma lasciamo questo fino alla sezione 20.1.
Soluzioni: ciascuno dei 2N compiti è una possibile soluzione.Un incarico è
Valido per l'istanza data se soddisfa tutti i vincoli.
Misura del successo: un incarico viene assegnato il valore uno se soddisfa tutti
i vincoli e il valore zero altrimenti.
Obiettivo: dati i vincoli, l'obiettivo è quello di trovare un incarico soddisfacente.
Iteteratura attraverso le soluzioni: l'algoritmo di forza bruta prova semplicemente ciascuno di
le 2n assegnazioni delle variabili.Prima di leggere, pensa a come faresti
Iteruttutamente iteruzione attraverso tutte queste soluzioni.Anche questo più semplice degli esempi
è sorprendentemente difficile.
Loop nidificati: l'ovvio algoritmo è di avere anelli nidificati ciascuno da cui vanno ciascuno
0 a 1. Tuttavia, ciò richiede di conoscere il valore di n prima di compilare il tempo, che
non è probabile.
Numeri binari incrementali: un'altra opzione è quella di trattare l'assegnazione come un
Numero binario a n-bit e quindi ciclo attraverso i 2N assegnazioni aumentando
Questo numero binario ogni iterazione.
Algoritmo ricorsivo: la tecnica di backtracking ricorsiva è in grado di iterare
Attraverso le soluzioni con molto meno sforzo nella codifica.Innanzitutto l'algoritmo si impegna ad assegnare x1 = 0 e ripete in modo ricorsivo attraverso le assegnazioni 2n - 1
delle restanti variabili.Quindi l'algoritmo si reca indietro, ripetendo questi passaggi
con la scelta x1 = 1. vista in un altro modo, la prima piccola domanda di uccelli sul
soluzioni è se la prima variabile X1 è impostata su zero o una, la seconda domanda
chiede la seconda variabile X2 e così via.I 2n incarichi delle variabili
x1, x2 ,..., XN sono associati alle foglie 2n dell'albero binario completo con
profondità n.Un determinato percorso dalla radice a una foglia commette ogni variabile XI
zero o uno facendo passare il percorso a sinistra o a destra quando
Raggiungendo il livello ITH.
Istanze e sottoinstabilità: data un'istanza, l'algoritmo ricorsivo deve
Costruisci due sottoinstanze con cui i suoi amici si ripresentano.Ci sono due tecniche
per fare questo.
Restringere la classe di soluzioni: associato a ciascun nodo dell'albero di classificazione è una subinstance definita come segue: l'insieme di vincoli rimane invariato, tranne per il fatto che le soluzioni considerate devono essere coerenti nelle variabili
x1, x2 ,..., XR con il compito dato dal percorso al nodo.Attraversando un passo
Più in basso l'albero di classificazione restringe ulteriormente l'insieme di soluzioni.

---
layout: 
title: Pagina 279
level: 3
---


Backtracking ricorsivo
263
Ridurre l'istanza: data un'istanza costituita da una serie di vincoli
Sui variabili n, prima di
Il primo amico sarà i vincoli sulle variabili rimanenti dato che x1 = 0. per
Esempio, se uno dei nostri vincoli originali è ⟨x1 o x3 o x8⟩, dopo aver assegnato x1 = 0, il vincolo ridotto sarà ⟨x3 o x8⟩.Questo perché non è più
possibile che X1 sia vero, dato che uno di X3 o X8 deve essere vero.Dall'altra
mano, dopo aver assegnato x1 = 1, il vincolo originale è soddisfatto indipendentemente da
I valori delle altre variabili, e quindi questo vincolo può essere rimosso.
Potatura: questo algoritmo di backtracking ricorsivo per SAT può essere accelerato.Questo può essere visto a livello globale come una potatura da interi rami dell'albero di classificazione o
essere visto localmente come vedere che alcune sottoinstabilità, dopo che sono state sufficienti
ridotto, sono banali da risolvere.
Rami di potatura dall'albero: considera il nodo dell'albero di classificazione è arrivato al di sotto del sottofondo x1 = 0, x2 = 1, x3 = 1, x4 = 0 ,..., x8 = 0. Tutti i
soluzioni di assegnazione coerenti con questo incarico parziale non soddisfano il
vincolo ⟨x1 o x3 o x8⟩.Quindi, tutta questa sottostruttura può essere potata.
Substanze banali: quando l'algoritmo cerca di assegnare x1 = 0, il vincolo
⟨X1 o x3 o x8⟩ è ridotto a ⟨x3 o x8⟩.Assegnare x2 = 1 non cambia questo
vincolo particolare.Assegnare x3 = 1 riduce ulteriormente questo vincolo a
⟨X8⟩, affermando che X8 deve essere vero.Infine, quando l'algoritmo sta prendendo in considerazione il
Valore per X8, da questo vincolo che X8 è costretto a essere uno.Quindi il
X8 = 1 amico viene chiamato, ma l'amico x8 = 0 non lo è.
Stop quando viene trovato un incarico: la specifica del problema lo chiede solo
incarico soddisfacente.Quindi, l'algoritmo può fermarsi quando si trova.
Davis - Putnam: i rami dell'algoritmo sopra sui valori di ciascuna variabile, x1, x2 ,..., xn, in ordine.Tuttavia, non vi è alcun motivo particolare per cui questo ordine deve
essere fisso.Ogni ramo dell'algoritmo ricorsivo può usare dinamicamente un po 'di euristica
Decidere su quale variabile ramifica successiva.Ad esempio, se esiste una variabile, come
x8 Nell'esempio precedente, il cui incarico è forzato da qualche vincolo, quindi
Chiaramente questo incarico dovrebbe essere eseguito immediatamente.Farlo rimuove questa variabile
Da tutti gli altri vincoli, semplificando l'istanza.Inoltre, se l'algoritmo
ramificato su x4 ,..., x7 Prima della forzatura di X8, allora questa stessa forzatura dovrebbe
essere ripetuto all'interno di tutti i 24 di questi rami.
Se non ci sono variabili da forzare, una strategia comune è quella di ramificarsi sulla variabile
Questo appare nel maggior numero di vincoli.Il pensiero è che la rimozione di
Questa variabile può portare alla più semplificazione dell'istanza.
Un esempio di come diversi rami possono impostare le variabili in un ordine diverso
è il seguente.Supponiamo che ⟨x1 o x2⟩and ⟨x1 o x3⟩are due dei vincoli.

---
layout: 
title: Pagina 280
level: 3
---


Problemi di ottimizzazione
264
L'assegnazione di x1 = 0 semplificherà il primo vincolo per ⟨x2⟩ e rimuovere il secondo vincolo.Il prossimo passo sarebbe forzare x2 = 1. D'altra parte, assegnando x1 = 1
semplificherà il secondo vincolo alla forzatura x3 = 1.
Codice:
Algoritmo Davisputnam (C)
⟨Pre-Cond⟩: C è un insieme di vincoli sull'assegnazione a ⃗
X.
⟨Post-Cond⟩: se possibile, Optsol è un incarico soddisfacente e anche OptCost è uno.
Altrimenti OptCost è zero.
inizio
Se (C non ha vincoli o nessuna variabile)
% C è banale di satis.
restituire ⟨∅, 1⟩
altrimenti se (C ha entrambi un vincolo che forza una variabile XI a 0
e uno forzando la stessa variabile a 1) quindi
% C non è banale.
restituire ⟨∅, 0⟩
altro
Per qualsiasi variabile forzata da un vincolo a un certo valore
sostituire questo valore in c.
Sia Xi la variabile che appare più spesso in C
% Loop rispetto alle possibili risposte degli uccelli.
per k = 0 a 1 (a meno che non sia stata trovata una soluzione soddisfacente)
% Ottieni aiuto da un amico.
Sia C ′ i vincoli C con k sostituiti per xi
⟨Optsubsol, optsubcost⟩ = Davisputnam

c ′
Optsolk = ⟨Valori forzati, xi = k, optsubsol⟩
optcostk = optsubcost
fine per
% Prendi la migliore risposta degli uccelli.
kmax = a k che massimizza optcostk
optsol = optsolkmax
optcost = optcostkmax
restituire ⟨optSol, optcost⟩
finisci se
Algoritmo di fine
Tempo di esecuzione: se non viene eseguita alcuna potatura, allora chiaramente il tempo di esecuzione è (2n), come
Tutti i 2N incarichi sono provati.È necessario verificare una potatura considerevole per rendere il tempo polinomiale dell'algoritmo.Certamente nel peggiore dei tempi, il tempo di esecuzione è 2 (n).In
Pratica, tuttavia, l'algoritmo può essere abbastanza veloce.Ad esempio, supponiamo che l'istanza sia scelta in modo casuale scegliendo i vincoli M, ognuno dei quali è il o di

---
layout: 
title: Pagina 281
level: 3
---


Backtracking ricorsivo
265
Tre variabili o le loro negazioni, ad esempio ⟨x1 o x3 o x8⟩.Se vengono scelti pochi vincoli (dire che M è inferiore a circa 3n), allora con una probabilità molto elevata ce ne sono molti
I compiti soddisfacenti e l'algoritmo individua rapidamente uno di questi incarichi.Se
Vengono scelti molti vincoli (diciamo che M è almeno N2), quindi con una probabilità molto elevata
Esistono molti vincoli di conflitto, che impediscono di essere incaricati soddisfacenti e l'algoritmo trova rapidamente una di queste contraddizioni.Dall'altra
mano, se il numero di vincoli scelti è tra queste soglie, allora lo ha
è stato dimostrato che l'algoritmo Davis -Putnam richiede tempo esponenziale.
17.5
Esercizi
Esercizio 17.5.1 (vedi soluzione nella parte quinta.) In una versione del gioco Scrabble, un
L'istanza di input è costituita da una serie di lettere e una tavola e l'obiettivo è trovare una parola
Questo restituisce il maggior numero di punti.Uno studente ha descritto il seguente backtracking ricorsivo
algoritmo per questo.L'uccello fornisce la parola migliore dall'elenco delle lettere.L'amico
Fornisce il posto migliore sul tabellone per mettere la voce.Perché sono queste cattive domande?
Esercizio 17.5.2 (vedi soluzione nella quinta parte.) Considera il seguente problema di scrabble.
Un'istanza è costituita da una serie di lettere e un dizionario.Una soluzione consiste in una permutazione di un sottoinsieme delle lettere fornite.Una soluzione è valida se è nel dizionario.Il valore
di una soluzione dipende dal suo posizionamento dalla scheda.L'obiettivo è trovare un valore più alto
parola che è nel dizionario.
ESERCIZIO
17.5.3 (vedi soluzione nella parte cinque.) Traccia l'algoritmo Queens (Sezione 17.2.1) sulla scheda standard 8 per 8.A quali sono la prima dozzina di risultati legali
l'algoritmo?Per risparmiare tempo, nota che le prime due o tre regine non si muovono così in fretta.
Quindi, potrebbe valere la pena disegnare una tavola con tutti i quadrati che confondono con questi
cancellato.
Esercizio 17.5.4 (vedi soluzione nella parte quinta.) Qual è il tempo di esecuzione delle regine
Algoritmo (Sezione 17.2.1) per la scheda n-by-n quando non c'è potatura?Dare limiti superiori e più bassi sul tempo di esecuzione di questo algoritmo dopo tutto il
la potatura si verifica.
Esercizio 17.5.5 (vedi soluzione nella parte cinque.) Un'istanza può avere molte soluzioni ottimali con esattamente lo stesso costo.La postconditazione del problema consente una qualsiasi di
Questi per diventare output.In qualsiasi algoritmo di backtracking ricorsivo, quale riga di codice
Scegli quale di queste soluzioni ottimali verranno selezionate?
Esercizio 17.5.6 Supponiamo che tu stia risolvendo SAT dalla sezione 17.4.Supponiamo che la tua istanza sia X e Y e il uccellino ti dice di impostare X su uno.Qual è l'istanza che
dai al tuo amico?Fai lo stesso per i casi ¬x e y, x o y e ¬x o y.

---
layout: 
title: Pagina 282
level: 3
---


Problemi di ottimizzazione
266
Esercizio 17.5.7 Set indipendente: dato un grafico, trova un sottoinsieme più grande dei nodi
per i quali non ci sono bordi tra nessuna coppia nel set.Dai l'uccello
Astrazione di un algoritmo di backtracking ricorsivo per questo problema.cosa chiedi
L'uccello e cosa danno al tuo amico?
Esercizio 17.5.8 grafico 3-color (3-COL): dato un grafico, determina se è
I nodi possono essere colorati con tre colori in modo che due nodi non abbiano lo stesso colore se
Hanno un vantaggio tra loro.Ciò che sorge di difficoltà quando si tenta di progettare a
Algoritmo di backtracking ricorsivo per questo?Riesaminare il problema in modo che l'input consiste
di un grafico e una colorazione parziale dei nodi.Il nuovo obiettivo è determinare se
C'è una colorazione del grafico coerente con la colorazione parziale fornita.Dare l'astrazione dell'amica degli uccelli di un algoritmo di backtracking ricorsivo per questo problema.Che cosa
Chiedi all'uccello e cosa danno al tuo amico?

---
layout: 
title: Pagina 283
level: 3
---


267
18 algoritmi di programmazione dinamica
La programmazione dinamica è un altro potente strumento per risolvere i problemi di ottimizzazione.
Proprio come il backtracking ricorsivo, ha come componente chiave una relazione di ricorrenza che
dice come trovare una soluzione ottimale per un'istanza del problema da ottimale
Soluzioni per un certo numero di istanze più piccole dello stesso problema.Invece di ricorrere a queste sottoinstanze, la programmazione dinamica riempie iterativamente in una tabella con
Una soluzione ottimale per ciascuno, in modo che ciascuno debba essere risolto solo una volta.Dinamico
La programmazione fornisce algoritmi a tempo polinomiale per molti problemi importanti e pratici.
Personalmente, non mi piace il nome "Programmazione dinamica".È vero che gli algoritmi di programmazione dinamica hanno un programma di sotterranee da risolvere.Ma questi
Le sottoinstanze vengono scelte in un ordine presuperato fisso, non dinamicamente.Al contrario, negli algoritmi di backtracking ricorsivi, le sottoinstanze sono costruite dinamicamente.
Un modo per progettare un algoritmo di programmazione dinamica è iniziare indovinando il
Set di sottoinstanze che devono essere risolte.Tuttavia, sento che è più facile iniziare
Progettare la relazione di ricorrenza e il modo più semplice per farlo è progettare prima
Algoritmo di backtracking ricorsivo per il problema.Una volta fatto questo, puoi
Usa una tecnica denominata memoizzazione per convertire meccanicamente questo ricorsivo
Algoritmo di backtracking in un algoritmo di programmazione dinamico.
18.1
Inizia sviluppando un backtracking ricorsivo
Questa sezione esamina i passaggi consigliati per lo sviluppo di un backtracking ricorsivo
algoritmo.
Esempio 18.1.1
Percorso ponderato più breve all'interno di un grafico livellato
Per dimostrare i passaggi, svilupperemo un algoritmo per una versione del problema con il percorso più basso dal capitolo 14. Generalizziamo il problema consentendo pesi negativi sui bordi e semplificarlo richiedendo il livellamento del grafico di input.

---
layout: 
title: Pagina 284
level: 3
---


Problemi di ottimizzazione
268
S
v
1
v
2
v3
v
4
V5
v
6
v
7
V8
T
4
5
3
3
9
2
7
5
5
7
4
1
2
4
2
3
6
7
7
S
7
2
3
3
v
5
v
optare.
8+4 = 12
6+7 = 13
11+2 = 13
10+3 = 13
Peso
Nodo successivo
Optare.sentiero
peso = 6
Optare.sentiero
peso = 8
Optare.sentiero
peso = 11
Optare.sentiero
peso = 10

4
3
v
2
v
2
v
1
v
1
v
T
v
5
?
(UN)
(B)
Figura 18.1: (a) Il grafico ponderato a strati diretti G per esempio 18.1.1.(b) il ricorsivo
Algoritmo di backtracking.
1) Specifica: il primo passo deve essere molto chiaro su quale problema deve essere
risolto.Per un problema di ottimizzazione, dobbiamo essere chiari su quale sia l'insieme di istanze, per ogni istanza quale sia il suo set di soluzioni e per ogni soluzione a cosa fosse il suo
Il costo è.
Precondizionismo: ci viene data una delle seguenti istanze.
Istanze: un'istanza è costituita da ⟨g, s, t⟩, dove g è un peso.
Grafico a strati, S è un nodo di origine specificato e T è una destinazione specificata
nodo.Vedi Figura 18.1.a.Il grafico G ha N nodi.Ogni nodo ha il massimo
In e outdegree d.Ogni bordo ⟨vi, vj⟩is etichettato con un valore reale (possibilmente
negativo) peso w⟨vi, vj⟩.I nodi sono divisi in livelli in modo che ciascuno
Il bordo è diretto da un nodo a un nodo a un livello inferiore per prevenire i cicli.
È più facile supporre che i nodi siano ordinati in modo che un bordo possa passare
nodo VI al nodo VJ solo se i <j.
Postcondition: l'output è una soluzione con il costo minimo e il costo
soluzione.
Soluzioni: una soluzione per un'istanza è un percorso dal nodo di origine S al nodo di destinazione t.
Costo della soluzione: il costo di una soluzione è la somma dei pesi dei bordi
all'interno del percorso.
Algoritmo di forza bruta: il problema con semplicemente provare tutti i percorsi è che lì
può essere un numero esponenziale di essi.
2) Progetta una domanda e le sue risposte per l'uccello: supponiamo il uccellino
conosce una delle soluzioni ottimali per la nostra istanza.Tu, il designer dell'algoritmo,

---
layout: 
title: Pagina 285
level: 3
---


Algoritmi di programmazione dinamica
269
Deve formulare una piccola domanda su questa soluzione e sull'elenco delle sue possibili risposte.La domanda dovrebbe essere tale che avere una risposta corretta riduce notevolmente il
ricerca.
Domanda sulla fine della soluzione: durante la progettazione di un backtracking ricorsivo
Algoritmi, si chiede generalmente la prima parte della soluzione.Lo faremo più tardi
Vedi che se il nostro obiettivo finale è un algoritmo di programmazione dinamica, allora è meglio
Per girarlo e chiedere l'ultima parte della soluzione (vedere la sezione 18.3.1).
Grafico livellato: non sapendo ancora perché chiediamo dell'ultima parte della soluzione, progetteremo questo algoritmo chiedendo invece la prima parte.Dato un grafico
e nodi s e t, chiedo: “Quale bordo dovremmo prendere la prima per formare un ottimale
Path to t? "Mi assicura che prendere il bordo, v1⟩ è buono.La specifica di
Il problema dà che al massimo ci sono bordi da qualsiasi nodo.Quindi, questo è un
rilegato sul numero K di diverse risposte.
Per essere coerenti, useremo sempre la lettera K per indicizzare le risposte agli uccelli.Al fine
Perché l'algoritmo finale sia efficace, è importante che il numero k di diverso
le risposte sono piccole.
3) Costruire le sottoinstanze: supponiamo che l'uccello ci dia il kth delle sue risposte.
Questo ci dà una parte della soluzione e vogliamo chiedere a un amico ricorsivo per il resto
della soluzione.All'amico deve avere un'istanza più piccola dello stesso problema di ricerca.È necessario formulare SubInstance Sui per l'amico in modo che ci ritorni
informazioni che desideriamo.
Grafico livellato: inizio (almeno temporaneamente) a fidarmi dell'uccello e faccio un passo
Lungo il bordo, V1⟩.In piedi a V1, la domanda naturale da porre al mio amico lo è
"Qual è il percorso migliore da V1 Tot?"Espresso come ⟨g, v1, t⟩, questa è una subinstance
dello stesso problema computazionale.
4) Costruire una soluzione per la mia istanza: supponiamo che l'amico ci dia una soluzione ottimale optsubsol per la sua istanza sui.Come produciamo una soluzione ottimale optsol per la tua istanza I dalla risposta dell'uccello K e dalla soluzione dell'amico
Optsubsol?
Grafico livellato: il mio amico mi darà fedelmente il percorso optsubsol = ⟨v1, v6, t⟩, questo è un percorso migliore da v1 a t.La difficoltà è che questa non è una soluzione
Per la mia istanza ⟨g, s, t⟩, perché non è, in sé, un percorso da S a T.IL
Il percorso da S è formato per primo facendo il passo da S a VI e quindi seguendo il miglior percorso da lì a T, vale a dire optsol = ⟨Bird Risposta⟩+ Optsubsol =
⟨S, v1⟩+ ⟨v1, v6, t⟩ = ⟨s, v1, v6, t⟩.
Nella Sezione 8.7 abbiamo dimostrato che possiamo fidarci dell'amico per fornire una soluzione ottimale al SubInstance Subi, perché è davvero una versione ricorsiva più piccola di noi stessi.

---
layout: 
title: Pagina 286
level: 3
---


Problemi di ottimizzazione
270
5) Costi di soluzioni e subsoluzioni: dobbiamo anche restituire il costo del nostro
Soluzione Optsol.Come lo determiniamo dalla K dell'uccello e il costo optsubcost di
Optsubsol dell'amico?
Grafico livellato: il costo dell'intero percorso da S a T è il costo del bordo
⟨S, v1⟩plus Il costo del percorso da V1 a t.Fortunatamente, il nostro amico dà quest'ultimo:
optcostk = w⟨s, v1⟩ + optsubcost = 3 + 10 = 13.
6) Il meglio del meglio: prova tutte le risposte dell'uccello e prendi il meglio del meglio.
Grafico livellato: se ci fidiamo sia dell'uccello che dell'amico, concludiamo che questo
Il percorso da S a T è un percorso migliore.Si scopre che perché il nostro uccello ci ha dato il
Primo bordo sbagliato, questo potrebbe non essere il percorso migliore da s a t.Tuttavia, il nostro lavoro
non è stato sprecato, perché siamo riusciti a trovare il miglior percorso tra
Quelli che iniziano con il bordo, v1⟩.Non fidarsi del piccolo uccello, ripetiamo questo
processo, trovando un percorso migliore a partire da ciascuno di ⟨s, v2⟩, ⟨s, v5⟩ e ⟨s, v3⟩.Almeno
Uno di questi quattro percorsi deve essere un percorso migliore generale.Diamo il meglio di questi
Come percorso migliore generale.
7) Casi di base: le istanze del caso di base sono istanze del tuo problema che sono piccoli
abbastanza da non poter essere risolti usando i passaggi 2-6, ma possono essere risolti facilmente in a
Way di forza bruta.Quali sono questi casi di base e quali sono le loro soluzioni?
Grafico livellato: l'unico caso di base è trovare un percorso migliore da S a T quando S e
sono lo stesso nodo.In questo caso, l'uccello non sarebbe in grado di dare il primo
bordo nel percorso migliore, perché non contiene bordi.La soluzione ottimale è la
Percorso vuoto e il suo costo è zero.
8) Codice: dai passaggi 1–7, il codice può sempre essere messo insieme usando la stessa base
struttura.
Algoritmo livellatedGraph (G, S, T)
⟨Pre-Cond⟩: G è un grafico a strati diretto ponderato e S e T sono nodi.
⟨Post-Cond⟩: Optsol è un percorso con peso totale minimo da s tot e optcost
è il suo peso.
inizio
% Base di base: l'unico caso di base è per il miglior percorso da t a t.La sua soluzione
è il percorso vuoto con il costo zero.
if (s = t) allora
restituire ⟨∅, 0⟩
altro
% Caso generale:
% Prova ogni possibile risposta per uccelli.
Per ciascuno dei bordi D, VK⟩

---
layout: 
title: Pagina 287
level: 3
---


Algoritmi di programmazione dinamica
271
% L'algoritmo di uccelli e amicizia: l'uccello ci dice che il primo
bordo in un percorso ottimale da s a t is ⟨s, vk⟩.Chiediamo all'amico
Per un percorso ottimale da VK a t.Risolve questo dono ricorsivamente
Us Optsubsol.A questo, aggiungiamo il bordo dell'uccello, dandoci Optsolk.
Questo Optsolk è un percorso migliore da S a T tra questi percorsi
Coerentemente con la risposta dell'uccello.
⟨Optsubsol, optsubcost⟩ = liveledgraph (⟨g, vk, t⟩)
optsolk = ⟨s, vk⟩+ optsubsol
optcostk = w⟨s, vk⟩+ optsubcost
fine per
% Che ha il meglio, optsolk, per la risposta di ogni uccello k, manteniamo il
Il meglio di questi.
kmin = "a k che minimizza optcostk"
OptSol = Optsolkmin
optcost = optcostkmin
restituire ⟨optSol, optcost⟩
finisci se
Algoritmo di fine
9) Relazioni di ricorrenza: la relazione di ricorrenza al centro di questo algoritmo di backtracking ricorsivo è il seguente.
LAVELEDGRAPHSOLUZIONE (G, S, T) = MINVK∈N (S) ⟨S, VK⟩
+ Liveledgraphsolution (⟨g, vk, t⟩)
LiveledGraphCost (g, s, t) = min
dove n (s) è l'insieme di nodi vk con bordo ⟨s, vk⟩.
Tempo di esecuzione: l'algoritmo di backtracking ricorsivo elenca fedelmente tutte le soluzioni per la tua istanza e quindi richiede tempo esponenziale.
Esercizio 18.1.1 Dai un grafico livellato diretto su N nodi che ha un piccolo numero di
bordi e il maggior numero possibile di percorsi da s a t.
18.2
I passaggi nello sviluppo di un algoritmo di programmazione dinamica
Sebbene l'algoritmo di backtracking ricorsivo per esempio 18.1.1 possa sembrare complesso, in che altro modo dovresti ripetere attraverso tutti i percorsi?Ora useremo le tecniche di memoizzazione per convertire meccanicamente questo algoritmo in un algoritmo di programmazione dinamico che funziona in tempo polinomiale.La parola "Memorization" deriva da "Memo".
Questa tecnica accelera un algoritmo ricorsivo salvando il risultato per ogni sottoinstallazione che incontra in modo che non debba essere ricompenso.La programmazione dinamica fa l'idea della memoizzazione un ulteriore passo avanti.Invece di attraversare l'albero di

---
layout: 
title: Pagina 288
level: 3
---


Problemi di ottimizzazione
272
cornici di stack ricorsivi, tenendo traccia di quali amici stanno aspettando le risposte
Quali amici, determina prima l'insieme completo di sottoinstanze per le quali sono necessarie soluzioni e quindi le calcola in un ordine in modo tale che nessun amico debba aspettare.
Come va, emette una tabella contenente una soluzione ottimale per ogni sottoinstabilità.IL
La tecnica per trovare una soluzione ottimale per una determinata sottoinstabilità è identica al
Tecnica utilizzata nell'algoritmo di backtracking ricorsivo.L'unica differenza è quella
Invece di ricorrere a risolvere una sotto-sottopostanza, l'algoritmo si alza nel tavolo
Una soluzione ottimale trovata in precedenza.Quando l'intero tavolo è stato completato, l'ultimo
L'ingresso conterrà una soluzione ottimale per l'istanza originale.
1) L'insieme di sottoinstanze: otteniamo l'insieme di sottoinstanze che devono essere risolte
dall'algoritmo di programmazione dinamica tracciando l'algoritmo di backtracking ricorsivo attraverso l'albero di frame dello stack che iniziano con l'istanza data I. Il set è costituito dall'istanza iniziale I, dalle sue sotterranee, dalle loro sottoinstanze e così via.Assicuriamo che questo set contenga tutte le sottoinstanze richieste assicurandosi che sia chiusa
in base a questa operazione secondaria, o equivalentemente che nessuna subinstance è solitaria, perché se lo è
Incluso allora sono tutti i suoi amici.Vedere la sezione 18.3.3.Assicurati anche che tutto (o almeno
La maggior parte) di queste sottoinstanze sono necessarie.
Grafico livellato:
Includi ⟨g, v7, t⟩: su ⟨g, s, t⟩, il uccellino, tra le altre cose, suggerisce
Prendendo il bordo, v1⟩lettendo alla sottoinstance ⟨g, v1, t⟩.Su questa sottoinstabilità, l'uccello, tra le altre cose, suggerisce di prendere il bordo ⟨v1, v4⟩
portando alla sottoinstance ⟨g, v4, t⟩.Su questa sottoinstabilità, l'uccello, tra le altre cose, suggerisce di prendere il bordo ⟨v4, v 7⟩leading, come detto, al
Subinstance ⟨G, V 7, T⟩.Quindi, questa sottoinstabilità deve essere considerata dal
Algoritmo di programmazione dinamica.Vedi Figura 18.2.A, ⟨g, v 7, t⟩.
Escludi ⟨G, V81, T⟩: data la stessa istanza I, ⟨g, V81, T ⟩S non è una sottoinstabilità, perché il nodo V81 non è un nodo nel grafico, quindi non si presenta mai.
Escludi ⟨g, v1, v8⟩: nessuno dei due è ⟨g, v1, v 8⟩a subinstance richiesto, perché
Ogni sottoinstabilità che si presenta è alla ricerca di un percorso che termina nel nodo t.
Indovina il set: a partire dall'istanza ⟨g, s, t⟩, l'insieme completo di sottoinstanze chiamate sarà {⟨g, vi, t⟩ |vi sopra t}.Vedi Figura 18.2.b.
Ridondanza: possiamo accelerare l'algoritmo di backtracking ricorsivo solo quando è
Risolve la stessa sottoinstabilità molte volte.
Grafico livellato: l'algoritmo di backtracking ricorsivo della sezione 18.1 attraversa
ciascuno dei percorsi esponenzialmente di S tot.All'interno di questo importo esponenziale
Di lavoro, c'è molta ridondanza.A amici diversi viene assegnato il

---
layout: 
title: Pagina 289
level: 3
---


Algoritmi di programmazione dinamica
273
amico immagazzinato
da quello che ciascuno
Costruisci percorso
(C)
T
T
8
v
7
v
6
v
7
v
5
v
4
v
3
v
2
v
1
v
Lavoro ripetuto, tempo esponenziale
(UN)
S
1
v
5
v
V8
7
v
v
6
v
4
3
v
v2
S
T
8
v
7
v ...
Risolvi ogni subinstance
4
5
3
3
5
9
2
6
7
5
5
7
4
10
7
4
1
6
2
7
4
2
3
6
8
11
12
0
7
8
v
6
v
7
v
5
v
4
v
3
v
2
v
1
v
0
5
4
7
6
8
11
10
12
6
Tabella optcost
(D)
T
S
(B)
S
Figura 18.2: (a) l'algoritmo ricorsivo.(b) l'algoritmo di programmazione dinamica: il piccolo
freccia fuori dal nodo VI indica il primo bordo in un percorso ottimale da VI a T e il valore
All'interno del cerchio sul nodo dà il costo di questo percorso.(c) Il percorso ottimale da s a t.(d) il
Contenuto della tabella OptCost.È riempito all'indietro.
Eastico stesso compito.In effetti, per ogni percorso da S a VI, ad alcuni amici viene chiesto di risolvere
la subinstance ⟨g, vi, t⟩.Vedi Figura 18.2.A.
Un amico per subinstance: per risparmiare tempo, l'algoritmo di programmazione dinamica
risolve ciascuna di queste sottoinstanze una sola volta.Assegniamo un amico a ciascuno di questi
Sottosegui, il cui compito è trovare una soluzione ottimale per esso e fornire questo
soluzione a qualsiasi altro amico che ne ha bisogno.
2) Contare le sottoinstanze: il tempo di esecuzione dell'algoritmo di programmazione dinamica è proporzionale al numero di sottoinstanze.A questo punto nel design di
L'algoritmo, dovresti contare quante sottoinstanze un'istanza che ho in funzione della dimensione n = | i |dell'istanza.Se ce ne sono troppi, allora inizia al
molto cominciando, progettare un nuovo algoritmo di backtracking ricorsivo con un diverso
Domanda per l'uccello.
Grafico livellato: il numero di sottoinstanze nel set {⟨g, vi, t⟩ |vi sopra t} è n, il numero di nodi nel grafico G.
3) Costruire una tabella indicizzata per sottoinstabilità: l'algoritmo progettista costruisce
un tavolo.Deve avere una voce per ogni subinstance.Generalmente, il tavolo avrà
Una dimensione per ciascun parametro utilizzato per specificare una subinstance particolare.Essere
Coerente, useremo sempre le lette e, se necessario, J per indicizzare le sottoinstanze.
Ogni voce nella tabella viene utilizzata per archiviare una soluzione ottimale per la sottoinstabilità
con il suo costo.Spesso abbiamo diviso questa tabella in due tabelle: una per la soluzione e una per
il costo.

---
layout: 
title: Pagina 290
level: 3
---


Problemi di ottimizzazione
274
Grafico livellato: il singolo parametro utilizzato per specificare una particolare sottoinstabilità è
io.Quindi, le tabelle adatte sarebbero optsol [0..n] e optcost [0..n], dove optsol [i]
memorizzerà il miglior percorso dal nodo VI al nodo T e optcost [i] memorizzeranno il suo costo.
Vedi Figura 18.2.D.
4) Soluzione dalle subsoluzioni: l'algoritmo di programmazione dinamica per la ricerca di un
La soluzione ottimale a una determinata istanza da una soluzione ottimale a una sottoinstabilità è
identico a quello all'interno dell'algoritmo di backtracking ricorsivo, tranne quello invece
di ricorrere per risolvere una sottoinstabilità, l'algoritmo trova la sua soluzione ottimale nel
tavolo.
Grafico livellato: il compito di Amico nell'algoritmo di programmazione dinamica non lo è
Per risolvere ⟨g, s, t ⟩but ⟨g, vi, t⟩, alla ricerca di un percorso migliore da vi a t.Lo fa come
segue.Chiede all'uccello per il primo bordo sul suo cammino e prova ciascuno di lei
possibili risposte.Quando l'uccello suggerisce il bordo ⟨vi, vk⟩, chiede a un amico un amico
Miglior percorso da VK tot.Questo compito è la subinstance ⟨G, VK, T⟩, che è stata assegnata a Friendk e la cui soluzione è stata memorizzata in Optsol [K].Il ricorsivo
Codice di backtracking
⟨Optsubsol, optsubcost⟩ = liveledgraph (⟨g, vk, t⟩)
optsolk = ⟨s, vk⟩+ optsubsol
optcostk = w⟨s, vk⟩+ optsubcost
è cambiato in semplicemente
optsolk = ⟨vi, vk⟩+ optsol [k]
optcostk = w⟨vi, vk⟩+ optcost [k]
Amici affronta il bordo dell'uccello ⟨vi, vk⟩onto questo percorso davk tot, dando un percorso che è
Il percorso migliore da VI tot tra quelli coerenti con la risposta dell'uccello ⟨vi, vk⟩.
Dopo aver provato la risposta di ogni uccello, Friedi salva il meglio di questi migliori percorsi nel
tavolo.
5) Casi di base: le istanze del caso di base sono esattamente le stesse del ricorsivo
Algoritmo di backtracking.L'algoritmo di programmazione dinamica inizia il suo calcolo
Mettendo nella tabella una soluzione ottimale per ciascuno di questi e i loro costi.
Grafico livellato: l'unico caso di base è trovare un percorso migliore da S a T quando S e
sono lo stesso nodo.Ciò si verifica solo con la subinstance ⟨g, vn, t⟩, dove
VN è un altro nome per t.Il codice di backtracking ricorsivo
if (s = t) allora
restituire ⟨∅, 0⟩

---
layout: 
title: Pagina 291
level: 3
---


Algoritmi di programmazione dinamica
275
è cambiato in
% Caso base:
optsol [n] = ∅
optcost [n] = 0
6) L'ordine in cui riempire la tabella: quando un amico nell'algoritmo di backtracking ricorsivo ha bisogno di aiuto da un amico, l'algoritmo si ripresenta e il telaio dello stack
Poiché il primo amico attende fino al ritorno del telaio dello stack per il secondo amico.Questo forma
Un albero di cornici di stack ricorsivi, tenendo traccia di quali amici stanno aspettando le risposte
da quali amici.Al contrario, in un algoritmo di programmazione dinamica, gli amici
Risolvi le loro sottoinstanze in un ordine in modo tale che nessuno debba aspettare.Ogni ricorsivo
L'algoritmo deve garantire che si ripresenta solo su casi più piccoli.Quindi, se il
Algoritmo di programmazione dinamica ﬁ lls nella tabella da casi più piccoli a più grandi, quindi quando viene risolta un'istanza, la soluzione per ciascuna delle sue sotterranee è già disponibile.In alternativa, il designer dell'algoritmo può semplicemente scegliere qualsiasi ordine per
riempire la tabella che rispetta le dipendenze tra le istanze e le loro sottoinstanze.La tabella deve essere indicizzata per sotterranee.Quando si alloca il tavolo, sii
Cancella quale sottoinstanza rappresenta ogni voce della tabella.
Grafico livellato: amici, con istanza ⟨g, vi, t⟩, dipende da friendk quando lì
è un bordo ⟨vi, vk⟩.Dalla condizione preliminare del problema, sappiamo che ogni bordo
Deve passare da un livello superiore a uno più basso, e quindi sappiamo che K> i.Riempimento della tabella nell'ordine T = Vn, Vn - 1, Vn - 2 ,..., v2, v1, v0 = s assicura che quando
Friedi fa il suo lavoro, Friendk ha già immagazzinato la sua risposta nel tavolo.IL
Subinstance ⟨g, vn, t ⟩has è già stato risolto.Il seguente ciclo è messo in giro
Il codice del caso generale dell'algoritmo di backtracking ricorsivo:
% CASI GENERALI: ciclo sopra le sottoinstanze nella tabella.
per i = n −1 a 0
% Risolvi l'istanza ⟨g, vi, t⟩ e ﬁ ll nella voce della tabella ⟨i⟩.
Visualizzazione dell'algoritmo di programmazione dinamica come un algoritmo iterativo, il ciclo invariante quando si lavora su una particolare sottoinstabilità è che tutte le sottoinstanze più piccole
Sarà necessario essere stati risolti.Ogni iterazione mantiene il ciclo invariante
mentre fa progressi risolvendo questa successiva sottoinstabilità.
7) La soluzione finale: l'istanza originale sarà l'ultima sottoinstabilità da risolvere.
Quando completare il programma dinamico restituisce semplicemente questa risposta.
Grafico livellato: l'istanza originale ⟨g, s, t⟩ è uguale alla subinstance
⟨G, v0, t⟩, dove V0 è un altro nome per s.Il programma dinamico termina con il
codice
return ⟨optSol [0], optcost [0]⟩

---
layout: 
title: Pagina 292
level: 3
---


Problemi di ottimizzazione
276
8) Codice: dai passaggi 1–7, il codice può sempre essere messo insieme usando la stessa base
struttura:
Algoritmo livellatedGraph (G, S, T)
⟨Pre-Cond⟩: G è un grafico a strati diretto ponderato e S e T sono nodi.
⟨Post-Cond⟩: Optsol è un percorso con peso totale minimo da s tot e optcost
è il suo peso.
inizio
% Tabella: Optsol [i] memorizza un percorso ottimale da VI a T e
optcost [i] il suo costo.
Tabella [0..n] Optsol, optcost
% Base di base: l'unico caso di base è per il miglior percorso da t a t.
La sua soluzione è il percorso vuoto con costo zero.
optsol [n] = ∅
optcost [n] = 0
% CASI GENERALI: ciclo sopra le sottoinstanze nella tabella.
per i = n −1 a 0
% Risolvi l'istanza ⟨g, vi, t⟩ e ﬁ ll nella voce della tabella ⟨i⟩.
% Prova ogni possibile risposta per uccelli.
Per ciascuno dei bordi d ⟨vi, vk⟩
% L'algoritmo di uccelli e amicizia: l'uccello ci dice che il primo
bordo in un percorso ottimale da vi a t è ⟨vi, vk⟩.Chiediamo all'amico
Per un percorso ottimale da VK a t.Ci dà optsol [k], che lui
aveva immagazzinato nel tavolo.A questo aggiungiamo il bordo dell'uccello.Questo da
Us Optsolk che è un percorso migliore da VI a T tra quelli
Percorsi coerenti con la risposta dell'uccello.
optsolk = ⟨vi, vk⟩+ optsol [k]
optcostk = w⟨vi, vk⟩+ optcost [k]
fine per
% Avere il meglio, Optsolk, per la risposta di ogni uccello K, manteniamo il meglio
Di questi migliori.
kmin = a k che minimizza optcostk
optsol [i] = optsolkmin
optcost [i] = optcostkmin
fine per
return ⟨optSol [0], optcost [0]⟩
Algoritmo di fine
Struttura coerente: per essere coerenti, useremo sempre questa stessa struttura per
Tutto il codice di programmazione dinamico.Anche quando ci sono piccoli modi in cui il codice potrebbe
Sii ottimizzato, ci atteniamo a questa stessa struttura.Anche quando diversi nomi variabili

---
layout: 
title: Pagina 293
level: 3
---


Algoritmi di programmazione dinamica
277
Sarebbe più significativo, ci atteniamo a TOI e, se necessario, J per indicizzare le sottoinstanze e K per indicizzare le risposte degli uccelli.Credo che questa coerenza renderà più facile per
Tu (e per il marcatore) di capire i numerosi algoritmi di programmazione dinamica.
9) Tempo di esecuzione: possiamo vedere che il codice si avvicinò a ogni sottoinstabilità e, per
Ciascuno, i passanti su ogni uccello risposta.Da questo, il tempo di esecuzione sembra essere il numero di sottoinstanze nel periodo della tabella il numero k di risposte alla domanda dell'uccello.
Vedremo nella sezione 18.3.4 che in realtà il tempo di esecuzione di questa versione dell'algoritmo è un fattore di N più grande di questo.La stessa sezione dirà come rimuoverlo
fattore extra di n.
Grafico livellato: il tempo di esecuzione di questo algoritmo è ora polinomiale.Ci sono
Solo n amici, uno per ogni nodo nel grafico.Per l'istanza ⟨g, vi, t⟩, c'è
Una risposta di uccello per ogni bordo fuori dal suo nodo di origine VI.Ci sono al massimo D di questi.
Il tempo di esecuzione è quindi solo O (n · d) volte questo fattore extra di n.
18.3
Punti sottili
Prima di elencare alcuni dei punti più sottili nello sviluppo di un backtracking ricorsivo
E un algoritmi di programmazione dinamici, do un altro problema di esempio.
Esempio 18.3.1
Stampa ordinatamente
Considera il problema della stampa di un paragrafo ordinatamente su una stampante.Il testo di input è un
Sequenza di n parole con lunghezze L1, L2 ,..., LN, misurato in personaggi.Ogni stampante
La linea può contenere un massimo di caratteri M.Il nostro criterio per la pulizia è che ci sia
Il minor numero possibile di spazi alle estremità delle linee.
Precondizioni: un'istanza ⟨m; l1 ,..., ln⟩consist della lunghezza della linea e la parola
lunghezze.Generalmente, M sarà pensato come una costante, quindi lo lasceremo fuori quando
è chiaro dal contesto.
PostConditions: l'obiettivo è quello di dividere il testo in linee in modo da ridurre al minimo il costo.
Soluzioni: una soluzione per istanze è un elenco che fornisce il numero di parole per ciascuno
linea, ⟨k1 ,..., Kr⟩.
Costo della soluzione: dato il numero di parole in ogni riga, il costo di questa soluzione
è la somma dei cubi del numero di spazi vuoti alla fine di ogni riga (incluso
Per ora l'ultima riga).
Esempio: supponiamo che un modo per rompere il testo in righe dia 10 spazi vuoti
la fine di una delle linee, mentre un altro modo dà 5 spazi vuoti alla fine di una linea
e 5 alla fine di un altro.Il nostro senso dell'estetica impone che il secondo modo
è "più ordinato".Il nostro costo penalizza pesantemente con un gran numero di spazi vuoti su un singolo
riga cucidendo il numero.Il costo della prima soluzione è 103 = 1.000 mentre il
Il costo del secondo è solo 53 + 53 = 250.

---
layout: 
title: Pagina 294
level: 3
---


Problemi di ottimizzazione
278
Esempio 18.3.1
Stampa ordinatamente (cont.)
Esempio: considera la stampa ordinatamente il testo sciocco "questa settimana ha sette date ok"
in colonna con larghezza M = 11. Questo è rappresentato come stampa ordinatamente istanza
⟨M; l1 ,..., ln⟩ = ⟨11;4, 4, 3, 5, 5, 2, 2, 2⟩.Tre dei possibili modi per stampare questo testo sono
come segue:
⟨K1, k2 ,..., Kr⟩ = ⟨2,2,2,2⟩⟨k1, K2 ,..., Kr⟩ = ⟨1,2,2,3⟩⟨k1, K2 ,..., Kr⟩ = ⟨2,2,1,3⟩
Questa settimana..
23
Questo.......
73
Questa settimana..
23
ha. -seven ..
23
Settimana.HAS ...
33
ha. -seven ..
23
dates.in ...
33
Seven.Dates
03
date......
63
ok......
63
in.it.ok ...
33
in.it.ok ...
33
Costo
= 259
Costo
= 397
Costo
= 259
Di questi tre, il primo e gli ultimi sono i più economici e probabilmente il più economico di tutti
le possibili soluzioni.
18.3.1 La domanda per il piccolo uccello
Il designer di un algoritmo di backtracking ricorsivo, un algoritmo di programmazione dinamico o un algoritmo avido deve decidere quale domanda porre al uccellino.Cioè, il progettista dell'algoritmo deve decidere quale sequenza di decisioni specificherà la soluzione costruita dall'algoritmo: quali cose proveranno l'algoritmo prima di fare il backtrack per provare qualcos'altro?Questo è uno dei principali passaggi creativi nella progettazione del
algoritmo.
Considerazioni locali vs. globali: uno dei motivi per cui i problemi di ottimizzazione
sono difficili è che siamo in grado di prendere ciò che chiamiamo osservazioni e decisioni locali
Ma è difficile vedere le conseguenze globali di queste decisioni.
Grafico livellato: quale vantaggio di S è più economico è una domanda locale.Quale percorso è
La più economica generale è una domanda globale.Siamo stati tentati di seguire il più economico
bordo fuori dalla fonte s.Tuttavia, a volte si può arrivare a un complesso migliore
Percorso iniziando con un primo bordo che non è il più economico.
Stampa ordinatamente: se seguiamo un algoritmo avido, mettiamo tutte le parole su
la prima linea possibile.Tuttavia, un sacrificio locale di mettere meno parole su questo
La linea può portare a livello globale a una soluzione complessiva migliore.
Chiedi di una proprietà locale: la domanda che poniamo all'uccello riguarda alcuni locali
Proprietà della soluzione:
Primo oggetto: se la soluzione è una sequenza di oggetti, una buona domanda sarebbe
"Qual è il primo oggetto nella sequenza?"

---
layout: 
title: Pagina 295
level: 3
---


Algoritmi di programmazione dinamica
279
Grafico livellato: se la soluzione è un percorso attraverso un grafico, potremmo chiedere: "Cosa
Il primo bordo è nel percorso? "
Stampa ordinatamente: se la soluzione è una sequenza di quante parole da mettere
Ogni riga, chiediamo: "Quante parole k mettiamo sulla prima linea?"
Sì o No: se l'istanza è una sequenza di oggetti e una soluzione è un sottoinsieme di
Questi oggetti, una buona domanda sarebbe "è il primo oggetto dell'istanza inclusa nella soluzione ottimale?"
Pianificazione degli eventi: se la soluzione indica quali eventi da programmare, lo faremo
Chiedi: "Pianifichiamo il primo evento?"
Quale radice: se una soluzione è un albero binario di oggetti, una buona domanda sarebbe
"Quale oggetto è alla radice dell'albero?"
Il miglior albero di ricerca binaria: nota che la prima domanda non è se
Prendi il ramo sinistro o destro dell'albero di ricerca binaria indicata, ma qual è la radice
dovrebbe essere quando si costruisce l'albero di ricerca binaria.
Al contrario, chiedendo all'uccello il numero di bordi nel miglior percorso nel livellato
Il grafico è una domanda globale, non locale.
Il numero k di diverse risposte degli uccelli: puoi chiedere solo un po 'all'uccello
domanda.(È solo un uccello.) In una piccola domanda, il numero k di risposte diverse a 1, un 2 ,..., Una K che l'uccello potrebbe dare deve essere piccolo.Il k più piccolo è, il
Più efficiente l'algoritmo finale sarà.
Grafico livellato: quando si chiede un vantaggio da S, il numero k di risposte è il
grado del nodo.Questo dà un limite su k.
Stampa ordinatamente: k è il numero massimo delle prime parole del testo che
si tratterebbe sulla prima linea.
Pianificazione degli eventi: "Pianifichiamo il primo evento?"ha k = 2 risposte, sì
e no.
Brute Force: la domanda ovvia da chiedere all'uccello è che ti dica un
intera soluzione ottimale.Tuttavia, il numero di soluzioni per la tua istanza è
probabilmente esponenziale;Ogni soluzione è una possibile risposta.Quindi, k sarebbe esponenziale.Dopo essersi sbarazzato dell'uccello, l'algoritmo risultante sarebbe il solito
Algoritmo di forza bruta.
Domande ripetute: anche se vuoi evitare di pensarci, ognuno dei tuoi
Gli amici ricorsivi dovranno fare una domanda simile al suo uccello.Quindi, dovresti

---
layout: 
title: Pagina 296
level: 3
---


Problemi di ottimizzazione
280
v1
2
v v3
4
v
6
v v7
8
v
V5
v
1
v
1
v2
v2
Peso del nodo successivo
6+7 = 13
6+7 = 13
7+5 = 12
optare.
v
5
v
3
v
3
v
3
8+9 = 17
6
8
v
5
v
5
v
4
v
4
v
7
v
v
6
8
v
7
v
v
peso = 7
peso = 9
Optare.sentiero
peso = 8
peso = 6
Optare.sentiero
Optare.sentiero
Optare.sentiero
7
5
4
9
?
T
S
v
1
v
1
v2
v2
S
S
T
...
Costruisci percorso
da quello che ciascuno
amico immagazzinato
9
0
3
2
4
T
6
7
7
6
8
7
6
3
2
4
2
1
4
7
5
5
7
2
9
3
3
5
12
4
Risolvi ogni subinstance
Tavolo Optsol
3
S
T
0
2
4 8 6 6 9 7 12
(UN)
(B)
(C)
(D)
Figura 18.3: (a) l'algoritmo ricorsivo.(b) l'algoritmo di programmazione dinamica: il piccolo
freccia fuori dal nodo VI indica l'ultimo bordo in un percorso ottimale da s a vi e il valore all'interno
Il cerchio in un nodo dà il costo di questo percorso.(c) Il percorso ottimale da s a t.(d) il contenuto
della tabella OptCost.Contrariamente a quello nella Figura 18.2, è riempito in avanti.
Scegli una domanda che fornisca una ragionevole domanda di follow-up di una forma simile.
Per esempio:
R "Qual è il secondo oggetto nella sequenza?"
R "Il secondo oggetto dell'istanza è incluso nella soluzione ottimale?"
R "Qual è la radice nella sottostruttura sinistra (a destra)?"
Al contrario, chiedendo all'uccello il numero di bordi nel miglior percorso nel livellato
Il grafico non ha una buona domanda di follow-up.
Invertire l'ordine: questo cambiamento è puramente per motivi estetici.La dinamica
Programmi Incolla indietro attraverso i nodi del grafico, T = Vn, Vn - 1, Vn - 2 ,..., v2, v1, v0 = s.Il modo standard per farlo è lavorare in avanti.L'algoritmo di backtracking ricorsivo ha funzionato in avanti da s.La tecnica di programmazione dinamica inverte il
Algoritmo di backtracking ricorsivo completando le sottoinstanze dal più piccolo a
maggiore.Per far andare avanti l'algoritmo finale, l'algoritmo di backtracking ricorsivo deve tornare indietro.Per fare questo, l'uccello dovrebbe chiedere qualcosa
sulla fine della soluzione e non sull'inizio.Confronta la Figura 18.2 e
Figura 18.3, e vedere il codice finale nella sezione 18.3.6.
Ultimo oggetto: "Qual è l'ultimo oggetto nella sequenza?"Qual è l'ultimo vantaggio in
Il percorso ottimale e quante parole abbiamo messo sull'ultima riga?
Sì o No: "L'ultimo oggetto dell'istanza è incluso nella soluzione ottimale?"
Pianifichiamo l'ultimo evento?
Quale radice: chiediamo ancora della radice.Non è utile chiedere informazioni sulle foglie.

---
layout: 
title: Pagina 297
level: 3
---


Algoritmi di programmazione dinamica
281
Esercizio 18.3.1 ricominciare e riqualificare la programmazione dinamica del grafico livellato
Algoritmo con questa nuova domanda per il piccolo uccello, in modo che il lavoro sia completato a partire dalla parte superiore del grafico.
18.3.2 Substanze e subsoluzioni
Ottenere una risposta affidabile dal piccolo uccello restringe il nostro problema di ricerca
al compito di trovare la migliore soluzione tra quelle soluzioni coerenti con
questa risposta.Sarebbe bello se potessimo semplicemente chiedere a un amico di trovarci una soluzione del genere;Tuttavia, ci è permesso solo di chiedere al nostro amico di risolvere le sottoinstanze del
Problema computazionale originale.Il nostro compito all'interno di questa sottosezione è formulare a
Sottoperto il nostro problema computazionale in modo tale che la ricerca delle sue soluzioni ottimali in qualche modo è parallela alla nostra attività di ricerca ristretta.
La struttura ricorsiva del problema: per essere in grado di progettare un algoritmo di backtracking ricorsivo per un problema di ottimizzazione, il problema deve
avere una struttura ricorsiva.Affinché una soluzione dell'istanza sia ottimale, una parte
della soluzione deve essere ottimale.Il problema computazionale ha un ricorsivo
struttura se il compito di trovare un modo ottimale per costruire questa parte della soluzione è
una sottoinstabilità dello stesso problema computazionale.
Grafico livellato: per un percorso da s a t essere ottimale, il sottofondo da alcuni vi
Per alcuni VJ lungo il percorso deve essere un percorso ottimale tra questi nodi.
Il problema computazionale ha una struttura ricorsiva perché il compito di trovare
Un modo ottimale per costruire questa parte del percorso è una sottoinstabilità dello stesso
problema computazionale.
Stampa ordinatamente: affinché tutte le parole vengano stampate ordinatamente, le parole che sono
Nelle ultime dieci righe devono essere stampati ordinatamente su queste dieci righe.
Domanda dalla risposta: a volte è una sfida sapere a cosa
Chiedi al nostro amico.Si scopre che è più facile sapere quale risposta (subsoluzione) vogliamo
da lui.Conoscere la risposta che vogliamo sarà un enorme suggerimento su quale domanda
dovrebbe essere.
Ogni soluzione come sequenza di risposte: Un'attività che devi fare come progettista di algoritmo è organizzare le informazioni necessarie per specificare una soluzione in a
Sequenza di campi, sol = ⟨eld1, campo 2 ,..., Fieldm⟩.
Miglior animale: nel problema dello zoo, ogni soluzione è costituita da un animale, che
Ci identificheremo con la sequenza di risposte alle domande del piccolo uccello, sol = ⟨vertebrate, mammifero, gatto, ghepardo.

---
layout: 
title: Pagina 298
level: 3
---


Problemi di ottimizzazione
282
Grafico livellato: nel problema grafico livellato, una soluzione è costituita da a
Path, ⟨s, v1, v6, t⟩, che identificheremo con la sequenza di bordi sol =
⟨⟨S, v1⟩, ⟨v1, v6⟩, ⟨v6, t ⟩⟩.
Stampa ordinatamente: una soluzione per la stampa in modo ordinato il problema fornisce il numero
di parole per ogni riga, ⟨k1 ,..., Kr⟩.
Domanda di Bird e compito rimanente: l'algoritmo chiede al piccolo uccello il
Ultimo campo di campo di una delle soluzioni ottimali dell'istanza e chiede all'amico
I campi rimanenti ⟨end1 ,..., Fieldm - 1⟩.Lasceremo che K denoteremo la risposta fornita dall'uccello e Optsubsol quella fornita dall'amico.Dato entrambi, il
L'algoritmo costruisce la soluzione finale semplicemente concatenando queste due parti
Insieme, vale a dire, optsol = ⟨optsubsol, k⟩ = ⟨⟨eld1 ,..., Fieldm - 1⟩, Fieldm⟩.
Grafico livellato: chiedendo l'ultimo campo di una soluzione ottimale optsol =
⟨⟨S, v1⟩, ⟨v1, v6⟩, ⟨v6, t ⟩⟩aMounts per chiedere l'ultimo vantaggio che il percorso
dovrebbe prendere.L'uccello risponde ⟨v6, t⟩.L'amico fornisce optsubsol =
⟨⟨S, v1⟩, ⟨v1, v6⟩⟩.Concatenare queste forme la nostra soluzione.
Stampa ordinatamente: chiedendo l'ultimo campo di una soluzione ottimale optsol =
⟨K1 ,..., Kr⟩amontes per chiedere quante parole dovrebbero andare sull'ultima riga.
Formulazione della sottoinstabilità: dobbiamo trovare un'istanza del computazionale
Problema la cui soluzione ottimale è optsubsol = ⟨eld1 ,..., Fieldm - 1⟩.L'istanza è che il cui set di soluzioni valide è setSubsol = {subsol |⟨Subsol, k⟩∈
SetSol}.
Grafico livellato: l'istanza la cui soluzione è optsubsol = ⟨⟨s, v1⟩, ⟨v1, v6⟩⟩
è ⟨g, s, v6⟩, chiede il percorso ottimale da S a V6.
Stampa ordinatamente: se l'uccello ti ha detto che un numero ottimale di parole da mettere
Nell'ultima riga c'è K, quindi una stampa ottimale delle parole è una stampa ottimale delle prime parole n -k seguite dalle restanti parole k su una riga di
loro stessi.Il tuo amico può trovare un modo ottimale di stampare queste prime parole
Risolvendo l'instanza ⟨m; l1 ,..., ln - k⟩.Tutto quello che devi fare allora è aggiungere
Le ultime parole K, cioè optsol = ⟨optsubsol, K⟩.
Costi delle soluzioni: oltre a trovare una soluzione ottimale per l'istanza
Io, l'algoritmo deve anche produrre il costo di questa soluzione.Per essere utile, il
Friend fornisce il costo della sua soluzione, Optsubsol.A causa della struttura ricorsiva del problema, i costi di queste soluzioni optsol = ⟨⟨eld1 ,..., ﬁ fiel -1⟩, fieldm⟩and optsubsol = ⟨eld1 ,..., il campo -1 -1 ⟩usualmente differisce in modo uniforme.Per
Esempio, spesso il costo è la somma dei costi dei campi, cioè costo (optsol) =
m
i = 1 costo (fitto).
In
Questo
caso
Noi
Avere
Quello
costo (optsol) = costo (optsubsol) +
costo (campo).

---
layout: 
title: Pagina 299
level: 3
---


Algoritmi di programmazione dinamica
283
Grafico livellato: il costo di un percorso da s a t è il costo dell'ultimo bordo più il
Costo del resto del percorso.
Stampa ordinatamente: il costo totale di una soluzione ottimale per la data istanza ⟨m;
L1 ,..., è il costo della soluzione ottimale per la subinstance ⟨m; l1 ,..., ln - k⟩
più il cubo del numero di spazi vuoti alla fine della linea che contiene l'ultimo
K Words, cioè optCost = optsubCost + (m −k + 1 - n
j = n - k+1 lj) 3.
Prova formale di correttezza:
Struttura ricorsiva dei costi: affinché questo metodo di backtracking ricorsivo a
Risolvi un problema di ottimizzazione, i costi che il problema alloca alle soluzioni devono avere la seguente struttura ricorsiva.Considera due soluzioni sol =
⟨Subsol, k⟩and sol ′ = ⟨subsol ′, k⟩both coerente con la stessa risposta dell'uccello k.
Se la funzione di costo data impone che la soluzione SOL sia migliore della soluzione SOL ′, allora anche il subsol di subsol di SOL sarà migliore del subsol -subsol ′ di Sol ′.Ciò garantisce che qualsiasi subinstance ottimale della subinstance
porta a una soluzione ottimale dell'istanza originale.
Teorema 18.3.1: la soluzione Optsol restituita è una soluzione migliore per I da
Tra quelli che sono coerenti con le informazioni K fornite dall'uccello.
Prova: per mezzo di contraddizione, non assumere.Quindi ci deve essere un'altra soluzione BestSol coerente con K il cui costo è strettamente migliore di quello per Optsol.
Dal modo in cui abbiamo costruito la subinstance del nostro amico, questa soluzione migliore
Deve avere la forma BestSol = ⟨Bettersubsol, K⟩where BestSubsol è una soluzione
per subi.Abbiamo dimostrato nella Sezione 8.7, usando una forte induzione, che possiamo fidarci del
amico per fornire una soluzione ottimale al sub -SODUNSTANZA.Perché il costo
di Bestsol è migliore di quello di Optsol, ne consegue che il costo di BestSubsol è
Meglio di quello di Optsubsol.Ciò contraddice l'affermazione secondo cui Optsubsol è un
Soluzione ottimale per la subinstance subi.
Dimensione di un'istanza: per evitare di ricorrere indipendentemente, la sottoinstabilità che
Dai che il tuo amico deve essere più piccolo della tua istanza secondo alcuni
misura delle dimensioni.A proposito, abbiamo formulato la sottoinstabilità, sappiamo che è
Soluzioni valide subsol = ⟨eld2 ,..., fieldm⟩ sono più corti delle soluzioni valide Sol =
⟨° eld1, field2 ,..., campo dell'istanza.Quindi, una misura ragionevole della dimensione di
Un'istanza è la lunghezza della sua soluzione valida più lunga.Questa misura non riesce solo a funzionare
Quando un'istanza ha soluzioni valide che sono finalmente lunghe.
Grafico livellato: la dimensione dell'istanza ⟨g, s, t⟩ è la lunghezza del percorso più lungo, o semplicemente il numero di livelli, tra S e T.Detto questo, la dimensione della subinstance ⟨g, S, VK⟩, che è il numero di livelli tra S e VK, è più piccola.

---
layout: 
title: Pagina 300
level: 3
---


Problemi di ottimizzazione
284
Ogni soluzione come un albero di risposte: alcuni backtracking ricorsivi, programmazione dinamica e algoritmi avidi hanno la seguente struttura più complessa di
Nelle sezioni precedenti.In questi, i campi che specificano una soluzione sono organizzati
un albero anziché una sequenza.Ad esempio, se il problema è quello di trovare il miglior binario
albero di ricerca, quindi è abbastanza ragionevole che i campi siano i nodi dell'albero e
Questi campi dovrebbero essere organizzati come l'albero stesso.L'algoritmo chiede al uccellino
per dirlo il campo alla radice di una delle soluzioni ottimali dell'istanza.Un amico è
Chiesto di riempire nella sottostruttura sinistra e un altro a destra.Vedi sezioni 19.5 e 19.6.
18.3.3 L'insieme di sottoinstanze
Può essere difficile: quando si utilizza la tecnica di memorizzazione per convertire meccanicamente
Un algoritmo ricorsivo in un algoritmo iterativo, la fase più difficile è determinare per ogni istanza di input l'insieme completo di sottoinstanze che verranno chiamate da
L'algoritmo ricorsivo, a partire da questa istanza.
Grafico livellato: abbiamo ipotizzato che una sottoinstabilità per il problema grafico livellato
è composto da {⟨g, vi, vj⟩ |Coppia VI, VJ}, vale a dire, il compito di trovare il percorso migliore tra ogni coppia di nodi.Più tardi, tracciando l'algoritmo ricorsivo, l'abbiamo visto
Queste sottoinstanze non sono tutte necessarie, perché le sottoinstanze si chiamavano sempre
Cerca un percorso che termina nello stesso nodo fisso t.Dopo aver cambiato la domanda per uccelli per porre sull'ultimo vantaggio, tutte le sottoinstanze chiamate sempre cercano un percorso
A partire dal nodo fisso s.
Indovina e controlla: la tecnica per trovare il set di sottoinstanze è provare prima
Traccia l'algoritmo ricorsivo su un piccolo esempio e indovina quale sarà l'insieme di sottoinstanze.Quindi Lemma 18.3.2 può essere utilizzato per verificare se questo set è abbastanza grande e
Non troppo grosso.
Un set chiuso in un'operazione: diciamo che il set di numeri interi è
chiuso in aggiunta e moltiplicazione perché la somma e il prodotto di qualsiasi
Due numeri pari sono pari.In generale, diciamo che un set è chiuso in un'operazione se
L'applicazione dell'operazione a tutti gli elementi nel set si traduce in un elemento anche in
il set.
Il gioco di costruzione: considera il seguente gioco: ti do l'intero 2. tu
sono autorizzati a costruire nuovi oggetti prendendo oggetti che hai già e
aggiungendoli o moltiplicarli.Qual è l'insieme completo di numeri che sei
in grado di costruire?
Indovina un set: potresti immaginare di essere in grado di costruire l'insieme di positivi
anche numeri interi.Come fai a sapere che questo set è abbastanza grande e non troppo grande?

---
layout: 
title: Pagina 301
level: 3
---


Algoritmi di programmazione dinamica
285
Abbastanza grande: perché l'insieme di numeri interi positivi è chiuso in aggiunta
e moltiplicazione, sostengo che non costruirai mai un oggetto che non è positivo
numero pari.
Prova: dimostriamo per induzione su t ≥0 che dopo i passaggi T hai solo numeri pari positivi.Questo è vero per t = 0, perché inizialmente hai solo il
Positivo anche intero 2. Se è vero per T, l'oggetto costruito nel passaggio T + 1
è la somma o il prodotto di oggetti precedentemente costruiti, che sono
Tutti positivi anche interi.Perché l'insieme di numeri interi positivi è chiuso
In base a queste operazioni, anche l'oggetto risultante deve essere positivo.Questo
Completa il passaggio induttivo.
Non troppo grande: ogni intero anche positivo può essere generato da questo gioco.
Prova: considera un numero pari positivo positivo i = 2J.Inizialmente, ne abbiamo solo 2.
Costruiamo I aggiungendo 2 + 2 + 2 + · · · + 2 un totale di J volte.
Conclusione: l'insieme di numeri interi positivi caratterizza accuratamente che
I numeri possono essere generati da questo gioco, non meno e non più.
Lemma 18.3.2: il set S sarà l'insieme completo di sottoinstanze chiamate avviamento
Dalla nostra istanza iniziale Istart Iff
1. Istart ∈s.
2. S è chiuso sotto il sottosuolo.(S è abbastanza grande.) Il sub operatore è definito
come segue: data una particolare istanza del problema, l'applicazione del sub operatore produce tutte le sottoinstanze costruite da esso da un singolo frame stack del ricorsivo
algoritmo.
3. Ogni subinstance i ∈ è può essere generata da IStart usando il sub operatore.(S è
Non troppo grande.) Ciò garantisce che non ci siano casi in S che non sono necessari.
L'algoritmo di programmazione dinamica funzionerà in modo da set di sottoinstanze contiene sottoinstanze che non vengono chiamate.Tuttavia, non vuoi troppo il set
più grande del necessario, perché il tempo di esecuzione dipende dalle sue dimensioni.
Esempi:
L'elenco degli inviti di nozze: uno degli incubi quando si sposano sta decidendo la lista degli inviti.L'obiettivo è rendere tutti felici tutti lì
Mantenere piccoli il numero di persone.Si applicano anche le tre regole nel lemma
Qui.
Istart ∈s: chiaramente la sposa e lo sposo devono essere invitati.
La chiusura assicura che tutti siano felici: se inviti la zia Hilda, allora in
Ordina di mantenerla felice, devi invitare suo figlio odioso.Allo stesso modo,

---
layout: 
title: Pagina 302
level: 3
---


Problemi di ottimizzazione
286
Devi mantenere felici tutte le tue sottoinstanze, essendo sicuro per ogni
Sopvianza inclusa, sono inclusi anche i suoi amici immediati.Nell'elenco del matrimonio, inviterai rapidamente il mondo intero.Il principio di segazione di sei gradi afferma che l'insieme composto dagli amici dei tuoi amici "
Gli amici degli amici degli amici degli amici includono tutti.Allo stesso modo, per la maggior parte dei problemi di ottimizzazione il numero di sottoinstanze necessarie tende ad essere esponenziale nella dimensione dell'istanza.Un problema ha un buon algoritmo di programmazione dinamica quando il numero di sottoinstanze è piccolo.
Tutti avevano bisogno: vediamo che tutti nella lista devono essere invitati.Persino il
Il figlio odioso deve venire.Perché la sposa deve venire, sua madre deve
Venire.Perché sua madre deve venire, la zia Hilda deve venire, e quindi
il figlio.
Grafico livellato:
Indovina un set: il set indovinato è {⟨g, s, vi⟩ |vi sotto s}.
CHIUSO: considera una subinstance arbitraria ⟨g, s, vi⟩from questo set.Il sub
L'operatore considera un po 'di bordo ⟨vk, vi⟩ e forma la subinstance ⟨g, s, vk⟩.
Questo è contenuto nell'insieme dichiarato di sottoinstanze.
Generazione: considera una subinstance arbitraria ⟨g, s, vi⟩.Sarà chiamato da
L'algoritmo ricorsivo se e solo se esiste un percorso ⟨vi, vk1, vk2 ,..., VKR, T⟩
da VI alla destinazione originale t.Il frame stack iniziale sull'istanza ⟨g, s, t⟩, tra le altre cose, ricorsi su ⟨g, s, vkr⟩, che ricorsi
su ⟨g, s, vkr - 1⟩ ,..., che si ripresenta su ⟨g, s, vk1⟩, che si ripresenta su ⟨g, s, vi⟩.
Se il nodo VI non può essere raggiunto dal nodo S, allora la sottoinstabilità
⟨G, s, vi⟩ill non sarà mai chiamato dall'algoritmo ricorsivo.Nonostante ciò, lo faremo
includerlo nel nostro programma dinamico, perché questo non è noto su VI fino a
Dopo che l'algoritmo è stato eseguito.
Stampa ordinatamente: tracciando l'algoritmo ricorsivo, vediamo che l'insieme della sottoinstabilità usata è costituito solo da prefiniti delle parole, vale a dire, {⟨m; l1 ,..., li⟩ |i ∈
[0, n]}.
Chiuso: sappiamo che questo set contiene tutte le sottoinstanze generate dall'algoritmo ricorsivo, perché contiene l'istanza iniziale ed è chiuso sotto
il sub operatore.Prendi in considerazione una subinstance arbitraria ⟨m; l1 ,..., li⟩from questo
impostato.L'applicazione del sub operatore costruisce le sottoinstanze ⟨m; l1 ,..., li - w⟩
per 1 ≤w ≤i, che sono contenuti nell'insieme indicato di sottoinstanze.
Generazione: considera la sottoinstance arbitraria ⟨m; l1 ,..., li⟩.Dimostriamo che è chiamato dall'algoritmo ricorsivo come segue: lo stack iniziale
frame sull'istanza ⟨m; l1 ,..., ln⟩, tra le altre cose, imposta w su 1 e ricorre su ⟨m; l1 ,..., ln - 1⟩.Questo telaio dello stack imposta anche W su 1 e si ripresenta

---
layout: 
title: Pagina 303
level: 3
---


Algoritmi di programmazione dinamica
287
⟨M; l1 ,..., ln - 2⟩.Questo continua N −i volte, fino a quando il desiderato ⟨m; l1 ,..., li⟩is
chiamato.
Il numero di sottoinstanze: un algoritmo di programmazione dinamica è veloce solo se
L'istanza data non ha molte sottoinstanze.
La sottoinstabilità è una sottosequenza: una ragione comune per il numero di sottoinstanze di una determinata istanza essendo polinomiale è che l'istanza è costituita da a
Sequenza di cose piuttosto che un insieme di cose.In tal caso, ogni sottoinstabilità può
essere una sottosequenza contigua (continua) delle cose piuttosto che un arbitrario
sottoinsieme di loro.Esistono solo successioni contigue di O (N2) di una sequenza di
Lunghezza N, perché si può essere specificati specificando i due punti finali.Anche
Meglio, ci sono ancora meno sottoinstanze se sono definite come prefissi del
sequenza.Ci sono solo n prefiniti, perché si può essere specificati specificando
l'unico punto finale.D'altra parte, ci sono 2n sottoinsiemi di un set, perché per
Ogni oggetto è necessario decidere se includerlo o meno.
Grafico livellato: come indicato nella definizione del problema, è più facile supporre che i nodi siano ordinati in modo che un bordo possa passare dal nodo VI al nodo
VJ solo se io <j.Inizialmente abbiamo indovinato che tre erano sottoinstanze O (N2) costituite da successioni tra due nodi e VJ.Lo abbiamo quindi ridotto
solo al O (n) postfini dalla sorgente fissata S ad un nodo VI.Notare che
Le sottoinstanze non possono essere successive dell'istanza se il grafico di input è
non richiesto di essere livellato.
Stampa ordinatamente: perché l'instanza utilizzata è costituita solo da prefiniti di
Le parole, vale a dire {⟨m; l1 ,..., li⟩ | i ∈ [0, n]}, il numero di essi è O (n).IL
Il parametro singolo utilizzato per specificare una particolare sottoinstabilità è i.Quindi, le tabelle adatte sarebbero birdAdvice [0..n] e costo [0..n].La dimensione della subinstance
è semplicemente il numero di parole, i.Quindi, la tabella è riempita con loop con
I da 0 a n.
Riutilizzo della tabella: a volte è possibile risolvere molte istanze correlate dello stesso
Problema usando la stessa tabella.
Grafico livellato: l'algoritmo ti dà gratuitamente il percorso più breve da s a ciascuno
dei nodi.
Stampa ordinatamente: quando in realtà stampano il testo in modo ordinato, non importa quanti
Gli spazi sono alla fine dell'ultima riga.Quindi, il cubo di questo numero
non dovrebbe essere incluso nel costo.Potremmo usare l'algoritmo originale per trovare
per k = 1, 2, 3 ,...Come stampare tutte tranne le ultime parole K e poi mettere queste ultime
K sull'ultima riga.Tuttavia, ciò richiederebbe un totale di O (N · N2).Invece, il tempo può essere risparmiato colpendo nella tabella solo una volta.Si può ottenere i costi per
Queste diverse istanze da questa singola tabella.Dopo aver determinato quale è meglio,

---
layout: 
title: Pagina 304
level: 3
---


Problemi di ottimizzazione
288
Chiama la stampa in modo che una volta per costruire la soluzione per questa istanza.
Il tempo totale è ridotto solo a O (N2).
18.3.4 Tempo e spazio decrescenti
Riepilogo di un algoritmo di programmazione dinamica: un algoritmo di programmazione dinamica ha due loop nidificati (o serie di loop).La prima parte attraverso tutte le sottoinstanze rappresentate nella tabella, trovando una soluzione ottimale per ciascuno.Durante la ricerca
Una soluzione ottimale per la sottoinstance attuale, il secondo ciclo itera attraverso il
K Possibili risposte alla domanda del piccolo uccello, provando ciascuno di essi.All'interno di questo ciclo interno, l'algoritmo deve trovare una soluzione migliore per la sottoinstabilità attuale da
Tra quelli coerenti con la risposta dell'uccello attuale.Questo passaggio sembra richiedere
Solo una quantità costante di lavoro.Implica la ricerca nella tabella una soluzione ottimale per una sotto-sottopostanza della subinstance attuale e l'utilizzo per costruire un
Soluzione per la sottoinstance attuale.
Tempo di esecuzione?Il tempo di esecuzione è chiaramente il numero di sottoinstabilità nella tabella
volte il numero k di risposte alle domande dell'uccello tempi a ciò che appare (falsamente) a
essere tempo costante.
Trasferimento di informazioni da amico a amico: sia in un backtracking ricorsivo che in un
Algoritmo di programmazione dinamica, le informazioni vengono trasferite dal sottofamico a
amico.Nel backtracking ricorsivo, queste informazioni vengono trasferite restituendole da
una chiamata di subroutine.Nella programmazione dinamica, queste informazioni vengono trasferite avendo
Il sottofriente memorizza le informazioni nella voce della tabella associata alla sua sottoinstabilità
E avere l'amico a cercare queste informazioni dal tavolo.Le informazioni trasferite sono una soluzione ottimale e il suo costo.Il costo, essendo solo un numero intero, non è un grande
Affare.Tuttavia, una soluzione ottimale generalmente richiede (n) caratteri per scrivere.
Pertanto, il trasferimento di queste informazioni richiede questo tempo.
Grafico livellato: nella riga del codice "Optsolk = Optsol [k] + ⟨vk, vi⟩", chiede Friedi
Friendk per il suo percorso migliore.Questo percorso può contenere N nodi.Quindi, potrebbe richiedere
Amici O (n) passi temporali semplicemente per trasferire la risposta da Friendk.
GIECCO DI STUMAZIONE TEMPO E SPAZIO: essendo all'interno di questi due anelli nidificati, questo trasferimento di informazioni è il collo di bottiglia sul tempo di esecuzione dell'algoritmo.In una dinamica
Algoritmo di programmazione, queste informazioni per ogni sottoinstabilità sono archiviate nella tabella
per la durata dell'algoritmo.Quindi, questo è un collo di bottiglia nello spazio della memoria
Requisiti dell'algoritmo.
Grafico livellato: il tempo totale è O (n · d · n).Lo spazio totale è (n · n), essendo
O (n) per ciascuna delle voci della tabella N.

---
layout: 
title: Pagina 305
level: 3
---


Algoritmi di programmazione dinamica
289
Un algoritmo di programmazione dinamico più veloce: ora modificheremo la dinamica
Algoritmo di programmazione per ridurre i requisiti di tempo e spazio.L'idea chiave
è ridurre la quantità di informazioni trasferite.
Costo dal sottocost
Al fine di trovare il costo di una soluzione ottimale alla subinstance attuale.I sottocampi devono solo fornire il costo di questa sottosoluzione ottimale.Trasferendo solo il
I costi accelerano l'algoritmo.
Grafico livellato: affinché Friedi possa trovare il costo di un miglior percorso da S a VI, lui
Ho bisogno di ricevere solo il miglior sottoschetto dai suoi amici.(Vedi i numeri all'interno del
cerchi nella Figura 18.3.b.) Per ciascuno dei bordi ⟨vk, vi⟩ dal suo nodo di destinazione
VI, impara da Friendk il costo di un percorso migliore da S a VK.Aggiunge il costo
del bordo ⟨vk, vi⟩to questo per determinare il costo di un percorso migliore da s a vi da
Tra quelli che prendono questo vantaggio.Quindi determina il costo di un migliore
Percorso da S a VI prendendo il meglio di questi costi migliori.
Si noti che questo algoritmo richiede o (n · d) —nt o (n · d · n) —time, perché
Questo miglior costo può essere trasferito da Friendk a Friedi in tempo costante.Tuttavia, questo algoritmo trova solo il costo del percorso migliore;non trova il meglio
sentiero.
Il consiglio del piccolo uccello:
Definizione dei consigli: un amico che cerca di trovare una soluzione ottimale alla sua sottoinstabilità pone un uccellino una domanda su questa soluzione ottimale.La risposta, di solito indicata da K, a questa domanda classifica le soluzioni.Se questo amico aveva un
uccellino onnipotente, quindi potrebbe consigliargli a quale classe di soluzioni
Cerca per trovare una soluzione ottimale.Dato che non ha un tale uccello, deve semplicemente provare tutte le rese delle possibili risposte e determinare se stesso quale
La risposta è la migliore.Ad ogni modo, faremo riferimento a questa migliore risposta come consiglio del uccellino.
Grafico livellato: il consiglio dell'uccello a Friedi, che sta cercando di trovare un percorso migliore
Da S a VI, è il bordo per durare.Questo vantaggio per ogni amico è indicato
dalle piccole frecce nella Figura 18.3.b.
Consigli dal costo: all'interno dell'algoritmo che trasferisce solo il costo di un ottimale
Soluzione, ogni amico è in grado di determinare il consiglio del uccellino.
Grafico livellato: Friedi determina, per ciascuno dei bordi ⟨vk, vi⟩into suo
nodo, il costo di un miglior percorso da s a vi tra quelli che lo prendono
bordo, e quindi determina quale di questi è meglio.Quindi, sebbene questo amico
Non impara mai un percorso migliore da s a vi nella sua interezza, impara quale vantaggio
è preso per ultimo.In altre parole, determina, anche senza aiuto da parte del
Piccolo uccello, quale sarebbe il consiglio del uccellino.

---
layout: 
title: Pagina 306
level: 3
---


Problemi di ottimizzazione
290
Trasferimento del consiglio dell'uccello: il consiglio dell'uccello non deve essere trasferito
Da Friendk a Friedi, perché Friedi non ne ha bisogno.Tuttavia, Friendk lo farà
Conservare questo consiglio nel tavolo in modo che possa essere utilizzato alla fine dell'algoritmo.
Questo consiglio di solito può essere conservato in uno spazio costante.Quindi, può essere immagazzinato
Con il miglior costo in tempo costante senza rallentare l'algoritmo.
Grafico livellato: il consiglio indica un singolo bordo.Teoricamente, prendendo
O (logn) bit, questo impiega più spazio costante;praticamente, tuttavia, può
essere archiviato usando due numeri interi.
Informazioni memorizzate nella tabella: Per rendere più veloce l'algoritmo di programmazione dinamica, le informazioni memorizzate nella tabella non saranno più una soluzione ottimale
e il suo costo.Invece, solo il costo di una soluzione ottimale e il consiglio del uccellino k
sono immagazzinati.
Grafico livellato: il codice di programmazione dinamico nella sezione 18.2 per LaspedGraph ha solo due piccole modifiche.La riga "Optsolk = optsol [k] + ⟨vk, vi⟩"
All'interno del ciclo interno e della linea "Optsol [i] = Optsolkmin", che memorizza la soluzione ottimale, vengono commentate (ti consiglio di lasciarli come commenti
Per aggiungere chiarezza per il lettore).Il secondo di questi viene sostituito con la linea
"BirdAdvice [i] = kmin", che memorizza il consiglio dell'uccello.Vedere la sezione 18.3.6 per il
Nuovo codice.
Requisiti di tempo e spazio: il tempo di esecuzione dell'algoritmo che calcola il
i costi e il consiglio dell'uccello sono
Time = (il numero di sottoinstanze che indicizzano la tabella)
× (il numero di risposte diverse K alla domanda dell'uccello)
Il requisito dello spazio è
Spazio = il numero di sottoinstanze che indicizzano la tabella
Grafico livellato: come detto, ci sono n sotterranei e una risposta per uccelli per ogni bordo
fuori dal suo nodo di origine VI.Quindi, il tempo di esecuzione è O (n · d).
Stampa ordinatamente: ci sono (n) sottoinstanze nella tabella e il numero di
Possibili risposte per l'uccello è (n), perché ha la possibilità di dirti
Abbastanza bene qualsiasi numero di parole da mettere sull'ultima riga.Quindi, la corsa totale
Il tempo è (n) · (n) = (n2) e il requisito dello spazio è (N).
Costruire una soluzione ottimale: con queste modifiche, l'algoritmo no
Costruisce più a lungo una soluzione ottimale.Una soluzione ottimale per l'istanza originale
è richiesto, ma non per le sotterranee.Costruiamo una soluzione ottimale per l'istanza utilizzando un algoritmo separato che viene eseguito dopo la programmazione dinamica più veloce
L'algoritmo infila il tavolo con i costi e i consigli degli uccelli.Questo nuovo algoritmo ricomincia
Dall'inizio, risolvendo il problema di ottimizzazione.Tuttavia, ora sappiamo cosa

---
layout: 
title: Pagina 307
level: 3
---


Algoritmi di programmazione dinamica
291
Risposta il piccolo uccello darebbe per ogni sottoinstabilità considerata.Quindi, possiamo
Basta eseguire l'algoritmo di Bird -Friend.
Un algoritmo di uccello ricorsivo: la seconda manche dell'algoritmo sarà
identico all'algoritmo ricorsivo, tranne ora dobbiamo solo seguire un percorso
lungo l'albero di ricorsione.Ogni frame stack, invece di ramificare per ciascuno dei
K risponde che l'uccello potrebbe dare, ricorre solo sulla singola risposta data da
l'uccello.Questo algoritmo funziona molto rapidamente.Il suo tempo di esecuzione è proporzionale a
Numero di campi necessari per rappresentare la soluzione ottimale.
Grafico livellato: un percorso migliore da S = V0 a T = Vn si trova come segue.Ogni
L'amico sa quale vantaggio è l'ultimo vantaggio per raggiungere il suo nodo.Che cosa
resti è mettere insieme questi pezzi camminando all'indietro attraverso il
Grafico, seguendo le direzioni indicate.Vedi Figura 18.3.C.Friendt lo sa
che l'ultimo vantaggio è ⟨v 8, t⟩.Friend8 sa che il precedente è ⟨v5, v 8⟩.
Friend5 conosce il bordo ⟨v3, v5⟩.Infine, Friend3 conosce il bordo, v3⟩.Questo
Completa il percorso.
Algoritmo LaspedGraphWithadvice (⟨g, S, Vi⟩, BirdAdvice)
⟨Pre- & Post-COND⟩: uguale a LeveledGraph, tranne con i consigli.
inizio
if (s = vi) quindi return (∅)
kmin = BirdAdvice [i]
optsubsol = liveledGraphWithaDvice (⟨g, S, Vkmin⟩, BirdAdvice)
optsol = optsubsol + ⟨vk, vi⟩
Restituisce Optsol
Algoritmo di fine
Esercizio 18.3.2 perché l'algoritmo per i grafici livellati con consigli si ripresentano
Una volta per telaio dello stack, è facile trasformarlo in un algoritmo iterativo.L'algoritmo
è molto simile a un algoritmo avido.In quanto sa sempre quale scelta avida fare.
Progetta questo algoritmo iterativo.
18.3.5 Contare il numero di soluzioni
Gli algoritmi di programmazione dinamici che abbiamo considerato finora restituiscono uno dei
Forse molte soluzioni ottimali per la data istanza.Potrebbe esserci un esponenziale
Numero di soluzioni.In questa sezione, vediamo come cambiare gli algoritmi in modo che loro
Output anche il numero di possibili soluzioni ottimali.
Conteggio della frutta: se voglio contare il numero di pezzi di frutta in una ciotola, posso chiedere
un amico per contare per me il frutto rosso e un altro il frutto verde e un altro il
arancia.La mia risposta è la somma di questi tre.Se tutta la frutta arancione è marcia, allora io
Potrebbe non includere il numero di frutti arancioni nella mia somma.

---
layout: 
title: Pagina 308
level: 3
---


Problemi di ottimizzazione
292
Doppio conteggio: per essere sicuro di non contestare alcune soluzioni ottimali, abbiamo bisogno dell'insieme di soluzioni coerenti con una risposta di un uccello per essere disgiunti da quelli
coerente con un'altra risposta per uccelli.
Frutta: se alcuni frutti sono mezzo rosso e mezzo verde, questi potrebbero essere contati a doppia.
Vogliamo assicurarci che il colore divida in modo disgustoso il frutto secondo il
risposta data.
Grafico livellato: se la risposta dell'uccello ci dice il primo bordo del percorso ottimale, allora
Quei percorsi che iniziano nel primo bordo sono chiaramente diversi dai percorsi che finiscono
nel secondo.
Calcolo del conteggio: nel nuovo algoritmo di programmazione dinamica, ogni amico
memorizza il numero di soluzioni ottimali per la sottoinstabilità, oltre al costo
della soluzione ottimale per la sua sottoinstabilità e il consiglio dell'uccello.Questo è calcolato
come segue.Un amico con una di queste sotterranee prova a ciascuno dei possibili uccelli
Risposte.Quando provi K, trova la migliore soluzione alla sua istanza tra i suoi
soluzioni coerenti con la risposta di questo uccello k chiedendo a un suo amico
Risolvi un po 'di sottoinstabilità.Questo amico gli dice il numero di soluzioni ottimali a questo
subinstance.Lascia che Numk sia questo numero.Generalmente, esiste una mappatura individuale tra le soluzioni e le soluzioni ottimali del nostro amico alla sua istanza che sono coerenti
Con la risposta di questo uccello k.Quindi, sa che ci sono numer di questi.Come prima, lascia che OptCostk sia il costo della migliore soluzione alla mia istanza tra le sue soluzioni
che sono coerenti con la risposta di questo uccello k.L'amico calcola il costo della sua soluzione ottimale semplicemente di OptCost = maxk∈ [k] optcostk.Potrebbe esserci un certo numero di uccelli
Risposte che portano a questo stesso costo ottimale optcost.Ognuno di questi porta a ottimale
soluzioni.Siamo stati attenti che l'insieme di soluzioni coerente con una risposta di uccello
è disgiunta da quella coerente con un'altra risposta per uccelli.Quindi, il numero totale
di soluzioni ottimali alla mia istanza è num =
k∈ {k |optcostk = optcost} numk.Vedere la sezione 18.3.6 per il nuovo codice grafico livellato.
CONDULARE IL NUMERO DI SOLUZIONI: Num (n) indica il numero massimo
di possibili soluzioni ottimali che qualsiasi programma dinamico come descritto sopra potrebbe
output, data un'istanza di dimensioni n.Il numero numer di soluzioni ottimali riportate
Dall'amico del nostro amico è al massimo numer (n -1), perché la sua sottoinstabilità ha dimensioni a
La maggior parte di N −1.Ci sono al massimo le risposte a K Bird.Quindi, num =
k∈ {k |optcostk = optcost}
NumK può essere al massimo num (n) =
k∈ [1..k] num (n −1) = k × num (n −1) = k n.Nota
Che ci vorrebbe tempo esponenziale per produrre queste soluzioni ottimali.Tuttavia, il numero di bit per rappresentare questo numero è solo log2 (k n) = log2 (k) × n = (n).
Quindi, questo numero può essere emesso.
18.3.6 Il nuovo codice
Tre modifiche: l'algoritmo di programmazione dinamica per il problema grafico livellato sviluppato nella sezione 18.2 è stato modificato in tre modi.

---
layout: 
title: Pagina 309
level: 3
---


Algoritmi di programmazione dinamica
293
Invertire l'ordine: come descritto nella sezione 18.3.1, l'algoritmo è stato riqualificato con il uccellino che veniva chiesto l'ultimo vantaggio nel percorso anziché per il
primo bordo.Questo ha il vantaggio estetico di avere l'algoritmo ora di ramo
fuori in avanti da s invece di arretrare da t.
Conservare i consigli di Bird invece della soluzione: come descritto nella sezione 18.3.4, l'algoritmo ora memorizza il consiglio del piccolo uccello anziché la soluzione ottimale.Questo è
Fatto per ridurre il tempo e lo spazio utilizzato dall'algoritmo da un fattore di n.
Contare il numero di soluzioni: come descritto nella sezione 18.3.5, l'algoritmo, oltre a una delle molte soluzioni ottimali per la data istanza, ora emette anche il numero di possibili soluzioni ottimali.
Codice:
Algoritmo livellatedGraph (G, S, T)
⟨Pre-Cond⟩: G è un grafico a strati diretto ponderato e S e T sono nodi.
⟨Post-Cond⟩: Optsol è un percorso con peso totale minimo da s tot e optcost
è il suo peso e optnum è il numero di possibili soluzioni ottimali.
inizio
% Tabella: Optsol [i] immagazzinerebbe un percorso ottimale da S a VI, ma in realtà archiviamo solo i consigli dell'uccello per la SubInstance
e il costo della sua soluzione.
Tabella [0..n] BirdAdvice, optcost, optnum
% Base di base: l'unico caso di base è per il miglior percorso da s a s.
Ha solo una soluzione ottimale, che è il percorso vuoto con il costo zero.
% Optsol [0] = ∅
optcost [0] = 0
BirdAdvice [0] = ∅
optnum [0] = 1
% CASI GENERALI: ciclo sopra le sottoinstanze nella tabella.
per i = 1 a n
% Risolvi istanza ⟨g, s, vi⟩ e ﬁ ll nella voce della tabella ⟨i⟩.
% Prova ogni possibile risposta per uccelli.
Per ciascuno dei bordi d ⟨vk, vi⟩
% L'algoritmo di uccelli e amico: l'uccello ci dice che l'ultimo
bordo in un percorso ottimale da s a vi è ⟨vk, vi⟩.Chiediamo all'amico
Per un percorso ottimale da S a VK.Ci dà optsol [k], che lui
ha memorizzato nel tavolo.A questo aggiungiamo il bordo dell'uccello.Questo da
Us Optsolk, che è un percorso migliore da S a VI tra quelli
Percorsi coerenti con la risposta dell'uccello.
% Optsolk = Optsol [k] + ⟨vk, vi⟩
optcostk = optcost [k] + w⟨vk, vi⟩
fine per

---
layout: 
title: Pagina 310
level: 3
---


Problemi di ottimizzazione
294
% Che ha il meglio, optsolk, per la risposta di ogni uccello k, manteniamo il
Il meglio di questi.
kmin = a k che minimizza optcostk
% optsol [i] = optsolkmin
optcost [i] = optcostkmin
BirdAdvice [i] = kmin
optnum [i] =
k∈ {k |optcostk = optcostkmin} optnum [k].
fine per
optsol = liveledGraphWithadvice

⟨G, S, Vn⟩, BirdAdvice

return ⟨optSol, optcost [n], optnum [n]⟩
Algoritmo di fine
Esercizio 18.3.3 (Vedi soluzione nella quinta parte.) Fornire il codice per la stampa in modo ordinato.
Esercizio 18.3.4
Considera la stampa ordinatamente il testo sciocco “Questa settimana ha sette date
in esso ok ”in una colonna con larghezza m = 11. Questo è rappresentato come la stampa in modo ordinato
istanza ⟨m; l1 ,..., ln⟩ = ⟨11;4, 4, 3, 5, 5, 2, 2, 2⟩.(a) Riempi il birdamio [0..n] e
COST [0..N] tabelle per questo esempio.L'istanza originale, la sua soluzione e il suo costo sono
Nella riga inferiore.(b) Quando si riempie in quest'ultima riga, dare soluzioni e costi associati
con ciascuna delle possibili risposte degli uccelli.
Esercizio 18.3.5 Ho visto questo puzzle su un Toronto
metropolitana.La domanda è quante volte il
La parola "treni" appare nell'accompagnamento
diagramma.Ogni evento della parola deve seguire un percorso connesso in modo che ciascuna delle sue lettere lo sia
adiacente alla sua lettera precedente.Per imparare
Il numero di tali eventi, potremmo contare
loro, ma questo potrebbe essere esponenziale nel numero di quadrati.Invece, per ogni scatola fai una quantità costante di lavoro e scrivi un numero intero.In
la fine, la risposta dovrebbe apparire nella scatola
con un "T."Dovresti dare alcune frasi che spiegano l'ordine in cui riempi le scatole, come lo fai e quanto lavoro è.
T
R
UN
IO
N
N
S
S
S
S
S
S
S
S
S
1
S
1
S
1
S
S
S
S
S
S
S
S
S
N
N
N
N
N
N
N
N
N
N
N
N
N
IO
IO
IO
IO
IO
IO
IO
IO
IO
IO
IO
UN
UN
UN
UN
UN
UN
UN
R
R
R
N3
Questo completa la presentazione delle tecniche generali e la teoria dietro
Algoritmi di programmazione dinamica.Ora svilupperemo algoritmi per altri problemi di ottimizzazione.

---
layout: 
title: Pagina 311
level: 3
---


295
19 Esempi di programmi dinamici
19.1
Il problema più lungo-common-sub-subsequenza
C'è una grande domanda di algoritmi che trovano i modelli nelle stringhe, ad esempio il DNA.
Il seguente problema di ottimizzazione è chiamato sottosequenza comune (LCS) più lungo.
Subitativa comune più lunga:
Istanze: un'istanza è costituita da due sequenze x = ⟨x1 ,..., xn⟩and y =
⟨Y1 ,..., ym⟩ per esempio, x = ⟨b, d, c, a, b, a⟩ e y = ⟨a, b, c, b, d, a, b⟩.
Soluzioni: una sottosequenza di una sequenza è un sottoinsieme degli elementi presi in
stesso ordine.Una soluzione è una sottosequenza z = ⟨z1 ,..., zl⟩ che è comune ad entrambi
X e Y.
Misura del successo: il costo (o il successo) di una soluzione è la lunghezza della sottosequenza comune.
Obiettivo: date due sequenze X e Y, l'obiettivo è trovare gli LC.
Esempio: z = ⟨b, c, a⟩ è una soluzione perché è una sottosequenza di x =
⟨B, d, c, a, b, a⟩and y (y = ⟨a, b, c, b, d, a, b⟩).Il costo (successo) di questo
La sottosequenza è | z |= 3. Qui z = ⟨b, c, b, a⟩ dovrebbe essere una sottosequenza comune più comune con il costo 4.
Algoritmo avido: supponiamo x = ⟨a, b, c, d⟩and y = ⟨b, c, d, a⟩.Un algoritmo avido potrebbe impegnarsi ad abbinare le due A.Tuttavia, questo sarebbe un errore, perché la risposta ottimale è z = ⟨b, c, d⟩.
Possibili risposte per uccelli: in genere, la domanda posta al uccellino è
Alcuni dettagli sulla fine di una soluzione ottimale.
Caso xn ̸ = zl: supponiamo che l'uccello ci assicura che l'ultimo carattere di x è
non l'ultimo personaggio di almeno un LCS Z di X e Y. Potremmo quindi semplicemente

---
layout: 
title: Pagina 312
level: 3
---


Problemi di ottimizzazione
296
Ignora quest'ultimo personaggio di X. Potremmo chiedere a un amico di darci un LCS di X ′ =
⟨X1 ,..., xn - 1⟩ e y, e questo sarebbe un LCS di X e Y.
Caso ym ̸ = zl: Allo stesso modo, se ci viene detto che l'ultimo carattere di y non è usato, quindi
Possiamo ignorarlo.
Caso xn = ym = zl: supponiamo che l'uccello ci dica che l'ultimo carattere di
Sia X che Y sono l'ultimo carattere di una Z. ottimale, ovviamente, questo implica
Gli ultimi personaggi di X e Y sono gli stessi.In questo caso, potremmo semplicemente ignorare
Quest'ultimo personaggio di X e Y. Potremmo chiedere a un amico di darci il più lungo
Sinsequenza comune di x ′ = ⟨x1 ,..., xn - 1⟩and y ′ = ⟨y1 ,..., ym - 1⟩.Un lcs di x
e y sarebbe lo stesso, tranne che con il carattere xn = ym attaccato al
fine, cioè z = z′xn.D'altra parte, se il uccellino risponde a questo caso
xn = ym = zl e noi per noi osserviamo che xn ̸ = yn, allora sappiamo che il
Il piccolo uccello è sbagliato.
Caso Zl =?: Ancora più estremo, supponiamo che l'uccello arrivi fino a dire
noi l'ultimo personaggio di un LCS Z. Potremmo quindi eliminare gli ultimi personaggi di X e
Y fino all'ultima occorrenza di questo personaggio.Un amico potrebbe darci
un LCS di X e Y rimanenti, e quindi potremmo aggiungere il personaggio noto
per darci Z.
Caso xn = zl ̸ = ym: supponiamo che l'uccello ci assicura che l'ultimo carattere di x
è l'ultimo carattere di una Z. ottimale questo ci dirà l'ultimo personaggio di Z e
Quindi l'ultimo caso si applicherà.
La domanda per il piccolo uccello: abbiamo diverse risposte che il
Piccolo uccello potrebbe dare, ognuno dei quali ci aiuterebbe a trovare una Z. Ottuale potremmo aggiungere
Ancora più possibili risposte all'elenco.Tuttavia, maggiore è il numero k di possibile
Le risposte sono che più lavoro dovrà fare il nostro algoritmo.Quindi, vogliamo restringere
Questo elenco di possibilità il più possibile.Considereremo solo i primi tre
Risposte degli uccelli.Questo è sufficiente perché per ogni possibile soluzione almeno una
Questi è vero, vale a dire (1) xn ̸ = zl, (2) ym ̸ = zl o (3) xn = ym = zl.Naturalmente, potrebbe accadere che xn ̸ = zl e ym ̸ = zl, ma se questo è vero, l'uccello ha un uccello
Scelta se rispondere (1) o (2).
L'insieme di sottoinstanze: supponiamo che l'insieme di sottoinstanze dell'istanza
⟨⟨X1 ,..., xn⟩, ⟨y1 ,..., ym⟩⟩is {⟨⟨x1 ,..., xi⟩, ⟨y1 ,..., yj⟩⟩ |I ≤n, j ≤m}.
Chiuso: sappiamo che questo set contiene tutte le sottoinstanze generate dall'algoritmo ricorsivo, perché contiene l'istanza iniziale ed è chiuso sotto
L'operazione secondaria.Prendi in considerazione una subinstance arbitraria, ⟨⟨x1 ,..., xi⟩, ⟨y1 ,..., yj⟩⟩.
L'applicazione del sub operatore costruisce le sottoinstanze ⟨⟨x1 ,..., xi - 1⟩, ⟨y1 ,..., yj - 1⟩⟩, ⟨⟨x1 ,..., xi - 1⟩, ⟨y1 ,..., yj⟩⟩ e ⟨⟨x1 ,..., xi⟩, ⟨y1 ,..., yj - 1⟩⟩, che sono tutti
contenuto nell'insieme dichiarato di sottoinstanze.

---
layout: 
title: Pagina 313
level: 3
---


Esempi di programmi dinamici
297
Generazione: sappiamo che l'insieme specifico di sottoinstanze non contiene
Sottoseguizioni non chiamate dal programma ricorsivo, perché possiamo costruire
Qualsiasi sottoinstallazione arbitraria dal set con il sub operatore.Considera un
Subinstance arbitraria ⟨⟨x1 ,..., xi⟩, ⟨y1 ,..., yj⟩⟩.Il programma ricorsivo sul file
istanza ⟨⟨x1 ,..., xn⟩, ⟨y1 ,..., ym⟩⟩can si riprende la prima opzione n −i volte
e poi sulla seconda opzione m −J volte.Ciò si traduce in Subinstance
⟨⟨X1 ,..., xi⟩, ⟨y1 ,..., yj⟩⟩.
Costruire una tabella indicizzata per sottoinstabilità: ora costruiamo una tabella con una voce per ogni sottoinstabilità.Avrà una dimensione per ciascuno dei parametri e J utilizzati per specificare una particolare subinstance.Le tabelle saranno costose [0..n, 0..M]
e BirdAdvice [0..n, 0..M].
Casi di base: la sottoinstabilità rappresentata dal costo [0, j] è ⟨∅, ⟨y1 ,..., ym⟩⟩ e non ha no
personaggi in X. Quindi, non è ragionevole chiedere all'uccello l'ultimo personaggio di
X. Inoltre, questo è un caso facile da gestire come custodia di base.L'unica sottosequenza del
La stringa vuota è la stringa vuota.Quindi, LCS è la stringa vuota.Il costo di questo
La soluzione è il costo [0, J] = 0.
Ordine in cui riempire la tabella: l'ordine ufficiale in cui riempire la tabella
con le sottoinstanze vanno da più piccole a più grandi.Qui le dimensioni della subinstance
⟨⟨X1 ,..., xi⟩, ⟨y1 ,..., yj⟩⟩is i + j.Pertanto, si insinua nel tavolo lungo le diagonali.Tuttavia, l'ovvio ordine di looping, per i = 0 a N e da j = 0 a m, anche
Rispetta invece le dipendenze tra i casi e quindi potrebbero essere usati.
Codice:
Algoritmo LCS (⟨⟨x1,.., Xn⟩, ⟨y1,.., ym⟩⟩)
⟨Pre-Cond⟩: un'istanza è costituita da due sequenze.
⟨Post-Cond⟩: Optsol è un LCS e OptCost è la sua lunghezza.
inizio
% Tabella: Optsol [i, J] memorizzerebbe un LCS ottimale per ⟨⟨x1 ,..., xi⟩, ⟨y1 ,..., yj⟩⟩, ma in realtà archiviamo solo i consigli dell'uccello per il
Sottosessuale e costo della sua soluzione.
Tabella [0..n, 0..M] BirdAdvice, costo
% Casi di base: i casi di base sono costituiti da quando una stringa o l'altra è
vuoto, cioè quando i = 0 o quando j = 0.
Per ciascuno, la soluzione è la stringa vuota con costo zero.
per j = 0 a m
% Optsol [0, J] = ∅
costo [0, j] = 0
BirdAdvice [0, J] = ∅

---
layout: 
title: Pagina 314
level: 3
---


Problemi di ottimizzazione
298
fine per
per i = 0 a n
% optsol [i, 0] = ∅
costo [i, 0] = 0
BirdAdvice [i, 0] = ∅
fine per
% CASI GENERALI: ciclo sopra le sottoinstanze nella tabella.
per i = 1 a n
per j = 1 a m
% Risolvi l'istanza ⟨⟨x1 ,..., xi⟩, ⟨y1 ,..., yj⟩⟩ e ﬁ ll nella voce della tabella
⟨I, j⟩.
% L'algoritmo di uccelli e amicizia: l'uccello ci dice (1) xi ̸ = zl ′, (2) yj ̸ = zl ′ o (3) xi = yj = zl ′.Rimuoviamo quest'ultima lettera (1) xi, (2)
YJ, o (3) entrambi e chiedi all'amico un LCS ottimale per le parole rimanenti.Ci dà (1) Optsol [I −1, J], (2) Optsil [I, J −1] o (3) Optsol [I −1, J −1], che ha memorizzato nella tabella.Per i casi
1 e 2, lasciamo questo lo stesso.Per il caso 3, aggiungiamo l'uccello
lettera, supponendo che xi = yj.Questo ci dà Optsolk che è un LCS
Per ⟨i, tra quelle stampe coerenti con l'uccello
risposta.
% Prova ogni possibile risposte degli uccelli.
% Case k = 1): xi ̸ = zl ′
% optsol1 = optsol [i −1, j]
cost1 = cost [i −1, j]
% Caso K = 2): YJ ̸ = Zl ′
% optsil2 = optsol [i, j −1]
cost2 = cost [i, j −1]
% Case k = 3): xi = yj = zl ′
Se xi = yj allora
% optsol3 = optsol [i −1, j −1] + xi
cost3 = cost [i −1, j −1] + 1
altro
% Bird aveva torto.
% optsol3 =?
cost3 = −∞
finisci se
% Casi finali
% Avendo il meglio, Optsolk, per la risposta di ogni uccello K, manteniamo il meglio di questi.
kmax = a k ∈ [1, 2, 3] che massimizza costk
% optsol [i, j] = optsolkmax

---
layout: 
title: Pagina 315
level: 3
---


Esempi di programmi dinamici
299
costo [i, j] = costkmax
BirdAdvice [i, j] = kmax
fine per
fine per
optsol = lcswithadvice (⟨⟨x1,., xn⟩, ⟨y1,.
restituire ⟨optsol, costo [n, m]⟩
Algoritmo di fine
Utilizzando le informazioni sull'installazione: questo algoritmo ha solo tre diverse risposte agli uccelli.Sicuramente, questo è abbastanza buono.Tuttavia, il numero delle possibili risposte può essere ridotto ulteriormente.Sappiamo che l'istanza è ⟨⟨x1 ,..., xi⟩, ⟨y1 ,..., yj⟩⟩;Quindi, senza chiedere all'uccello, sappiamo se gli ultimi personaggi sono uguali o meno, cioè se xi = yj.Se xi ̸ = yj, il terzo caso con
xi = yj = zl ′ non è chiaramente possibile.Al contrario, quando xi = yj, ci si potrebbe anche meravigliarsi
Se il caso XI ̸ = Zl ′ potrebbe mai portare a una soluzione ottimale.Esercizio 19.1.1 spettacoli
che in questo caso dobbiamo solo considerare xi = yj = zl ′.Come in un algoritmo avido, noi
Conosci la risposta anche prima di porre la domanda.
Costruire una soluzione ottimale:
Algoritmo lcswithadvice

⟨⟨X1 ,..., xi⟩, ⟨y1 ,..., YJ⟩⟩, BirdAdvice

⟨Pre- & Post-Cond⟩: uguale a LCS tranne che con i consigli.
inizio
if (i = 0 o j = 0) quindi
optsol = ∅
Restituisce Optsol
finisci se
KMAX = BirdAdvice [i, J]
Se kmax = 1 allora
optsubsol = lcswithadvice (⟨⟨x1, ..., xi - 1⟩, ⟨y1,., Yj⟩⟩, BirdAdvice)
optsol = optsubsol
altro se kmax = 2 allora
optsubsol = lcswithadvice (⟨⟨x1, ..., xi⟩, ⟨y1,., YJ - 1⟩⟩, BirdAdvice)
optsol = optsubsol
altro se kmax = 3 allora
optsubsol = lcswithadvice (⟨⟨x1, ..., xi - 1⟩, ⟨y1,., yj - 1⟩⟩, birdam
optsol = ⟨optsubsol, xi⟩
finisci se
Restituisce Optsol
Algoritmo di fine
Requisiti di tempo e spazio: vedere l'esercizio 19.1.2.

---
layout: 
title: Pagina 316
level: 3
---


Problemi di ottimizzazione
300
0
1
2
3
7
0
3
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
1
1
0
1
0
4
5
6
1
2
4
5
6
7
0
1
0
1
0
0
1
0
0
1
0
1
1
1
J
io
J
y
X
io
1
1
2
2
2
1
1
2
2
2
3
3
3
1
1
1
1
2
2
2
3
3
3
4
4
4
3
4
4
5
1
1
3
8
1
0
2
2
2
2
2
3
3
3
4
4
4
4
5
5
5
5
6
Figura 19.1: le tabelle generate per l'istanza x = 1001010 e y = 01011010. ciascuno
Il numero è il costo [i, j], che è la lunghezza della più lunga sottosequenza comune della prima i
Personaggi di X e il primo J personaggi di Y. La freccia indica se il consiglio dell'uccello è
per includere xi = yj, escludere xi o escludere yj.Le cifre cerchiate di xey danno un ottimale
soluzione.
Esempio: vedi Figura 19.1.
Esercizio 19.1.1 (vedi soluzione nella parte cinque.) (A) Dimostra che se xi = yj, allora noi
Devo considerare il terzo caso e se xi ̸ = yj, allora dobbiamo solo considerare il primo
Due casi.(b) Mostra come questo cambia il codice.
Esercizio 19.1.2 (vedi soluzione nella parte cinque.) Calcola il tempo di esecuzione di questo
algoritmo.
19.2
Programmi dinamici come iterativo più di Input
Algoritmi invarianti in loop
Un programma dinamico può essere pensato da due prospettive molto diverse: come un algoritmo di backtracking ricorsivo ottimizzato e come algoritmo invariante del loop iterativo
che riempiono in un tavolo.Dal punto di vista di un algoritmo iterativo, il loop invariante
Mantenuto è che le voci della tabella precedente sono state riempite correttamente.Il progresso è
Realizzato mantenendo questo loop invariante inserendo nella voce successiva.Ciò si ottiene utilizzando le soluzioni memorizzate nelle voci precedenti.

---
layout: 
title: Pagina 317
level: 3
---


Esempi di programmi dinamici
301
Negli algoritmi iterativi più dell'input (vedere la sezione 1.2), le sottoinstanze sono
prefiniti dell'istanza, e quindi l'algoritmo itera attraverso le sottoinstanze
Iterato in qualche modo attraverso gli elementi dell'istanza.
Semplice esempio 19.2.1
Sottosessenza contigua più lunga in aumento
Supponiamo che l'input sia costituito da una sequenza A [1..n] di numeri interi e vogliamo trovare
La sottosequenza contigua più lunga A [K1, K2] in modo tale che gli elementi siano monotonicamente in aumento.Ad esempio, la soluzione ottimale per [5, 3, 1, 3, 7, 9, 8] è [1, 3, 7, 9].
Blocco più lungo di quelli: il problema è molto simile al blocco più lungo
Problema indicato nella Sezione 2.2.
Automazione deterministica non definita: l'algoritmo leggerà i caratteri di input
uno alla volta.Lascia che un [1..I] denoti la sottosequenza letta finora.L'invariante in loop sarà
che sono archiviate alcune informazioni su questo prefisso a [1..I].Da queste informazioni su
A [1..I] e l'elemento A [i + 1], l'algoritmo deve essere in grado di determinare il richiesto
Informazioni sul pre -ﬁ x A [1..I + 1].Alla fine, l'algoritmo deve essere in grado di determinare la soluzione da queste informazioni sull'intera sequenza A [1..N].Come un
L'algoritmo è un automobile infinito deterministico (DFA) se solo una quantità costante di informazioni viene memorizzata in ogni momento.(Vedi sezione 2.2.) Tuttavia, in questo capitolo di più
sarà richiesta la memoria.
L'algoritmo: dopo aver letto un [1..I], ricorda il più lungo contiguo
La successione A [k1..k2] leggi finora e le sue dimensioni.Inoltre, in modo da sapere se il
La corrente che aumenta la sottosequenza contigua diventa più lunga di quella precedente, salva quella più lunga che termina con il valore a [i] e le sue dimensioni.
Se hai queste informazioni su un [1..I −1], allora puoi impararle su un [1..I] come
segue.Se a [i −1] ≤a [i], allora la fine della sottosequenza contigua più lunga crescente
Nel valore corrente aumenta di lunghezza di uno.Altrimenti, si riduce ad essere solo il
un elemento a [i].Se questa sottosequenza aumenta per essere più lunga del nostro precedente più lungo, sostituisce il precedente più lungo.Alla fine, conosciamo la successione contigua più lunga crescente.
Il tempo di esecuzione è (n).Questo non è un DFA, perché la quantità di spazio per ricordare un indice e un conteggio (pari ai valori (n)) è (log) bit.
Esempio più difficile 19.2.2
La sottosequenza di aumento più lunga
Ancora una volta l'input è costituito da una sequenza A di numeri interi di dimensione n.Tuttavia, ora vogliamo
trovare la successione più lunga (non necessariamente contigua) S ⊆ [1..n] in modo tale che gli elementi, nell'ordine in cui appaiono in A, sono monotonicamente in aumento.Ad esempio, una soluzione ottimale per [5, 1, 5, 7, 2, 4, 9, 8] è [1, 5, 7, 9], e così è [1, 2, 4, 8].
Programmazione dinamica Deterministica Automazione non finita: Ancora una volta l'algoritmo
Leggerà i caratteri di input uno alla volta.Ma ora l'algoritmo si archiverà adatto

---
layout: 
title: Pagina 318
level: 3
---


Problemi di ottimizzazione
302
Esempio più difficile 19.2.2
La sottosequenza più lunga in aumento (cont.)
Informazioni, non solo sulla corrente di conseguenza A [1..I], ma anche su ogni precedente sottosequenza ∀j ≤i, a [1..J].Ognuna di queste successioni a [1..j] verrà deferita
a come sottoinstabilità dell'istanza originale a [1..n].
L'algoritmo: come prima, memorizzeremo sia la sequenza più lunga che viene vista
lontano e quello più lungo che stiamo attualmente crescendo.
L'anello invariante: supponiamo che la sottosequenza sia stata finora 10, 20, 1, 30, 40, 2, 50. Quindi 10, 20, 30, 40, 50 sia la sottosequenza più lunga finora.UN
Uno più corto è 1, 2, 50. Il problema è che questi finiscono in un numero relativamente grande, quindi
Potremmo non essere in grado di estenderli ulteriormente.Se il resto della stringa è 3, 4, 5, 6, 7, 8, avremo ricordato che 1, 2 è la sottosequenza più lunga
Questo termina nel valore 2. In effetti, per molti valori v, dobbiamo ricordare il
La sottosequenza più lunga che termina in questo valore V (o uno più piccolo), perché
Alla fine, può darsi che molti degli elementi rimanenti aumentino a partire da
questo valore.Dobbiamo solo farlo per i valori v che sono stati visti finora nel
vettore.Quindi, una possibilità è conservare, per ogni j ≤i, la più lunga sottosequenza in aumento in un [1..j] che termina con il valore a [j].
Mantenimento dell'invariante loop: se abbiamo queste informazioni per ogni j ≤i −1, allora lo apprendiamo su un [i] come segue.Per ogni j ≤i −1, se a [j] ≤a [i], allora a [i]
può estendere la fine della successione con un [j].Data questa costruzione, la lunghezza massima per io sarò quindi una di quella per J.Otteniamo il più lungo per
Io prendendo il meglio di questi nel complesso.Se non esiste un tale j, allora il conteggio
Sarò 1, vale a dire semplicemente uno stesso [i].
Soluzione finale: alla fine, la soluzione è la crescente sottosequenza che termina
A [j], dove j ∈ [1..n] è quello per il quale questo conteggio è il più grande.
Tempo di esecuzione: il tempo per trovare questa migliore sottosequenza che termina in un [j] da
che estendere a un [i] sarebbe (i) se ogni j ∈ [1..I −1] dovesse essere controllata.
Tuttavia, memorizzando queste informazioni in un mucchio, la migliore J si trova in (logi)
tempo.Questo dà un tempo totale di (n
i = 1 logi) = (n logn) per questo algoritmo.
Backtracking ricorsivo: possiamo anche capire questo stesso algoritmo dalla prospettiva ricorsiva di backtracking.Dato l'obiettivo di trovare la sottosequenza più lunga di un [1..I], potremmo chiedere all'uccello se l'ultimo elemento A [i]
dovrebbe essere incluso.Entrambe le opzioni devono essere provate.Se un [i] non deve essere incluso, allora
La sottobosco rimanente deve trovare la successione in aumento più lunga di un [1..I −1].Questo
è chiaramente una sottoinstabilità dello stesso problema.Tuttavia, se un [i] deve essere incluso, allora
Il sottotitolo rimanente è quello di trovare la successione più lunga crescente di un [1..I −1] che
termina in un valore inferiore o uguale a quest'ultimo valore a [i].Questo è un altro modo di
Vedendo che dobbiamo imparare sia la sequenza in aumento più lunga del prefisso A [1..I]
e il più lungo che finisce in un [i].

---
layout: 
title: Pagina 319
level: 3
---


Esempi di programmi dinamici
303
19.3
Un avido programma dinamico: il lavoro/evento ponderato
Problema di pianificazione
Rivisitiamo il problema della pianificazione degli eventi dalla sezione 16.2.1, ora dà la priorità al
eventi.Il nostro algoritmo avido originale non funzionerà, ma la programmazione dinamica lo farà.
Il problema della pianificazione degli eventi ponderati: supponiamo che molti eventi vogliano
Usa la tua sala conferenze.Ad alcuni di questi eventi viene data una priorità più alta di altri.Il tuo obiettivo è programmare la stanza in modo ottimale.
Istanze: un'istanza è ⟨⟨s1, f1, w1⟩, ⟨s2, f2, w2⟩ ,..., ⟨Sn, fn, wn⟩⟩, dove 0 ≤Si ≤
FI sono i tempi di partenza e di conclusione e con il peso prioritario per n eventi.
Soluzioni: una soluzione per un'istanza è un programma S. Questo è costituito da un sottoinsieme
S ⊆ [1..n] degli eventi che non si confondono da sovrapposizioni nel tempo.
Misura del successo: il costo (o il successo) c (s) di una soluzione s è la somma del
pesi degli eventi programmati, ovvero
i∈S Wi.
Obiettivo: l'obiettivo dell'algoritmo è trovare la soluzione ottimale, ovvero massimizza il peso totale programmato.
Algoritmi falliti:
Tempo di finitura avido: l'algoritmo avido usato nella Sezione 16.2.1 per
La versione non ponderata seleziona avidamente l'evento con il primo tempo di risoluzione
fi.Questo algoritmo fallisce quando gli eventi hanno pesi.Quello che segue è un controesempio:
1
1000
L'algoritmo specificato pianifica l'evento superiore per un peso totale di 1. Il programma ottimale pianifica l'evento inferiore per un peso totale di 1000.
Peso più grande avido: un altro algoritmo avido seleziona il primo evento usando
Il criterio del peso più grande WI.Quello che segue è un controesempio per questo:
2
1
1
1
1 1
1
1
1
1
L'evento superiore ha peso 2 e quelli in basso hanno ciascuno peso 1. L'algoritmo specificato pianifica l'evento superiore per un peso totale di 2. Il programma ottimale pianifica gli eventi in basso per un peso totale di 9.
Programmazione dinamica: l'ovvio algoritmo di programmazione dinamica è per il
Little Bird per dirti se programmare o meno l'evento JN.

---
layout: 
title: Pagina 320
level: 3
---


Problemi di ottimizzazione
304
Algoritmo di uccelli e amico: considera un'istanza j = ⟨⟨s1, f1, w1⟩, ⟨s2, f2, w2⟩ ,..., ⟨Sn, fn, wn⟩⟩.Il piccolo uccello considera un programma ottimale.Noi chiediamo
il piccolo uccello indipendentemente dal programma di evento JN.Se lei dice di sì, allora il
Rimanendo possibili eventi da programmare sono quelli in J, escluso l'evento JN e
Escludendo tutti gli eventi che confondono con l'evento JN.Chiediamo a un amico di programmare
questi.Il nostro programma è il suo con evento aggiunto da JN.Se invece l'uccello ci dice
Non programmare l'evento JN, quindi i restanti eventi possibili da programmare sono
Quelli in J esclusi l'evento JN.
L'insieme di sottoinstanze: quando si traccia l'algoritmo ricorsivo su piccoli esempi, vediamo che l'insieme di sottoinstance utilizzato può essere esponenzialmente grande.
Vedi il lato sinistro della Figura 19.2 per un esempio.Gli eventi in istanza sono
accoppiato in modo che per i ∈ [1..n
2], lavoro ji conflitti con lavoro j n
2 +i, ma lavori tra
Le coppie non si confondono.Dopo che l'uccello ti dice se pianificare o meno
Lavori j n
2 +i per i ∈ [1..n
2], il lavoro Ji rimarrà nella sottoinstabilità se e solo se lavoro
J n
2 +Non ero programmato.Ciò si traduce in almeno 2n/2 percorsi diversi
albero di cornici dello stack nell'algoritmo di backtracking ricorsivo, ciascuno che porta a
una subinstance diversa.
Al contrario, guarda l'istanza a destra nella Figura 19.2.Ha solo
un numero lineare di sottoinstabilità, perché ogni sottoinstabilità è un prefisso di
gli eventi.L'unica differenza tra questi esempi è l'ordine del
eventi.
Programmazione dinamica avida: prima ordina gli eventi in ordine crescente del loro
Finishing Times Fi (una cosa avida da fare).Quindi eseguire la stessa programmazione dinamica
Algoritmo in cui l'uccello ti dice se pianificare o meno l'evento JN.
L'insieme di sottoinstanze: quando si traccia l'algoritmo ricorsivo su piccoli esempi, sembra speranza che l'insieme della sottoinstance usata sia {⟨⟨s1, f1, w1⟩, ⟨s2, f2, w2⟩ ,..., ⟨Si, fi, wi⟩⟩ | i ∈ [0..n]}.In tal caso, l'algoritmo è il tempo polinomiale.IL
Il pericolo è che quando si escludono quegli eventi che si confondono con l'evento JN, la sottoinstabilità creata non avrà più un prefisso contiguo degli eventi.Ad esempio, se l'evento J2 si confonde con JN ma l'evento J3 no, allora la nuova subinstance lo farà
È necessario essere ⟨⟨s1, F1, W1⟩, ⟨S3, F3, W3⟩ ,..., ??⟩, che non è incluso.Bisogno di risolvere
Anche questa subinstance può rendere esponenziale il tempo di esecuzione.
Chiuso: per questo algoritmo, più di quelli precedenti, dobbiamo fare attenzione a dimostrare che questo set contiene tutte le sottoinstanze generate dall'algoritmo ricorsivo mostrando che è chiuso sotto l'operazione secondaria.Prendi in considerazione una subinstance arbitraria ⟨⟨S1, F1, W1⟩, ⟨S2, F2, W2⟩ ,..., ⟨Si, fi, con il
impostato.Se eliminiamo da questo evento Ji e tutti gli eventi che lo confondono, noi
Deve dimostrare che questa nuova sottoinstabilità è di nuovo nel nostro set.Lascia che io sia ′ ∈ [0..I −1]
L'indice più grande tale che fi ′ ≤si.Perché gli eventi sono stati ordinati da

---
layout: 
title: Pagina 321
level: 3
---


Esempi di programmi dinamici
305
Sottosessuale dopo essersi impegnata a mantenere 16 anni
15
14
13
12
11
10
1
2
3
4
5
6
8
Sottosessuale dopo essersi impegnata a mantenere 15
13
11
9
7
5
3
2
4
6
8
1 0
12
14
1
18
16
14
12
10
8
6
4
2
3
5
7
9
1 1
13
15
17
10
11
12
13
14
15
16
17
18
9
8
7
6
5
4
3
2
1
Numeri di lavoro
1
15
13
11
9
7
5
3
2
4
6
8
1 0
12
14
16
17
16
15
14
13
12
11
10
1
2
3
4
5
6
7
8
Sottosessuale dopo essersi impegnata a mantenere 18
1
Sottosessuale dopo essersi impegnata a mantenere 18
Sottosessuale dopo essersi impegnata a rifiutare 16
Sottosessuale dopo essersi impegnata a rifiutare 17
1
8
7
6
5
4
3
2
1
10
11
12
13
14
15
16
14
12
10
8
6
4
2
3
5
7
9
1 1
13
15
Sottosessuale dopo essersi impegnata a rifiutare 14
Sottosessuale dopo essersi impegnata a rifiutare 15
1
12
10
8
6
4
2
3
5
7
9
1 1
13
8
6
5
4
3
2
1
10
11
12
13
14
Sottosessuale dopo essersi impegnata a mantenere 14
1
12
10
8
6
4
2
3
5
7
9
1 1
8
6
4
3
2
1
10
11
12
13
Sottosessuale dopo essersi impegnata a rifiutare 13
12
11
10
1
2
3
6
8
9
7
5
3
2
4
6
8
1 0
1
Sottosessuale dopo essersi impegnata a mantenere 13
Sottosessuale dopo essersi impegnata a mantenere 12
e così via
Figura 19.2: Due esempi delle sottoinstanze formate dal backtracking ricorsivo
algoritmo.
Il loro tempo di finitura, sappiamo che tutti gli eventi JK in ⟨⟨s1, F1, W1⟩, ⟨S2, F2, W2⟩ ,..., ⟨Si ′, fi ′, wi′⟩⟩ anche ha fk ≤Si e quindi non si confonde con ji.Tutti gli eventi
Jk in ⟨⟨si ′+1, fi ′+1, wi ′+1⟩ ,..., ⟨Si, fi, wi⟩⟩have si <fk ≤fi e quindi conflitto
con ji.Ne consegue che l'instanza risultante è ⟨⟨S1, F1, W1⟩, ⟨S2, F2, W2⟩ ,..., ⟨Si ′, fi ′, wi′⟩⟩, che è il nostro insieme di sottoinstanze.Se, d'altra parte, solo l'evento Ji viene eliminato, la sottoinstanza risultante è ⟨⟨S1, F1, W1⟩ ,..., ⟨Si - 1, fi - 1, wi - 1⟩⟩, che è ovviamente nel nostro insieme di sottoinstanze.È perchè
Ciò capisce che l'algoritmo è tempo polinomiale.
Generazione: considera la sottoinstance arbitraria ⟨⟨S1, F1, W1⟩, ⟨S2, F2, W2⟩ ,..., ⟨Si, fi, wi⟩⟩.È generato dall'algoritmo ricorsivo quando il uccellino
afferma che nessuno degli eventi successivi è incluso nella soluzione.
La tabella: la tabella di programmazione dinamica è un array unidimensionale indicizzato
di i ∈ [0..n].L'ordine di infilarlo è con l'aumentare i.Come nell'algoritmo avido, gli eventi sono considerati ordinati dal primo tempo di finitura.L'ingresso
è riempito provando ciascuna delle due risposte che l'uccello potrebbe dare.

---
layout: 
title: Pagina 322
level: 3
---


Problemi di ottimizzazione
306
Requisiti del tempo e dello spazio: in generale, il tempo di esecuzione è il numero di
Sotterragie volte il numero di possibili risposte agli uccelli e lo spazio è il
Numero di sottoinstanze.Ciò darebbe t = (n × 2) e s = (n).In questo
Caso, tuttavia, il tempo di esecuzione è più grande di così.Il motivo è che quando il
L'evento ji deve essere incluso, ci vuole tempo (logn) per fare una ricerca binaria per trovare
quali eventi precedenti si confondono con esso e quindi devono essere eliminati.Questo dà un
tempo di esecuzione di O (n logn), a parte il tempo iniziale di O (n logn) per l'ordinamento di
le attività finendo il tempo.
Esercizio 19.3.1 Scrivi lo pseudocodice per questo algoritmo.
19.4
La soluzione vista come un albero: catene di molteplicazioni matrice
Ora esaminiamo un esempio in cui i campi di informazioni che specificano una soluzione
sono organizzati in un albero anziché in una sequenza (vedere la sezione 18.3.2).L'algoritmo chiede all'uccello di dirgli il campo alla radice di uno degli istanza ottimale
Soluzioni, e quindi un amico separato verrà chiesto per ciascuna delle sottostrutture della soluzione.
Il problema di ottimizzazione determina come moltiplicare in modo ottimale un
catena di matrici.Moltiplicare una matrice A1 × A2 per una matrice A2 × A3 richiede A1 · A2 ·
Moltiplicazioni scalari A3.La moltiplicazione della matrice è associativa, il che significa che (M1 ·
M2) · M3 = M1 · (M2 · M3).A volte diverso da bracketing di una sequenza di matrice
Le moltiplicazioni possono portare al numero totale di molteplicazioni scalari molto diverse.Ad esempio, (⟨5 × 1.000⟩ · ⟨1.000 × 2⟩) · ⟨2 × 2.000⟩ = ⟨5 × 2⟩ · ⟨2 × 2.000⟩ = ⟨5 × 2.000⟩
Richiede 5 × 1.000 × 2 + 5 × 2 × 2.000 = 10.000 + 20.000 = 30.000 Moltiplicazioni scalari.Tuttavia, ⟨5 × 1.000⟩ · (⟨1.000 × 2⟩ · ⟨2 × 2.000⟩) = ⟨5 × 1.000⟩ · ⟨1.000 × 2.000⟩
= ⟨5 × 2.000⟩
Richiede 1.000 × 2 × 2.000 + 5 × 1.000 × 2.000 = 4.000.000 + 10.000.000 = 14.000.000.
Il problema considerato qui è quello di trovare come racchiudere una sequenza di moltiplicazioni di matrice al fine di ridurre al minimo il numero di moltiplicazioni scalari.
Chains of Matrix Moltiplicazioni:
Istanze: un'istanza è una sequenza di n matrici ⟨a 1, un 2 ,..., UN⟩.(Una preliminare è quella per ogni k ∈ [1..n −1], larghezza (ak) = altezza (ak+1).)
Soluzioni: una soluzione è un modo per trattare le matrici, ad esempio ((un 1A 2)
(A 3 (a 4a 5))).Una soluzione può essere vista equivalentemente come un albero binario con le matrici un 1 ,..., An alle foglie.L'albero binario darebbe l'ordine in cui
Moltiplica le matrici:

---
layout: 
title: Pagina 323
level: 3
---


Esempi di programmi dinamici
307
A1
A2
A3
A4
A5
Misura del successo: il costo di una soluzione è il numero di moltiplicazioni scalari necessarie per moltiplicare le matrici in base al bracketing.
Obiettivo: data una sequenza di matrici, l'obiettivo è trovare un bracketing che richiede
Il minor numero di moltiplicazioni.
Un algoritmo avido fallito: un evidente algoritmo avido seleziona dove l'ultimo
La moltiplicazione si verificherà in base alla quale è più economica.Possiamo dimostrare che qualsiasi tale
L'algoritmo semplice e avido fallirà, anche quando l'istanza contiene solo tre matrici.Lascia che le matrici A 1, A 2 e A 3 abbiano altezza e larghezza ⟨A0, A1⟩, ⟨A1, A2⟩ e
⟨A2, A3⟩.Ci sono due ordini in cui questi possono essere moltiplicati.I loro costi sono come
segue:
costo ((a 1 · a 2) · a 3) = a0a1a2 + a0a2a3
costo (a 1 · (a 2 · a 3)) = a1a2a3 + a0a1a3
Considera l'algoritmo che sceglie in modo che l'ultima moltiplicazione sia la più economica.
Supponiamo che l'algoritmo utilizzi il primo ordine.Questo dà a A0A2A3 <A0A1A3, cioè A2 <A1.Tuttavia, il secondo ordine sarà più economico se A0A1A2 + A0A2A3>
a1a2a3 + a0a1a3, cioè se a0 >> a3.Assediamo ora valori semplici che incontrano A2 <A1
e A0 >> A3.Dire a0 = 1000, a1 = 2, a2 ​​= 1 e a3 = 1. Collegando questi dà
costo ((a 1 · a 2) · a 3) = 1000 × 2 × 1 + 1000 × 1 × 1 = 2000 + 1000 = 3000
costo (a 1 · (a 2 · a 3)) = 2 × 1 × 1 + 1000 × 2 × 1 = 2 + 2000 = 2002
Questa è un'istanza in cui l'algoritmo dà la risposta sbagliata.Perché 1000 <
2000, utilizza il primo ordine.Tuttavia, il secondo ordine è più economico.
Un algoritmo di programmazione dinamica fallito: una domanda ovvia da porre al piccolo
Bird sarebbe quale coppia di matrici consecutive per moltiplicare insieme.Anche se
Questo algoritmo funziona, ha un tempo di esecuzione esponenziale.Il problema è che ci sono
un numero esponenziale di diverse sottoinstanze.Considera i percorsi lungo l'albero di
Impostati in cui per ogni coppia un 2i e un 2i+1, l'uccello ci fa moltiplicare insieme o no.Ciò si traduce in percorsi 2N/2 diversi lungo l'albero
di frame dello stack nell'algoritmo di backtracking ricorsivo, ciascuno che porta a un diverso
subinstance.
La domanda da porre all'uccello: una domanda migliore è porre all'uccello
per darci la scissione K in modo che l'ultima moltiplicazione moltiplica il prodotto

---
layout: 
title: Pagina 324
level: 3
---


Problemi di ottimizzazione
308
di ⟨a 1, a 2 ,..., Ak⟩ e di ⟨ak+1 ,..., UN⟩.Ciò equivale a chiedere la radice
dell'albero binario.Per ciascuna delle possibili risposte, la soluzione migliore si trova
Ciò è coerente con questa risposta, e quindi il meglio di queste migliori soluzioni è
restituito.
Ridotto alla sottoinstabilità: con questo consiglio, la nostra ricerca di un bracketing ottimale è
semplificato.Dobbiamo risolvere solo due sottoinstanze: trovare un bracketing ottimale di
⟨A 1, A 2 ,..., Ak⟩ e di ⟨ak+1 ,..., UN⟩.Nell'esempio con ⟨a 1, a 2 ,..., Un 5⟩above, l'uccello divide il problema nelle sottoinstanze ⟨a 1, a 2⟩a e ⟨a 3, a 4, a 5⟩.
Struttura ricorsiva: un bracketing ottimale delle matrici ⟨A 1, A 2 ,..., An⟩multiplica la sequenza ⟨a 1 ,..., Ak⟩ con il suo bracketing ottimale e ⟨ak+1 ,..., An⟩with
è un bracketing ottimale, e quindi moltiplica queste due matrici risultanti insieme,
IS, optsol = (optleft) (optright).
Il costo della soluzione ottimale deriva dal costo per le sottoinstanze:
Il numero totale di moltiplicazioni scalari utilizzate in questo bracketing ottimale è il
numero usato per moltiplicare ⟨a 1 ,..., Ak⟩, più il numero per ⟨ak+1 ,..., An⟩, più
Il numero per moltiplicare le due matrici finali.⟨A 1 ,..., Ak⟩valua a una matrice
la cui altezza è uguale a quella di un 1 e la cui larghezza è quella di Ak.Allo stesso modo, ⟨ak+1 ,..., An⟩becomi a altezza (ak+1) × larghezza (an) matrice.Moltiplicarli richiede un'altezza numerica (A 1) × Larghezza (AK) × Larghezza (AN) Moltiplicazioni scalari.Quindi, in totale, cost = costleft + costright + altezza (a 1) × larghezza (ak) × larghezza (an).
L'insieme di sottoinstanze chiamate: il
impostato
Di
sotterranei
Di
IL
esempio
⟨A 1, A 2 ,..., An⟩is ⟨ai, ai+1 ,..., Un j⟩ per ogni scelta di endpoint 1 ≤i ≤j ≤n.Questo
Insieme di sottoinstanze contiene tutte le sottoinstanze chiamate, perché è chiusa
sotto l'operazione secondaria.Applicando il sub operatore a una sottoinstance arbitraria ⟨ai, ai+1 ,..., A J⟩ da questo set costruisce sottoinstanze ⟨ai ,..., Ak⟩ e
⟨Ak+1 ,..., Un j⟩for i ≤k <j, che sono contenuti nell'insieme dichiarato di sottoinstanze.
Allo stesso modo, il set non contiene sottoinstanze non chiamate dal programma ricorsivo, perché possiamo facilmente costruire qualsiasi sottoinstallazione arbitraria nel set con il sub
operatore.Ad esempio, ⟨A 1 ,..., An⟩sets k = j e chiama ⟨a 1 ,..., Un J⟩, che imposta
k = i + 1 e chiama ⟨ai ,..., Un j⟩.
Costruire una tabella indicizzata per sottoinstabilità: la tabella indicizzata dall'insieme di
Le sottoinstanze avranno una dimensione per ciascuno dei parametri e J utilizzati per specificare
una subinstance particolare.Le tabelle saranno costose [1..n, 1..n] e BirdAdvice [1..n, 1..n].
Vedi Figura 19.3.
Ordina in cui riempire la tabella: la dimensione di una sottoinstabilità è il numero di matrici in essa.In questo ordine riempiremo la tabella.

---
layout: 
title: Pagina 325
level: 3
---


Esempi di programmi dinamici
309
A1
A2
A3
A4
A5
A6
A7
io
J
(i, j) = (2,7)
(K+1, J) = (5,7)
(i, k) = (2,4)
Figura 19.3: la tabella prodotta dalla soluzione di programmazione dinamica per la moltiplicazione della matrice.Quando si cerca il bracketing ottimale di un 2 ,..., Un 7, uno dei metodi da considerare
è [un 2 ,..., A 4] [A 5 ,..., Un 7].
algoritmo matrixmultiplication (⟨a 1, a 2,., an⟩)
⟨Pre-Cond⟩: un'istanza è una sequenza di n matrici.
⟨Post-Cond⟩: Optsol è un bracketing che richiede il minor numero di moltiplicazioni e
OptCost è il numero risultante di moltiplicazioni.
inizio
% Tabella: Optsol [i, J] memorizzerebbe un modo ottimale di trattare le matrici
⟨Ai, ai+1 ,..., Un J⟩, ma in realtà archiviamo solo i consigli dell'uccello per la sottoinstabilità
e il costo della sua soluzione.
Tabella [1..n, 1..n] BirdAdvice, costo
% Casi di base: i casi di base sono quando c'è solo una matrice, cioè ⟨ai⟩.
Per ciascuno, la soluzione è il bracketing vuoto con il costo zero.
per i = 1 a n
% Optsol [i, i] = ai
costo [i, i] = 0
BirdAdvice [i, i] = ∅
fine per
% CASI GENERALI: ciclo sopra le sottoinstanze nella tabella.
per dimensione = 2 a n
per i = 1 a n -zeze + 1
J = i + dimensione −1
% Risolvi l'istanza ⟨i, j⟩ e infila nella tabella.

---
layout: 
title: Pagina 326
level: 3
---


Problemi di ottimizzazione
310
% Prova ogni possibile risposte degli uccelli.
per k = i a j −1
% L'algoritmo di uccelli e amicizia: l'uccello ci dà la scissione K, in modo che l'ultima moltiplicazione moltiplica il prodotto di ⟨ai, ai+1 ,..., E quello di ⟨ak+1 ,..., Un j⟩.Un amico
ci dà optsol [i, k], un bracketing ottimale ⟨ai ,..., Ak⟩, e
Un altro ci dà optsol [k + 1, j], un bracketing ottimale di
⟨Ak+1 ,..., Un j⟩.Combiniamo le informazioni di questi amici e degli uccelli, ottenendo Optsolk, che è il miglior bracketing per ⟨i, J⟩
Tra quelli coerenti con la risposta dell'uccello.
% Ottieni aiuto da un amico
% optsolk = (opt a sinistra) (optright)
costk = cost [i, k] + cost [k + 1, j] + altezza (ai)
× larghezza (ak) × larghezza (a j)
fine per
% Avendo il meglio, Optsolk, per la risposta di ogni uccello K, manteniamo il meglio di questi.
kmin = a k che minimizza costk
% optsol [i, j] = optsolkmin
costo [i, j] = costkmin
BirdAdvice [i, j] = kmin
fine per
fine per
optsol = MatrixMultiplicationWithaDvice (⟨A 1, A 2,., An⟩, BirdAdvice)
restituire ⟨optsol, costo [1, n]⟩
Algoritmo di fine
Costruire una soluzione ottimale:
algoritmo matrixmultiplicationWithadvice (⟨ai, a 2,., A J⟩, BirdAdvice)
⟨Pre- & Post-COND⟩: uguale a MatrixMultiplication tranne che con il consiglio.
inizio
if (i = j) allora
optsol = ai
Restituisce Optsol
finisci se
kmin = BirdAdvice [i, J]
optleft = matrixmultiplicationWithaDvice (⟨A 1,., Akmin⟩, BirdAdvice)
optright = MatrixMultiplicationWithaDvice (
⟨Akmin+1 ,..., A J⟩, BirdAdvice)
Optsol = (Optleft) (OpTright)
Restituisce Optsol
Algoritmo di fine

---
layout: 
title: Pagina 327
level: 3
---


Esempi di programmi dinamici
311
Requisiti di tempo e spazio: il tempo di esecuzione è il numero di sottoinstabilità
volte il numero di possibili risposte degli uccelli e lo spazio è il numero di sottoinstanze.Il numero di sottoinstanze è (N2) e l'uccello sceglie uno di (N)
Luoghi per dividere la sequenza di matrici.Quindi, il tempo di esecuzione è (N3) e il
I requisiti di spazio sono (N2).
Esercizio 19.4.1 Dai i passi per trovare un controesempio per l'algoritmo avido che
Moltiplica prima la coppia più economica.
Esercizio 19.4.2 (vedi soluzione nella parte cinque.) Usa un'immagine per assicurarti che quando ⟨i, J⟩
è riempito, ⟨i, k⟩ e ⟨k + 1, j⟩are già riempito per tutti i ≤k <j.Dai altri due ordini
quel lavoro.
19.5
Generalizzare il problema risolto: il miglior albero AVL
Come discusso nella Sezione 8.3, a volte è utile generalizzare il problema risolto
In modo che tu possa fornire o ricevere maggiori informazioni dal tuo amico in un algoritmo ricorsivo.Ciò è stato dimostrato nel capitolo 10 con un algoritmo ricorsivo per
determinare se un albero è o meno un albero AVL.Questa stessa idea è utile per la programmazione dinamica.Ora lo dimostrerò dando un algoritmo per la ricerca
Il miglior albero AVL.Per iniziare, svilupperemo un algoritmo per la migliore ricerca binaria
albero.
Il miglior albero di ricerca binaria:
I istanze: un'istanza è costituita da NON PROBLIABILITÀ P1 ,..., PN a cui essere associato
I nomi N a1 <a2 <· · · <an.I valori delle chiavi stesse non importano.
Quindi, possiamo supporre che ai = i.
Soluzioni: una soluzione per un'istanza è un albero di ricerca binario contenente le chiavi.
Un albero di ricerca binario è un albero binario in modo tale che i nodi siano etichettati con le chiavi
e per ogni nodo tutte le chiavi nella sua sottostruttura sinistra sono più piccoli e tutti quelli in
a destra sono più grandi.
Misura del successo: il costo di una soluzione è la profondità prevista di una chiave
Quando si sceglie una chiave in base alle probabilità indicate, vale a dire
i∈ [1..n]
[PI · Profondità dell'IA nell'albero].
Obiettivo: date le chiavi e le probabilità, l'obiettivo è trovare un albero di ricerca binaria
con profondità minima prevista.
Profondità prevista: il tempo necessario per cercare una chiave è proporzionale alla profondità
della chiave nell'albero di ricerca binaria.Trovare la radice è veloce.Trovare una foglia profonda prende
molto più a lungo.L'obiettivo è progettare l'albero di ricerca in modo che le chiavi che vengono perquisite
poiché spesso sono più vicini alla radice.Le probabilità P1 ,..., PN, dato come parte dell'input,

---
layout: 
title: Pagina 328
level: 3
---


Problemi di ottimizzazione
312
Specificare la frequenza con cui è cercata ciascuna chiave;ad esempio, p3 = 1
8 significa quella chiave
A3 è alla ricerca in media uno su otto volte.
Uno riduce al minimo la profondità di un albero di ricerca binario rendendolo completamente bilanciato.Avere bilanciato, tuttavia, impone la posizione di ciascuna chiave.Sebbene avere l'albero parzialmente sbilanciato aumenta la sua altezza complessiva, può consentire le chiavi
che sono cercati spesso da posizionare più vicino alla parte superiore.
Riuscimo a mettere alcuni dei nodi vicini alla radice, e altri lo faremo
non.Il modo matematico standard di misurare il successo complessivo di mettere
più probabili tasti più vicini alla parte superiore è la profondità prevista di una chiave quando la chiave è
scelto in modo casuale in base alla distribuzione di probabilità data.È calcolato da

i∈ [1..n] pi · di, dove DI è la profondità dell'IA nell'albero di ricerca.
Un modo per capire questo è supporre che dovevamo cercare un
miliardi di chiavi.Se p3 = 1
8, quindi A3 viene cercato in media uno su otto volte.
Poiché stiamo cercando così tante chiavi, è quasi certo che il numero
di volte cerchiamo questa chiave è molto vicino a 1
8 miliardi.In generale, il numero
Di volte cerchiamo l'intelligenza artificiale è PI miliardi.Per calcolare la profondità media di queste miliardi di ricerche, sommiamo le loro profondità e dividiamo per un miliardo, vale a dire
1
109

K∈ [1..109]
[profondità di KTH Search] =
1
109

i∈ [1..n] (pi × 109) · di =
i∈ [1..n] pi · di.
Algoritmo per uccelli e amico: mi viene data un'istanza composta da N Probabilità
P1 ,..., pn.Chiedo all'uccello quale chiave mettere alla radice.Lei risponde ak.Chiedo a un amico
Per il miglior albero di ricerca binario per le chiavi A1 ,..., AK - 1 e la sua profondità prevista.Chiedo
Un altro amico per il miglior albero dell'altezza specificata FORAK+1 ,..., an e è previsto
profondità.Costruisco l'albero con AK alla radice e questi come sottostrutici sinistra e destra.
Generalizzare il problema risolto: una serie di probabilità P1 ,..., pn che definisce a
La distribuzione di probabilità dovrebbe avere la proprietà che
i∈ [1..n] pi = 1. Tuttavia, noi
generalizzerà il problema rimuovendo questa restrizione.Questo ci permetterà di chiedere al nostro
amico per risolvere le sottetà che non sono naturalmente legali.Si noti che le probabilità
Dato agli amici nell'algoritmo di cui sopra non si somma 1.
Il costo di una soluzione ottimale deriva dai costi per le sotterranee:
La profondità prevista del mio albero viene calcolata da quella fornita dal mio amico come segue.
Costo =
i∈ [1..n] [PI · Profondità di ai nell'albero]
(19.1)
=
i∈ [1..k - 1] [pi · (profondità di Ai nella sottostruttura sinistra) +1] + [pk · 1]
(19.2)
+
i∈ [k + 1..n] [pi · (profondità di ai nella sottostruttura destra) + 1]
(19.3)
= Costleft +

i∈ [1..k - 1] pi

+ pk + costright +

i∈ [k+1..n] pi

(19.4)
= Costleft +

i∈ [1..n] pi

+ Costright
(19.5)
= Costleft + costright + 1
(19.6)

---
layout: 
title: Pagina 329
level: 3
---


Esempi di programmi dinamici
313
Il set completo di sottoinstanze che verrà chiamato: il set completo di
Substances è s = {⟨ai ,..., A J;pi ,..., pj⟩ |1 ≤i ≤j ≤n}.La tabella è twodimensionale con dimensioni (n × N).
Tempo di esecuzione: la tabella ha dimensioni (n × n).L'uccello può dare e risposte diverse.
Quindi, il tempo è (N3).
Ora cambiamo il problema in modo che stia cercando il miglior albero di ricerca AVL.
Il problema del miglior albero:
I istanze: un'istanza è costituita da NON PROBLIABILITÀ P1 ,..., PN a cui essere associato
I nomi N a1 <a2 <· · · <an.
Soluzioni: una soluzione per un'istanza è un albero AVL contenente le chiavi.Un AVL
L'albero è un albero di ricerca binario con la proprietà che ogni nodo ha un fattore di equilibrio
di −1, 0 o 1. Il suo fattore di equilibrio è la differenza tra le altezze della sua sinistra
e sono i sottospelle giuste.
Misura del successo: il costo di una soluzione è la profondità prevista di una chiave,
i∈ [1..n] [PI · Profondità di Ai in t].
Obiettivo: date le chiavi e le probabilità, l'obiettivo è trovare un albero AVL con
profondità minima prevista.
Non possiamo coordinare gli amici: potremmo semplicemente chiedere agli amici di costruire la sinistra e
Sub-Avl-alberi di destra, ma allora cosa faremmo se la differenza nelle loro altezze
erano più grandi di uno?Non possiamo aspettarci che gli amici coordinino le loro risposte.
Il nuovo problema generalizzato: un'istanza è costituita dalle chiavi, dalle probabilità e un'altezza richiesta.L'obiettivo è trovare il miglior albero AVL con il dato
altezza.
Esercizio 19.5.1 (vedi soluzione nella parte cinque.)
1.
Quali sono le possibili altezze per le sottostrutture sinistro e destro di un albero AVL di
Altezza H?
2.
Quale domanda faresti all'uccello?Va bene.per fare due domande.Quale subinstance daresti al tuo amico?
3.
Come ti assicureresti l'equilibrio tra le altezze dei sottospere sinistra e destra?
4.
Qual è l'insieme completo di sottoinstanze che verranno chiamate?
5.
Qual è il tempo di esecuzione del tuo algoritmo?
6.
Nel problema originale, l'altezza non era fissata.Come useresti la tabella per
risolvi questo problema?

---
layout: 
title: Pagina 330
level: 3
---


Problemi di ottimizzazione
314
19.6
Tutte le coppie usando la moltiplicazione matrice
C'è un altro algoritmo di programmazione dinamica che trova anche il percorso più breve
tra ogni coppia di nodi.È simile in qualche modo al Floyd-Warshall-Johnson
Algoritmo, ma è divertente perché può essere visto come moltiplicazione della matrice.
Esercizio 19.6.1 Sia g = (v, e) essere un grafico (diretto o non indirizzato) e k ≤n alcuni
numero intero.Lascia che mk sia una matrice con una riga e una colonna per ciascun nodo nel grafico, in modo tale che per ogni coppia di nodi u, v ∈V the Element mk [u, v] fornisce il numero di percorsi distinti da u a vcontenere esattamente i bordi K.Qui un percorso può visitare un nodo di più
di una volta.M1 [u, v] è uno se c'è un bordo ⟨u, v⟩ e zero altrimenti e m1 [u, u] = 1
Perché c'è un percorso di lunghezza zero da u a te.Dimostra che mi+j = mi m j, dove × è
Moltiplicazione della matrice standard, ovvero mi+j [u, v] =
W [mi [u, w] · mj [w, v]].
Esercizio 19.6.2 Ora lascia che il grafico g = (v, e) abbia pesi wu, v (positivo o negativo) su ciascun bordo.Ridefinire
Mk [u, v] per dare il peso del percorso più breve da u
a v con il peso totale più piccolo tra questi percorsi che contiene esattamente k
bordi.Nota che
M1 [U, V] è il peso del bordo Wu, V (o in ﬁ withità) e
M1 [u, u] = 0
Perché c'è un percorso di lunghezza zero da u a te.Dimostrarlo
Mi+j =
Mi ×
MJ, dove ×
è la moltiplicazione della matrice standard, tranne per il fatto che la moltiplicazione scalare viene cambiata in +
e quello + è cambiato in min, cioè,
Mi+j [u, v] = Minw [
Mi [u, w] +
MJ [W, V]].Confrontare
Questo esercizio con l'esercizio 4.4.3.
Esercizio 19.6.3 Se tutti i pesi del bordo sono positivi, allora il percorso ponderato più breve
contiene al massimo i bordi n -1.Quindi,
Mn [u, v] per n ≥n −1 fornisce il più breve complessivo
Percorso ponderato da U a v. Dato
M1, qual è il modo più veloce di calcolo
Mn per alcuni
N ≥N?
Esercizio 19.6.4 Se esiste un percorso da U a V contenente un ciclo ponderato negativo, questo ciclo può essere ripetuto spesso
Peso e infinitamente molti bordi.Per rilevare questo, calcolare
Mn [u, v] e
M2n [u, v] per
Alcuni grandi n e vedono se sono diversi.Le domande sono quanto devono essere grandi N.Voi
Penserei che n = n −1 sarebbe sufficiente, ma non lo è.Dai un grafico con bordi, ciascuno con pesi interi positivi o negativi ℓ-bit, per i quali
Mk [u, v] =
M1 [u, v] per
k ∈ [1, n] per alcuni n molto grandi, ma
M n+1 [u, v] è più piccolo.
Esercizio 19.6.5
L'algoritmo standard per la moltiplicazione della matrice standard
(N3) tempo.L'algoritmo di Strassen (Sezione 9.2) è in grado di farlo in tempo (N2.8073).Fa
Questo stesso algoritmo funziona per questa strana moltiplicazione?Le equazioni x · (y + z) =
x · y + x · z e (x −y) + y = x sono veri per tutti i numeri reali.Sono veri di sostituire
· Con + e sostituire + con min?

---
layout: 
title: Pagina 331
level: 3
---


Esempi di programmi dinamici
315
19.7
Analisi con grammatiche senza contesto
Nel capitolo 12 abbiamo sviluppato un elegante algoritmo ricorsivo per l'analisi di una stringa
Secondo una determinata grammatica senza contesto che funziona solo per look-ahead-one
grammatiche.Ora sviluppiamo un algoritmo di programmazione dinamica che funziona per qualsiasi
Grammatica senza contesto.
Dato una grammatica G e una stringa S, il primo passo nell'analisi è quella di convertire la grammatica in una in forma normale di Chomsky, che è definita di seguito.Sebbene una dinamica
Il programma potrebbe essere scritto per funzionare direttamente per qualsiasi grammatica senza contesto, funziona molto
Più veloce se la grammatica viene convertita prima.
Il problema dell'analisi:
Istanza: un'istanza è costituita da ⟨G, Tstart, S⟩, dove G è una grammatica in forma normale di Chomsky, Tstart è il non terminale di G designato come simbolo di avvio, e S è la stringa ⟨a1 ,..., e i simboli del terminale da generare.La grammatica
G è costituito da un insieme di simboli non terminali v = ⟨t1 ,..., T | v |⟩ e un insieme di regole
⟨R1 ,..., rm⟩.La definizione della forma normale di Chomsky è che ogni regola rq ne ha una
delle seguenti tre forme:
R AQ ⇒BQCQ, dove AQ, BQ e CQ sono simboli non terminali.
r aq ⇒ bq, dove BQ è un simbolo terminale.
r tstart ⇒ϵ, dove tstart è il simbolo di avvio e ϵ è la stringa vuota.Questa regola
Può essere usato solo per analizzare la stringa S = ϵ.Potrebbe non essere usato all'interno dell'analisi di una stringa più grande.
Soluzione: una soluzione è una parziale analisi P, costituita da un albero.Ogni nodo interno
dell'albero è etichettato con un simbolo non terminale;La radice è etichettata con il simbolo specificato Tstart.Ogni nodo interno deve corrispondere a una regola della grammatica
G. Ad esempio, per la regola a ⇒bc, il nodo è etichettato a e dei suoi due figli
sono etichettati B e C. In un'analisi completa, ogni foglia dell'albero è etichettata con a
simbolo terminale.In un'analisi parziale, alcune foglie possono ancora essere etichettate con non terminali.
Misura del successo: si dice che un anallo p genera la stringa se le foglie del
Analisi nel modulo d'ordine s.Il costo di P sarà uno se genera la stringa S e
sarà zero altrimenti.
Obiettivo: l'obiettivo del problema è, dato un'istanza ⟨g, tstart, s⟩, per trovare un'analisi
P che genera s.
Non guardare avanti uno: la grammatica G potrebbe non essere uno sguardo.Ad esempio, in
A ⇒b c
A ⇒d e

---
layout: 
title: Pagina 332
level: 3
---


Problemi di ottimizzazione
316
Non sai se iniziare a analizzare la stringa come B o D.
Scelta sbagliata, devi eseguire il backup e ripetere il processo.Tuttavia, questo problema è
Un candidato perfetto per un algoritmo di programmazione dinamica.
Il tipo di dati astratti di analisi: useremo il seguente tipo di dati astratto per
Rappresenta gli scaglioni.Supponiamo che esista una regola rq = "aq ⇒bqcq" che genera
BQ e CQ da AQ.Supponiamo anche che la stringa S1 = ⟨A1 ,..., generato ak⟩is
A partire dal simbolo BQ usando l'analisi P1 (BQ è la radice di P1) e quella
S2 = ⟨ak+1 ,..., an⟩is generato da CQ usando P2.Quindi diciamo che la stringa S =
S1 ◦S2 = ⟨A1 ,..., an⟩is generato da AQ usando l'analisi P = ⟨AQ, P1, P2⟩.
Il numero di analisi: di solito, i primi tentativi algoritmici di analisi sono
qualche forma di algoritmo di forza bruta.Il problema è che ci sono un esponenziale
Numero di discussioni da provare.Questo numero può essere stimato approssimativamente come segue.Quando
Analisi, la stringa di simboli deve aumentare dall'essere della dimensione 1 (costituita solo
dei simboli iniziali) per essere di dimensioni n (costituite da s).L'applicazione di una regola ne aggiunge solo una
più simbolo di questa stringa.Pertanto, le regole devono essere applicate n -1 volte.Ogni volta
Applicherai una regola, devi scegliere quale delle regole M applicare.Quindi, il totale
Il numero di scelte può essere (MN).
La domanda da porre all'uccello: dato un'istanza ⟨g, tstart, s⟩, lo faremo
Il piccolo uccello è una domanda che contiene due sottoquesti su una p di analisi che genera S da Tstart.
La prima sottocusta
Prima al nostro simbolo di inizio Tstart.Anche se questa è informazioni utili, non vedo come
da solo potrebbe portare a una sottoinstabilità.
Non conosciamo P, ma sappiamo che P genera s = ⟨A1 ,..., UN⟩.Segue
che, per alcuni k ∈ [1..n], dopo che p applica la prima regola rq = "tstart ⇒ bqcq", genera quindi la stringa S1 = ⟨a1 ,..., Ak⟩from BQ e la stringa S2 = ⟨ak+1 ,..., an⟩from cq, in modo che nel complesso generi S = S1 ◦S2 = ⟨A1 ,..., UN⟩.La nostra seconda sottocestione ha chiesto
dell'uccello è di dirci questo k che divide la corda s.
Aiuto di un amico: ciò che non sappiamo sull'albero di analisi P è come BQ genera S1 = ⟨A1 ,..., Ak⟩ e come CQ genera s2 = ⟨ak+1 ,..., UN⟩.Quindi, chiediamo il nostro
Amici per gli scaglioni ottimali per la sottoinstabilità ⟨g, BQ, S1⟩And ⟨G, CQ, S2⟩.Essi
Rispondi con gli addestramenti P1 e P2.Concludiamo che P = ⟨tStart, P1, P2⟩Genera S = S1 ◦S2 = ⟨A1 ,..., an⟩from tstart.Se uno dei due amici ci dà un'analisi con zero
costo, allora sappiamo che non si siede coerente con le informazioni fornite da
L'uccello è possibile.Anche il costo dei nostri discussioni in questo caso è zero.Questo può
essere raggiunto impostando il costo dell'analisi nuova per essere il minimo di quelli
per P1 e per P2.La riga di codice sarà cost⟨q, k⟩ = min (costo [bq, 1, k], costo [cq, k + 1, n]).

---
layout: 
title: Pagina 333
level: 3
---


Esempi di programmi dinamici
317
L'insieme di sottoinstanze: l'insieme di sottoinstanze che vengono chiamate dal ricorsivo
Il programma composto da te, dai tuoi amici e dai loro amici è {⟨g, th, ai ,..., A J⟩ |h ∈
V, 1 ≤i ≤j ≤n}.
Chiuso: sappiamo che questo set contiene tutte le sottoinstanze generate dall'algoritmo ricorsivo perché contiene l'istanza iniziale ed è chiuso sotto il
operazione secondaria.Prendi in considerazione una subinstance arbitraria ⟨g, th, ai ,..., A j⟩in il set.Suo
Le sottoinstanze sono ⟨G, BQ, AI ,..., ak⟩and ⟨g, cq, ak+1 ,..., un J⟩, che sono entrambi dentro
il set.
Generazione: alcune di queste sotterranee non saranno generate.Tuttavia, la maggior parte
Le nostre istanze lo faranno.
Costruire una tabella indicizzata per sottoinstabilità: la tabella sarà tridimensionale.La soluzione per la subinstance ⟨g, th, ai ,..., un j⟩will sarà archiviato nella voce
Tabella [H, I, J] per H ∈V e 1 ≤i ≤j ≤n.Vedi Figura 19.4.
L'ordine in cui riempire la tabella: la dimensione della sottoinstance ⟨g, th, ai ,..., a J⟩ è la lunghezza della stringa da generare, cioè j −i + 1. inizieremo con più piccoli
stringhe e poi spostarsi su stringhe più lunghe.
Casi di base: un caso di base è la subinstance ⟨G, Tstart, ϵ⟩.Questa stringa vuota ϵ è
Analizzato con la regola Tstart ⇒, supponendo che si tratti di una regola legale.Gli altri casi di base
sono le sottoinstanze ⟨g, aq, bq⟩.Questa stringa, composta dal singolo carattere BQ, è
Analizzato con la regola Aq ⇒ BQ, supponendo che si tratti di una regola legale.
Costruire una soluzione ottimale:
Algoritmo Parsingwithadvice (⟨g, th, ai,.
⟨Pre- & Post-Cond⟩: uguale all'analisi tranne che con i consigli.
inizio
⟨Q, K⟩ = BirdAdvice [H, I, J]
if (i = j) allora
Regola RQ deve avere il modulo "Aq ⇒BQ", dove Aq è th e bq è AI
Analisi p = ⟨th, ai⟩
altro
Regola RQ deve avere il modulo "Aq ⇒ CQ BQ", dove Aq è th.
P1 = parsingwithadvice (⟨g, bq, ai, ..., ak⟩, birdadvice)
P2 = parsingwithadvice (⟨g, cq, ak+1, ..., a j⟩, birdadvice)
Analisi P = ⟨th, P1, P2⟩
finisci se
restituzione (P)
Algoritmo di fine

---
layout: 
title: Pagina 334
level: 3
---


Problemi di ottimizzazione
318
(1,1,1)
io
J
K
(5, i, k)
(5, n, n)
H = 5
(1,1,1)
io
J
K
(7, K, J)
(7, n, n)
H = 7
(1,1,1)
io
Per riempire
(1, i, j)
J
H = 1
K
(1, i, k)
(1, K, J)
H
(1, n, n)
(| V |, n, n)
: Substanze
: la nostra istanza
Figura 19.4: la tabella di programmazione dinamica per l'analisi.La voce della tabella corrispondente a
l'istanza ⟨g, t1, ai ,..., un j ⟩is rappresentato dal piccolo cerchio.Usando la regola t1 ⇒t1t1, il
Substanze ⟨g, T1, ai ,..., ak⟩and ⟨g, t1, ak+1 ,..., A J⟩ è formato.Usando la regola T1 ⇒t5t7, le sottoinstanze ⟨g, T5, AI ,..., ak⟩and ⟨g, t7, ak+1 ,..., A J⟩ è formato.Le voci della tabella corrispondenti a queste sotterranee sono rappresentate dai punti all'interno degli ovali.
Esercizio 19.7.1 (vedi soluzione nella parte cinque.) (A) Fornire il codice per l'algoritmo di analisi.(b) Dai il tempo di esecuzione per questo algoritmo.
19.8
Progettazione di algoritmi di programmazione dinamica tramite riduzioni
A volte, quando si cerca di sviluppare un algoritmo per un nuovo problema, è più facile
Cerca le somiglianze tra il tuo nuovo problema e un problema che già
avere un algoritmo per.Con queste intuizioni puoi rendere simile il nuovo algoritmo
la vecchia.Se fatto formalmente, questo si chiama facendo una riduzione dall'unico problema
all'altro.Il capitolo 20 copre queste idee in modo approfondito.Qui cercheremo
somiglianze tra problemi in modo più informale.Inizieremo usando questa tecnica
allo sviluppo di un algoritmo di programmazione dinamica per una versione più dura dell'evento
Problema di pianificazione.

---
layout: 
title: Pagina 335
level: 3
---


Esempi di programmi dinamici
319
Problema di pianificazione degli eventi: il problema è programmare un tour che cerca di partecipare al
Il massimo valore di eventi possibili.A differenza della versione della Sezione 19.3, gli eventi
si verificano in luoghi diversi.Un'istanza è ⟨e, d⟩.Qui e = {e1, e2 ,..., En} è un set
di n eventi.Per j ∈ [n], l'evento E J è specificato da ⟨s J, FJ, WJ⟩, dove è il suo tempo di inizio, fj il suo tempo di finzione e il suo valore in dollari.Gli eventi si verificano in diverse posizioni.Per ogni coppia di eventi E J ed E J ′, DJ, J ′ è il tempo necessario per viaggiare tra le posizioni di questi eventi.Si noti che il secondo parametro D è un n-by-n
matrice.
Una soluzione è un programma di eventi a cui partecipare.Ciò include quali eventi partecipi e l'ordine a cui partecipi, (ad esempio, S = ⟨e5, E32, E16,., E21⟩. La restrizione è che per partecipare a un evento, devi raggiungere la posizione delevento prima
inizia e devi rimanere fino al completamento.Più formalmente, supponiamo che dopo aver partecipato
Evento E J, successivamente partecipare all'evento e J ′.Ora e j ﬁ nishes al tempo fj, ed e j ′ inizia al tempo
S J ′.Quindi, hai il tempo s j ′ −fj per percorrere la distanza DJ, j ′ tra di loro.Ciò richiede dj, j ′ ≤s j ′ −fj.(Nota che supponiamo che le distanze dj, j ′ incontrino il triangolo
disuguaglianza, in modo che se dall'evento e j puoi raggiungere e j ′ e dall'evento e j ′ puoi raggiungere
E j ′ ′, quindi per transitività dall'evento e j puoi raggiungere e j ′ ′.)
Il valore di una soluzione è il totale dei degni di WJ degli eventi assistiti.IL
L'obiettivo è massimizzare il valore del programma.
Programmazione dinamica: inizia tentando di progettare un algoritmo di programmazione dinamico per questo problema.Non essere sorpreso se lo trovi duro.Questo è il motivo per cui lo siamo
Confrontare questo problema con un problema precedentemente noto.
Somiglianza con il percorso migliore: la soluzione a questo problema è un programma di eventi, che
In effetti è un percorso attraverso un sottoinsieme degli eventi.Abbiamo esaminato molti algoritmi per trovare un percorso migliore all'interno dei grafici, quindi proviamo a modellare questo problema
Un grafico.
Riduzione: data un'istanza di ⟨e, d⟩ del problema di pianificazione, lo risolviamo come
segue.Lo mappiamo prima a un'istanza del problema grafico.Il nostro algoritmo grafico
trova il percorso migliore con in questo grafico. Quindi mappiamo questo miglior percorso a una soluzione del
Problema di pianificazione.
Formare un'istanza del grafico: ora consideriamo come formare un grafico che rappresenta un
Dato insieme di eventi.
Nodi: una soluzione al problema di pianificazione è un percorso di eventi e al grafico
Il problema è un percorso di nodi.Ciò indica un collegamento tra eventi e nodi.
Quindi, nel grafico, costruiamo un nodo per ogni evento EJ.

---
layout: 
title: Pagina 336
level: 3
---


Problemi di ottimizzazione
320
Bordi: nel problema grafico, indipendentemente dal fatto che esiste o meno un bordo tra due nodi
indica se il percorso può viaggiare o meno da un nodo all'altro.
Quindi, per ogni coppia di eventi ej ed ej ′, aggiungiamo il bordo diretto ⟨ej, ej ′ ⟩if ej
può procedere ej ′ nel programma.Più formalmente, ⟨ej, ej ′ è un bordo se e solo se
dj, j ′ ≤s j ′ −fj.Finora la corrispondenza tra questi problemi è buona, perché ogni percorso attraverso questo grafico corrisponde a un programma legale di eventi
e viceversa.
Nodi s e t: i problemi standard per la ricerca di percorsi in un grafico presumono questo
L'ingresso specifica il nodo iniziale S e un nodo di finitura T, mentre la pianificazione
L'algoritmo non specifica un primo o ultimo evento a cui partecipare.Il modo standard per ottenere
Intorno a questo problema è semplicemente aggiungere un evento di inizio ex extra e un evento finale ET.
Dare evento è il tempo di ﬁ nishing fs = −∞means che impongono il vincolo che
Il programma inizia con ES non influisce su quali orari sono legali, perché
Si può ottenere dagli eventi ES a qualsiasi altro evento.Dando evento es del valore ws = 0 significa
Ciò, incluso gli eventi S, non cambia il valore della soluzione finale.Allo stesso modo, let st = ∞ e wt = 0. Dal punto di vista del grafico, aggiungiamo due nuovi nodi S e
t e un bordo diretto da s a ogni altro nodo e da ogni nodo a t.
Costi e pesi: il valore o il costo di un percorso è diverso anche nei due problemi.Il valore di un programma è la somma dei valore degli eventi, che diventa la somma dei pesi dei nodi, mentre il valore o il costo di un percorso
Attraverso un grafico tende a essere definito come la somma dei pesi dei bordi.Questo
La differenza, tuttavia, non dovrebbe essere troppo significativa.Un'opzione è tornare al
Algoritmi del percorso grafico e provare a farli funzionare dove i nodi e non il
I bordi hanno pesi.Un'altra opzione è semplicemente spostare il peso di ogni evento
sui bordi in uscita.I bordi ⟨ei, ej⟩ e ⟨ei, t⟩will hanno il valore vi del
primo evento EI.I bordi, ej⟩will hanno il valore zero.
Minimizzare o massimizzare: un'altra differenza tra questi problemi è che il
Il problema di pianificazione è alla ricerca del programma di valore massimo, mentre il
Il problema grafico è alla ricerca del percorso del valore minimo.Si scopre che finisce
Il percorso massimo ponderato in un grafico diretto generale è un problema difficile.Questo
motiva a guardare altre strutture relative al grafico che conosciamo.
Il percorso ponderato più lungo all'interno di un grafico a livello diretto: ricorda la dinamica
Algoritmo di programmazione per trovare il percorso ponderato più breve all'interno di un diretto
Grafico di livello che viene fornito nelle sezioni 18.1 e 18.2.Qui i nodi possono essere livellati
in modo che tutti i bordi vadano avanti.A quanto pare che sono necessari cambiamenti minimi
questo algoritmo in modo che invece trovi il percorso ponderato più lungo all'interno di un diretto
Il grafico a livello, cioè risolve lo stesso problema ma trova un percorso da s a t
Peso più grande.Quando prendiamo il meglio del meglio, prendiamo semplicemente il massimo e non
il percorso min.Perché non ci sono cicli, non dobbiamo preoccuparci dei percorsi
quel ciclo per avere un peso più lungo.Quindi, la prova della correttezza va
Proprio come prima.

---
layout: 
title: Pagina 337
level: 3
---


Esempi di programmi dinamici
321
Livellato: per utilizzare questo algoritmo grafico livellato, dobbiamo assicurarci
Il grafico che deriva dal problema di pianificazione è in realtà livellato.Il livello di
Un nodo EJ può essere l'ora di inizio s j dell'evento corrispondente.Le regole per quando
I bordi vengono aggiunti, assicurati che ogni bordo sia diretto da un nodo a un nodo in a
livello inferiore.
Mappatura dell'algoritmo: data questa somiglianza tra questi due problemi, ricordiamo l'algoritmo di programmazione dinamica riportato nella sezione 18.2 per la ricerca
il percorso ponderato più corto all'interno di un grafico a livello diretto e lasciamolo per trovare un
Algoritmo di programmazione dinamica per il problema della pianificazione degli eventi.
Set di istanze: una parte fondamentale di un algoritmo di programmazione dinamica è l'insieme di
Substanze risolte.A partire dall'istanza ⟨g, s, t⟩ e alla ricerca del percorso più breve da s a t, l'algoritmo trova il percorso più breve da S a ciascun nodo VI, in modo che l'insieme completo di sottoinstanze risolto dalla programmazione dinamica
L'algoritmo sarà {⟨g, s, vi⟩ | vi}.Allo stesso modo, per il problema di pianificazione, dato il
istanza ⟨e, d⟩, l'insieme di sottoinstanze sarà {⟨e, d, i⟩ |ei}, dove l'istanza
⟨E, d, i⟩asks per il miglior programma di eventi s = ⟨e5, e32, e16 ,..., E21, Ei⟩ che finisce
In caso di EI.Si noti che potrebbero esserci eventi che si verificano dopo l'evento EI, ma il programma della soluzione non è autorizzato a frequentarli.
L'algoritmo Bird -Friend: dato un'istanza ⟨e, d, i⟩, sappiamo che il secondo
per l'ultimo evento prima che EI nella soluzione ottimale deve essere un evento EK per il quale Dk, i ≤
si −fk.Chiediamo all'uccello di dirci questo k.Facciamo risolvere l'amico l'istanza
⟨E, d, k⟩.La nostra soluzione è la stessa con EI aggiunta alla fine.Il valore del nostro
La soluzione è la stessa con VK aggiunta in.
Il codice: il codice finale per risolvere il problema della pianificazione degli eventi è quasi identico a quello per trovare il percorso ponderato più breve entro un livello diretto
grafico.
Scheda di algoritmo (e, d)
⟨Pre-Cond⟩: Un'istanza è costituita da un insieme di eventi e = {ej}, con ora di inizio
S J, Time di finitura FJ, Worth WJ e Distances DJ, J ′ tra loro.
⟨Post-Cond⟩: Optsol è un programma ottimale valido di eventi che termina con
evento en.
inizio
Aggiungi un evento iniziale immaginario s = e0 con s0 = f0 = −∞.
Aggiungi un evento di conclusione immaginaria s = en+1 con sn+1 = fn+1 = ∞.
Ordina gli eventi all'inizio dell'orario.
% Tabella: Optsol [i] memorizza un programma ottimale di eventi che terminano con EI
e costil [i] il suo costo.
Tabella [0..n + 1] OptCost, BirdAdvice

---
layout: 
title: Pagina 338
level: 3
---


Problemi di ottimizzazione
322
% Base di base: l'unico caso di base è per l'insieme ottimale che termina in E0.
La sua soluzione consiste nel set vuoto con il costo zero.
% Optsol [0] = ∅
optcost [0] = 0
BirdAdvice [0] = ∅
% CASI GENERALI: ciclo sopra le sottoinstanze nella tabella.
per i = 1 a n + 1
% Risolvere l'istanza ⟨e, d, i⟩ e ﬁ ll nella voce della tabella ⟨i⟩.
% Prova ogni possibile risposta per uccelli.
per ogni k per il quale dk, i ≤si −fk
% L'algoritmo Bird -Friend: l'ultimo evento deve essere EI.L'uccello
Ci dice che il secondo all'ultimo evento è EK.Chiediamo all'amico
Un set ottimale che termina in EK.Ci dà optsol [k], che ha
memorizzato nel tavolo.A questo aggiungiamo EI.Questo ci dà optsolk che
è una soluzione migliore che termina in EI tra questi percorsi coerenti con la risposta dell'uccello.
% Optsolk = Optsol [K] + EI
optcostk = optcost [k] + vi
fine per
% Che ha il meglio, optsolk, per la risposta di ogni uccello k, manteniamo il
Il meglio di questi.
kmin = a k che massimizza optcostk
% optsol [i] = optsolkmax
optcost [i] = optcostkmax
BirdAdvice [i] = kmax
fine per
Optsol = SchedulingWithaDvice (⟨e, D⟩, BirdAdvice)
return ⟨optSol, optcost [n + 1]⟩
Algoritmo di fine
Tempo di esecuzione: il numero di sottoinstanze è N + 1 e il numero di risposte agli uccelli è al massimo N + 1. Pertanto, il tempo di esecuzione è O (N2).
Problema di elefante più grande-più intelligente: ora considereremo un altro problema.
Istanze: un insieme di elefanti e = {e1, e2, ..., en}, dove ei = ⟨wi, si, vi⟩represents
L'elefante, con il suo peso, si la sua intelligenza e vi il suo valore.(Per fare la vita
più facile, supponiamo che i pesi e le intelligenze siano valori unici, cioè Wi ̸ = WJ
e si ̸ = s j.)
Soluzioni: un sottoinsieme di elefanti è per i quali è più intelligente.
Formalmente, ∀i, j ∈s, [[wi <wj] iff [si <s j]].Un modo equivalente di guardarlo
è che se dovessi ordinare gli elefanti in S in aumento del loro peso,

---
layout: 
title: Pagina 339
level: 3
---


Esempi di programmi dinamici
323
Quindi questo stesso ordine li ordinerebbe rispetto all'intelligenza.(Suggerimento: lo è
utile supporre che gli elefanti nella soluzione siano ordinati in questo modo.)
Misura del successo: il costo della soluzione è la somma dei valori degli elefanti,
i∈S vi.
Obiettivo: dovremmo trovare una soluzione massima.
Esercizio 19.8.1 Progettare un algoritmo di programmazione dinamico per il più grande-intelligente
problema di elefante confrontandolo, come fatto in precedenza, con il problema di trovare il
Percorso ponderato più lungo all'interno di un problema grafico a livello diretto.
Esercizio 19.8.2 (vedi soluzione nella quinta parte.) Progettare un algoritmo di programmazione dinamica per il problema degli elefanti più grandi-più intelligenti confrontandolo con il problema più lungo di sub-sub-sub-subessenza indicato nella sezione 19.1.Per fare ciò il problema del problema LCS ha bisogno
essere generalizzato per avere pesi sulle lettere.

---
layout: 
title: Pagina 340
level: 3
---


324
20 riduzioni e completezza NP
Una giraffa con il suo collo lungo è una bestia molto diversa rispetto a un topo, che è diversa da un serpente.Tuttavia, Darwin e Gang hanno osservato che i primi due ne hanno alcuni
Somiglianze chiave, entrambe sono sociali, allattando i loro giovani e avendo i capelli.Il terzo
è completamente diverso in questi modi.Studiare somiglianze e differenze tra
le cose possono rivelare una sottile e profonda comprensione della loro natura sottolinea
Non sarebbe stato notato studiandoli uno alla volta.A volte cose
che prima sembra essere completamente diverso, se visualizzato in un altro modo,
essere lo stesso tranne per le differenze cosmetiche super ﬁ ciche.Questa sezione insegnerà
Come utilizzare le riduzioni per scoprire queste somiglianze tra la diversa ottimizzazione
i problemi.
Riduzione p
1 ≤Poly p
2: Diciamo che possiamo ridurre il problema P1 al problema P2 se noi
può scrivere un algoritmo a tempo polinomiale (n (1)) per P1 usando un presunto algoritmo per
P2 come subroutine.(Nota che potremmo o meno avere effettivamente un algoritmo per P2.) Il
La notazione standard per questo è P1 ≤Poly P2.
Perché ridurre?Una riduzione ci consente di confrontare le complessità temporali e sottostanti
strutture dei due problemi.La riduzione è utile per fornire algoritmi per nuovi
Problemi (limiti superiori), per fornire prove che non esistono algoritmi veloci per
Alcuni problemi (limiti inferiori) e per classificare i problemi in base alla loro difficoltà.
Limiti superiori: dalla riduzione P1 ≤Poly P2 da solo, non possiamo concluderlo
C'è un algoritmo a tempo polinomiale per P1.Ma ci dice che se c'è un
Algoritmo a tempo polinomiale per P2, quindi ce n'è uno per P1.Questo è utile in due modi.
Innanzitutto, ci consente di costruire algoritmi per nuovi problemi da algoritmi noti
per altri problemi.Inoltre, ci dice che P1 è almeno facile come P2.
Hot Dog ≤Poly Programmazione lineare: la sezione 15.4 descrive come risolvere il
Problema di preparare un hot dog economico usando un algoritmo per la programmazione lineare.

---
layout: 
title: Pagina 341
level: 3
---


Riduzioni e completezza NP
325
Flussi di rete bipartiti ≤Poly: svilupperemo un algoritmo per la corrispondenza bipartita nella sezione 20.4 che utilizza l'algoritmo di flusso di rete.
Limiti inferiori: il contrapposto dell'ultima affermazione è che se non esiste un
Algoritmo a tempo polinomiale per P1, quindi non può essercene uno per P2 (altrimenti lì
sarebbe uno per P1.) Questo ci dice che P2 è almeno difficile come P1.
(Qualsiasi problema di ottimizzazione) ≤poy CIR-SAT: questa dichiarazione di piccolo aspetto, dimostrata da Steve Cook nel 1971, è diventata una delle basi dell'informatica teorica.Ci sono molti interessanti problemi di ottimizzazione.Alcuni
Le persone hanno lavorato duramente per scoprire algoritmi veloci per questo e altri
ho fatto lo stesso per quello.Il teorema di Cook mostra che è sufficiente
ContraTuttavia, dopo molti anni di lavoro sodo, le persone hanno rinunciato e sospettano fortemente che almeno un problema di ottimizzazione sia difficile.Ciò fornisce evidenti prove del fatto che CIR-SAT è difficile.Il teorema di Cook è
dimostrato (e i problemi definiti) nella sezione 20.1.
CIR-SAT ≤Poly 3-COL: vedere la sezione 20.3.Ciò afferma che il problema di ottimizzazione 3-col è difficile quanto CIR-SAT, già noto per essere un problema difficile.Questo da
Prova che anche il 3-col è difficile.Inoltre, le riduzioni sono transitive, significato
Quel P1 ≤Poly P2 e P2 ≤Poly P3 dà automaticamente quel P1 ≤Poly P3.Quindi, insieme queste ultime due affermazioni danno questo (qualsiasi problema di ottimizzazione) ≤poy 3col.
Pianificazione del corso 3-cal ≤Poly, set indipendente 3-COL ≤Poly, 3-COL ≤Poly
3-Sat: questi forniscono prove che la programmazione del corso, il set indipendente e il 3-Sat
sono duri.Vedi sezioni 20.2 e 20.3.
(Problema di arresto) ≤Poly (cosa fa questa macchina Turing): può essere dimostrato
che il problema di arresto (dato una macchina Turing M e un input i, lo fa
la m halt on i?) è indecidenziale (nessun algoritmo può sempre rispondere correttamente
tempo in fini).Detto questo, le riduzioni possono essere usate per dimostrare che quasi tutti
Problema chiedendo cosa fa anche il calcolo di una data macchina Turing
indecidibile.
Riduzioni inverse: sapere
P1 ≤poly p2 e sapendo che non esiste un
L'algoritmo a tempo polinomiale per P2 non ci dice nulla sul fatto che ci sia
è un algoritmo a tempo polinomiale per P1.Anche se ci dice che l'algoritmo per
P1 fornito nella riduzione non funziona, potrebbe esserci un altro algoritmo completamente diverso per P1.Allo stesso modo, sapendo che esiste un algoritmo a tempo polinomiale
Per P1 non ci dice nulla sul fatto che ce n'è uno per P2.Per raggiungere questi due
Conclusioni, è necessario dimostrare la riduzione inversa P2 ≤Poly P1.

---
layout: 
title: Pagina 342
level: 3
---


Problemi di ottimizzazione
326
Classificazione dei problemi: le riduzioni vengono utilizzate per classificare i problemi.
Lo stesso problema tranne per le differenze super ﬁ ciche: più che essere in grado
Per confrontare le loro complessità temporali, la conoscenza di p1 ≤poly p2 e p2 ≤poy p1 rivela
che i due problemi sono in qualche modo fondamentalmente lo stesso problema, chiedendo il
Stessi tipi di domande.A volte questa somiglianza è piuttosto super ﬁ ciale.Usano semplicemente il vocabolario diverso.Tuttavia, altre volte questa connessione tra
i problemi sono piuttosto sorprendenti, fornendo una comprensione più profonda di ciascuno di
I problemi.Un modo in cui possiamo fare una riduzione ancora più sorprendente è
limitando l'algoritmo per l'uno per chiamare l'algoritmo solo per l'altro
una volta.Quindi la mappatura tra loro è ancora più diretta.
Competenze NP: abbiamo dimostrato che i problemi di ottimizzazione CIR-SAT, 3COL, pianificazione del corso, set indipendente e 3-Sat sono tutti riducibili a ciascuno
Altro e in questo senso sono tutti fondamentalmente lo stesso problema.In effetti, ci sono
Migliaia di problemi molto diversi che sono equivalenti a questi.Si dice che questi problemi siano completi NP.Ne discutiamo di più nella sezione 20.2.
Completezza del problema di fermo: un'altra classe importante definita in questo modo
è costituito da tutti i problemi equivalenti al problema di arresto.
20.1
La ﬁ capacità di Satis è almeno difficile quanto qualsiasi problema di ottimizzazione
Nel capitolo 13 abbiamo visto che i problemi di ottimizzazione comportano la ricerca attraverso l'insieme esponenziale di soluzioni per un'istanza per trovare una con un costo ottimale.Anche se lì
sono algoritmi veloci (cioè polinomiale) per alcuni di questi problemi, per la maggior parte di essi
Gli algoritmi più noti richiedono 2 (n) volte sulle istanze di input del caso peggiore e
Si ritiene fortemente che non ci siano algoritmi a tempo polinomiale per loro.IL
Il motivo principale di questa convinzione è che molte persone intelligenti hanno dedicato molti anni
Ricerca per cercare algoritmi veloci e non li ha trovati.Questa sezione utilizza
Riduzioni per dimostrare che alcuni di questi problemi di ottimizzazione sono universalmente difficili o completi, tra la classe di problemi di ottimizzazione, perché se si potesse progettare
Un algoritmo per risolvere rapidamente un tale problema, quindi potresti tradurre questo algoritmo
in uno che risolve rapidamente qualsiasi problema di ottimizzazione.Al contrario (e più probabile), se esiste anche un problema di ottimizzazione che non può essere risolto rapidamente, nessuno di nessuno
Questi problemi completi possono essere neanche.Dimostrando in questo modo un problema che il tuo
Boss vuole che tu risolva è difficile, perché saprai di non spendere molto
tempo che cerca di progettare un algoritmo per tutti gli usi per questo.
(Qualsiasi problema di ottimizzazione) ≤poy CIR-SAT: questa riduzione dimostrerà che il problema di ﬁ capacità di SATIS è completo per la classe di problemi di ottimizzazione, il che significa che lo è
universalmente difficile per questa classe.

---
layout: 
title: Pagina 343
level: 3
---


Riduzioni e completezza NP
327
Il problema del circuito SATIS di capacità: questo famoso problema computazionale, Cirsat, richiede di trovare un incarico soddisfacente per un determinato circuito.La sezione 17.4 dà
Un algoritmo di backtracking ricorsivo per il problema di ﬁ abilità di Satis, ma nel peggiore dei casi
Il suo tempo di esecuzione è 2 (n).
Circuito: un circuito può essere una notazione utile per descrivere un algoritmo in
dettaglio o una cosa pratica costruita nel silicio nel tuo computer.
Costruzione: è costruito con e, o, e non cancelli.
Nella parte superiore sono etichettate N etichettate con le variabili binarie
x1, x2 ,..., xn.Per specificare l'ingresso del circuito, ognuno di questi
assumerà 1 o 0, vero o falso, 5 volt o 0 volt.
Ciascuno e Gate ha due fili che ci entrano
Un input xi o dall'output di un altro gate.An e
Gate emette vere se entrambi i suoi input sono veri.Allo stesso modo, ciascuno o gate emette vero se almeno uno dei suoi input lo è
vero, e ogni non gate emette vero se il suo singolo input lo è
O
E
E
NON
y
NON
X
X
Un circuito per x y
y
⊕
falso.Considereremo solo circuiti che non hanno cicli, quindi questi e veri e
I valori falsi percolate ai fili di output.Ci sarà un singolo output
filo se il circuito calcola una funzione vera -falsa del suo ingresso x1, x2 ,..., xn
e avrà cavi di uscita M se supera una stringa a m-bit, che può essere utilizzata
per codificare alcune informazioni richieste.
Endoding binario: la funzione F che si desidera calcolare può prendere come input un oggetto astratto come un grafico G e restituire un altro oggetto astratto, come un percorso attraverso questo grafico;Tuttavia, se il calcolo di F è fatto
da un programma Java, una macchina Turing o un circuito, questi oggetti astratti prima
È necessario essere codificati in stringhe di zeri e quelli.
Calcola qualsiasi funzione: data qualsiasi funzione f: {0, 1} n → {0, 1} m, un circuito
può calcolarlo con un massimo di O (nm · 2n) come segue.Per qualsiasi fisso
Ingresso istanza ⟨x1, x2 ,..., xn⟩ = ⟨1, 0 ,..., 1⟩, un circuito può dire “L'ingresso
è questa istanza fissa "semplicemente calcolando [(x1 = 1) e non (x2 = 1)
E ...E (xn = 1)].Quindi il circuito calcola il bit della funzione
Output emettendo 1 se ["L'ingresso è questa istanza fissa" o "questa istanza"
O ...O "questa istanza"], in cui ogni istanza è elencata per il quale il bit
dell'output della funzione è 1.
Dimensione polinomiale per il tempo polinomiale: soprattutto, dato qualsiasi algoritmo il cui tempo di esecuzione della macchina Turing è t (n) e dato qualsiasi intero fisso N, c'è un circuito facilmente costruito con al massimo (t) 2)
calcola l'output dell'algoritmo dato l'istanza di input in ogni bit.Modifica
La definizione di una macchina Turing leggermente in modo che ogni cella sia abbastanza grande
che la cella attualmente indicata dalla testa può immagazzinare non solo
contenuto ma anche lo stato attuale della macchina.Il contenuto di questa cellula può

---
layout: 
title: Pagina 344
level: 3
---


Problemi di ottimizzazione
328
essere codificato con (1) bit.Poiché la macchina Turing utilizza solo il tempo t (n), può usare al massimo le prime celle T (N) della memoria.Per ciascuno dei passaggi T (N)
dell'algoritmo, il circuito avrà una riga di fili (1) · t (n) i cui valori
codificare il contenuto della memoria di queste celle t (n) durante questo passaggio.IL
le porte del circuito tra queste file di fili calcolano il contenuto successivo
di memoria dal contenuto corrente.Perché il contenuto di Celi al Timet
dipendono solo dal contenuto delle cellule I −1, i e i + 1 al momento t −1 e ciascuno
Di questi è solo un numero (1) di bit, questa dipendenza può calcolare usando un circuito con (1) porte.Questo viene ripetuto in una matrice di fasi di tempo T (n)
e cellule t (n), per un totale di (t (n) 2) porte.Nella parte inferiore, il circuito calcola l'output della funzione dal contenuto della memoria del Turing
macchina al momento t (n).
Circuito Specificazione di ﬁ cata di capacità: il problema CIR-Sat richiede come input a
Circuito con un singolo output True -False e restituisce un incarico alle variabili x1, x2 ,..., xn per il quale il circuito dà vero, se tale incarico
esiste.
Problemi di ottimizzazione: questa riduzione selezionerà un problema di ottimizzazione generico
e mostra che CIR-Sat è almeno così difficile.Per fare questo, dobbiamo avere un chiaro
Definizione di come appare un problema di ottimizzazione generico.
Definizione: ciascuno di questi problemi ha una serie di istanze che potrebbero essere fornite come input;Ogni istanza ha una serie di potenziali soluzioni, alcune delle quali sono valide;E
Ogni soluzione ha un costo.L'obiettivo, dato un'istanza, è quello di trovare uno dei suoi validi
soluzioni con costo ottimale.Una caratteristica importante di un problema di ottimizzazione è
Che ci siano algoritmi a tempo polinomiale per quanto segue:
Valido (i, s): data un'istanza i e una potenziale soluzione s, c'è un algoritmo valido (i, s) in esecuzione nel tempo | i | o (1) che determina se sono un'istanza valida
Per il problema di ottimizzazione e quella S è una soluzione valida per I.
Costo / i: data una soluzione valida s, c'è un costo / i algoritmo in esecuzione
tempo | i | o (1) che calcola il costo della soluzione S.
Esempio: programmazione dei corsi: dato il set di corsi richiesti da ogni studente
e il set di fasce orarie disponibili, trovano un programma che riduce al minimo il numero di
Conflitti.
I: Il set di corsi richiesti da ogni studente e il set di fasce orarie
disponibile
S: un programma specifico in che modo inizierà a ciascun corso verrà insegnato.
Valido (i, s): un algoritmo che restituisce se la pianificazione s alloca ciascuno
Corso richiesto in I esattamente uno slot orario fornito in I.

---
layout: 
title: Pagina 345
level: 3
---


Riduzioni e completezza NP
329
Costo (s): un conflitto si verifica nel programma quando due corsi richiesti dal
Lo stesso studente è programmato allo stesso tempo.Il costo (s) è un algoritmo che
Restituisce il numero di conflitti nel programma S.
ALG per il problema di ottimizzazione: dato un algcir-sat algoritmo veloce per CIR-SAT
e le descrizioni valide (i, s) e costi di un problema di ottimizzazione p lo faremo
Ora progetta un algoritmo veloce algoritmo per il problema di ottimizzazione e usalo per dimostrare
che il problema cir-sat è almeno difficile quanto il problema di ottimizzazione, cioè quello
P ≤Poly Cir-Sat.
Ricerca binaria del costo: dato un po 'di istanza del problema di ottimizzazione, l'attività di ALGP è determinare il copt dei costi della soluzione ottimale per I. ALGP
inizia determinando se esiste o meno una soluzione valida per i che ha un costo
Almeno C = 1. Se lo fa, ALGP lo ripete con C = 2, 4, 8, 16 ,....In caso contrario, ALGP prova c = 0, −1, −2, −4 ,..., fino a quando non trova C1 e C2 tra i quali lo sa
Il costo di una soluzione ottimale sta.Quindi fa una ricerca binaria per trovare Copt.IL
L'ultimo passo è trovare una soluzione per i che ha questo costo ottimale.
Trovare una soluzione con dato costo: ALGP determina se ho una soluzione s
Con il costo almeno C o trova una soluzione con COPT COPT, come segue.ALGP costruirà un circuito C e chiama l'algoritmo algcir-sat, che fornisce un soddisfacente
L'assegnazione a C. ALGP vuole l'assegnazione soddisfacente che ALGCIR-SAT fornisce
Essere la soluzione di cui ha bisogno.Quindi, ALGP disegna c da soddisfare dal
Assegnazione S solo se s è una soluzione S per i con un costo come richiesto, cioè c (s) ≡
[Valido (i, s) e costo (s) ≥C].Perché ci sono algoritmi a tempo polinomiale per
Valido (i, s), per i costi e per ≥, l'algoritmo algp può facilmente costruire tale
Circuito C (s).Se esiste una tale soluzione che soddisfa C, allora ALGCIR-SAT fornisce gentilmente
uno.
Questo completa la riduzione P ≤Poly Cir-Sat di qualsiasi problema di ottimizzazione a Cirsat.
Esercizio 20.1.1
Per ciascuno dei seguenti problemi, definito i, s, valido (i, s) e
Costi).
1.
Colorazione del grafico: dato un grafico, colorare i suoi nodi in modo che due nodi non abbiano il
stesso colore se hanno un bordo tra loro.Usa il minor numero possibile di colori.
2.
Set indipendente: dato un grafico, trova un sottoinsieme più grande dei nodi per i quali lì
non sono bordi tra nessuna coppia nel set.
3.
Aereo: dati i requisiti di un aereo, progettarlo, ottimizzando le sue prestazioni.
4.
Affari: data una descrizione di un'azienda, crea un piano aziendale per massimizzare il proprio
profitti.
5.
Factoring: dato un numero intero, fattore, ad esempio 6 = 2 × 3.
6.
Cryptografia: dato un messaggio crittografato, decodifica.

---
layout: 
title: Pagina 346
level: 3
---


Problemi di ottimizzazione
330
20.2
Passaggi per dimostrare la completezza NP
In questa sezione definiamo la classe NP e forniamo misure per dimostrare che una computazionale
Il problema è NP-completo.
Completezza per problemi di decisione polinomiale non determinante:
L'insieme di problemi computazionali che sono completi (universalmente difficili) per i problemi di ottimizzazione è estremamente ricco e vario.Studiarli è diventato un
Affascinante campo di ricerca.
Problemi di decisione NP: gli informatici teorici generalmente considerano solo
Una sottoclasse dei problemi di ottimizzazione, indicata come la classe di problemi di tempo polinomiale non deterministico (NP).
Un livello di costo: invece di preoccuparsi se una soluzione abbia un costo migliore di un'altra, abbandoneremo completamente la nozione del costo di una soluzione.S sarà considerato una soluzione valida solo per l'istanza I se
È una soluzione con un costo sufficientemente buono.Questa non è una grande restrizione, perché se vuoi considerare soluzioni con costi diversi, puoi sempre
Fai la ricerca binaria, come già fatto per il costo della soluzione ottimale.
Problema decisionale: data un'istanza al problema, l'obiettivo è determinare sì, ho una soluzione valida o no no.
Testimone: una soluzione per un'istanza viene spesso definita testimone, perché, sebbene possa richiedere tempo esponenziale per trovarlo, se fosse fornita da una madrina (non deterministica) fata, allora potrebbe essere usato in tempo polinomiale per
Testimone del fatto che la risposta per questo istanza è sì.A questo proposito, NP
i problemi sono asimmetrici in quanto non sembra esserci un testimone
dimostra rapidamente che un'istanza non ha una soluzione.
Definizione formale: diciamo che un tale problema computazionale p è in
Classe di problemi non deterministici del tempo polinomiale (NP) se esiste un
Algoritmo a tempo polinomiale valido (i, s) che specifica sì quando s è una soluzione (sufficientemente buona) per l'istanza I e no in caso contrario.Più formalmente, P può
essere definito come segue:
P (i) ≡ [∃s, valido (i, s)]
Esempi:
Circuito SATIS Abilità (CIR-SAT): il circuito che si può definire l'abilità
Un problema di decisione: dato un circuito, determinare se esiste un incarico che lo soddisfa.
Grafico 3-coloranti (3-COL): dato un grafico, determina se i suoi nodi
può essere colorato con tre colori in modo che due nodi non abbiano lo stesso
colore se hanno un bordo tra loro.

---
layout: 
title: Pagina 347
level: 3
---


Riduzioni e completezza NP
331
Pianificazione del corso: dato il set di corsi richiesti da ogni studente, il set di fasce orarie disponibili e un numero intero K, determina se esiste
è programmato con il maggior numero di conflitti K.
Riduzioni Cook vs. Karp: Stephen Cook prima ha dimostrato che CIR-SAT è completo
Per la classe di problemi NP.La sua definizione di una riduzione p1 ≤poly p2 è quella
può scrivere un algoritmo Alg1 per il problema P1 usando un algoritmo Alg2 per
Problema P2 come subroutine.In generale, questo algoritmo Alg1 può chiamare Alg2 come molti
volte come piace e fare qualsiasi cosa gli piace con le risposte che riceve.Richard
Karp in seguito ha osservato che quando i problemi P1 e P2 sono sufficientemente simili, il
L'algoritmo Alg1 utilizzato nella riduzione deve solo chiamare Alg1 una volta e risponde sì se se
E solo se Alg1 risponde sì.Queste due definizioni di riduzioni sono citate
come riduzioni di cuoco e karp.Anche se abbiamo definito riduzioni di cucina perché
Sono più naturali, considereremo solo le riduzioni di Karp da qui in poi.
Competenze NP: affinché il problema p sia completo NP, deve essere difficile, ma non troppo difficile.Diciamo che un problema computazionale p è NP-completo se
Sufficientemente duro, p ′ ≤poly p: diciamo che un problema p è np-hard se è come come
duro come ogni altro problema p ′ nella classe NP.Intuitivamente, questo significa
che se si trovasse un algoritmo rapido per p, questo algoritmo potrebbe essere
Tradotto in algoritmi rapidi per ogni problema NP P ′.Più formalmente, significa che ogni lingua in NP può essere ridotta polinomia
usando una riduzione del karp.
Problemi di ottimizzazione P ′, P ′ ≤Poly P.
Per dimostrarlo, è sufficiente dimostrare che il nostro problema computazionale
è almeno difficile quanto qualche problema già noto per essere NP-completo.
Ad esempio, perché ora sappiamo che CIR-SAT è NP-completo, lo è
sufficiente per dimostrare che cir-sat ≤poy P.
Non troppo difficile, p ∈NP: d'altra parte, affinché il problema p sia completo per la classe NP
, deve essere sufficientemente facile che sia esso stesso
classe.Ad esempio, il problema di arresto è sufficientemente difficile da essere nphard, ma è molto difficile essere in NP
.
I passaggi per dimostrare la completezza NP: dimostrare che un problema P è NP-completo
Può essere un po 'un'arte, ma una volta che hai capito, può essere divertente.Ora esponderò attentamente i passaggi necessari.(Dopo il passaggio 3, useremo Poracle per indicare il problema anziché P, perché a quel punto assumeremo che abbiamo un oracolo
per questo.)
Esempio di esecuzione: la pianificazione del corso è NP-completa: il problema p che noi
Dimostrerà che NP-completo sarà il problema di pianificazione del corso.

---
layout: 
title: Pagina 348
level: 3
---


Problemi di ottimizzazione
332
(0) p ∈NP: come detto, affinché il problema p sia composto da np, deve essere
sufficientemente facile essere in NP
.Per dimostrarlo, dobbiamo effettivamente fornire un tempo polinomiale non determinante.Ciò si ottiene fornendo
Algoritmo a tempo polinomiale valido (i, h) che specifica se s è una soluzione valida per
istanza I.
Pianificazione del corso: non è difficile determinare in tempo polinomiale se il
istanza I e la soluzione s sono correttamente definite e verificarla all'interno di questo
programma s, il numero di volte in cui uno studente vuole seguire due corsi che sono
Offerto allo stesso tempo è al massimo K.
1) Cosa ridurlo: un passo importante e impegnativo nel dimostrare che un problema è NP-completo sta decidendo quale problema NP-completa ridurlo.Noi
indicherò questo problema con Palg perché più tardi progetteremo un algoritmo
per questo.
Pianificazione del corso 3-COL ≤Poly: ridurremo 3-COL alla pianificazione dei corsi, cioè dimostreremo la riduzione della pianificazione del corso 3-COL ≤Poly.Salverò il
Prova che 3-COL è NP-completo per il nostro prossimo esempio, perché è molto più difficile.
Suggerimento: vuoi scegliere un problema "simile" in natura per il tuo.Al fine
Per avere di più tra cui scegliere, aiuta a conoscere una vasta raccolta di problemi che
sono NP-completi.Ci sono interi libri dedicati a questo.In caso di dubbio, 3-sa-sat
E 3-Col sono buoni problemi da usare.
2) Cos'è cosa: è importante ricordare cos'è tutto.
Pianificazione del corso 3-COL ≤Poly:
r Palg = 3Col è il problema a 3 colori grafici.
r ialg = igraph, un'istanza di esso, è un grafico non orientato.
r salg = scoloring, una potenziale soluzione, è una colorazione di ciascuno dei suoi nodi con
o rosso, blu o verde.È una soluzione valida se nessun bordo ha due nodi con
lo stesso colore.
r Algalg è un algoritmo che prende il grafico come input e determina
se ha una colorazione valida.
R Poracle = Pianificazione del corso.
r ioracle = icone, un'istanza, è il set di corsi richiesti da ogni studente, il set di fasce orarie disponibili e l'intero K.
r Soracle = sschedule, una potenziale soluzione, è un programma che assegna i corsi al tempo
slot.È una soluzione valida se ha al massimo i conflitti K.
R Algoracle è un algoritmo che prende icourses come input e determina se
ha un programma valido.
Tali istanze possono o meno essere soddisfatti e tali potenziali soluzioni possono
o potrebbe non essere valido.

---
layout: 
title: Pagina 349
level: 3
---


Riduzioni e completezza NP
333
ATTENZIONE: sii particolarmente attento a ciò che è un'istanza e di ciò che è una soluzione
Per ciascuno dei due problemi.
3) Direzione di riduzione e codice: un'altra fonte comune di errori sta facendo
la riduzione nella direzione sbagliata.Consiglio di non memorizzare questa direzione, ma di allenarla ogni volta.Il nostro obiettivo è dimostrare che il problema è sufficiente
Difficile essere NP-integrato.Quindi, è necessario mettere P sul lato duro della disuguaglianza 3-COL ≤Poly P con il problema, diciamo 3-Col, scelto al passaggio 1 sul lato facile.
A questo punto, gira il tuo pensiero.Invece di dimostrare che P è relativamente difficile, noi
Dimostrerà che il problema 3-col è relativamente facile.Per fare questo, dobbiamo progettare
Un algoritmo veloce per questo.Perché questo è un obiettivo da qui in poi, ci denunciare
Il problema 3-Col con Palg.La nostra convinzione è che non esiste un algoritmo veloce per questo
problema.Quindi, per aiutarci, useremo un presunto algoracolo di algoritmo veloce per P come P come P come P.
sottoprogramma.In genere per riduzioni le persone presumono che Algoracle sia un oracolo che significa che risolve il suo problema in un passo temporale.Quindi, da qui in poi useremo Poracle
indicare il problema invece di P. il codice per il nostro algoritmo per Palg sarà come
segue.
Algoritmo Algalg (IALG)
⟨Pre-Cond⟩: ialg è un'istanza di Palg.
⟨Post-Cond⟩: determinare se ialg ha una soluzione salg e, in tal caso, restituirlo.
inizio
Ioracle = InstanceMap (IALG)
% Ioracle è un'istanza di Poracle
⟨Sansoracle, Soracle⟩ = Algoracle (Ioracle)
% Se ce n'è uno, Soracle è una soluzione per ioracolo
if (ansoracle = sì) allora
Ansalg = Sì
Salg = SolutionMap (Soracle)
altro
Ansalg = no
Salg = zero
finisci se
restituzione (⟨ansalg, salg⟩)
Algoritmo di fine
4) Cerca somiglianze: sebbene i problemi Palg e Poracle possano sembrare molto
diverso, l'obiettivo in questo passaggio è cercare somiglianze sottostanti.Confronta come il loro
Le soluzioni, Salg e Soracle, sono formate dai loro casi, IALG e Ioracle.Generalmente, le istanze possono essere pensate come serie di elementi con una serie di vincoli tra
loro.Puoi considerare le loro soluzioni come sottoinsiemi di questi elementi o come etichette di
loro?Cosa permette a formare una soluzione e cosa si forma come si forma?Potere

---
layout: 
title: Pagina 350
level: 3
---


Problemi di ottimizzazione
334
Parli dei due problemi usando la stessa lingua?Ad esempio, un sottoinsieme di
Gli elementi possono essere visti come un'etichettatura degli elementi con zero e uno.Allo stesso modo, un'etichettatura di ciascun elemento E con ℓe ∈ [1..l] può essere vista come un sottoinsieme delle coppie
⟨E, ℓe⟩.
Pianificazione del corso 3-COL ≤Poly: una soluzione
Scoloring è una colorazione che assegna un colore a
ogni nodo.Una soluzione Sschedule è un programma che assegna una fascia oraria a ciascun corso.
Questa somiglianza chiarisce che lì
è una somiglianza tra i ruoli del
nodi di igrafe e dei corsi di icourses
e tra i colori dello scolaring e il
Time Flot of Sschedule.Ogni conflitto da colorare
sorge da un bordo tra nodi e
Più facile
IO
Iharder
Matematica
Inglese
Scienza
Più facile
S
È più difficile
Lunedì14:00
Lunedì14:00
blu
blu
verde
Mar.15:00
Ogni conflitto di programmazione deriva da uno studente che desidera due corsi.Questa somiglianza chiarisce che esiste una somiglianza tra i ruoli dei bordi della igrafia
e delle richieste di corsi di icourses.
5) InstanceMap: devi definire un algoritmo a tempo polinomiale InstanceMap (IALG)
Ciò, dato un'istanza ialg di Palg, costruisce un istanza di PORACLE che ha
Tipi simili di soluzioni.Il problema principale è che l'istanza costruita Ioracle ha a
soluzione se e solo se l'istanza data ialg ha una soluzione, cioè istanze sì, ottieni
mappato a sì, istanze e no a No.
Pianificazione dei corsi 3-cal ≤Poly: dato un grafico da colorare, progettiamo un
istanza iourses = instancemap (igraph) da programmare.Usando le somiglianze
osservato nel passaggio 4, la nostra mappatura avremo un corso per ogni nodo del
Grafico e uno slot temporale per ciascuno dei tre colori verde, rosso e blu.Per ciascuno
bordo tra i nodi U e V nel grafico, avremo uno studente che richiede
Sia il corso u che il corso v. Il problema da colorare non consente alcun conflitto.
Quindi, abbiamo impostato k = 0.
Non su o 1-1: è importante che ogni istanza sia mappato su un po 'di istanza, ma non è importante se un oracle è mappato
più di uno o nessuno.Nel nostro esempio, non menzioniamo mai le istanze
programmati che hanno più di tre fasce orarie o che consentono i conflitti K> 0.
ATTENZIONE: assicurarsi di fare questa mappatura nella direzione corretta.Il primo passo
Progettare un algoritmo Algalg è supporre che ti sia stato dato un input
Ialg per questo.Prima che il tuo algoritmo possa chiamare l'algoracolo dell'algoritmo come una subroutine, devi costruire un Ioracolo di istanza per dargli.
ATTENZIONE: non definire la mappatura solo per le istanze Sì o utilizzare una soluzione
Salg per ialg per determinare l'istanza a cui Ioracle ha mappato.L'algoritmo Algalg
che stai progettando è dato un istanza ialg, ma non sa se

---
layout: 
title: Pagina 351
level: 3
---


Riduzioni e completezza NP
335
o no l'istanza ha una soluzione.Il punto è dare una discussione che
La ricerca di una soluzione può richiedere tempo esponenziale.È più sicuro, quando si definisce la mappatura di instancemap (IALG), non per menzionare nemmeno se l'istanza ialg ha una soluzione o ciò che potrebbe essere quella soluzione.
6) Solutionmap: è anche necessario definire un algoritmo polinomiale Solutionmap
(Soracle) Mappatura di ciascuna soluzione valida Soracle per l'istanza Ioracle = InstanceMap (IALG)
Hai appena costruito una soluzione valida Salg per l'istanza che è stata data come input.Le soluzioni valide possono essere sottili e l'istanza Ioracle può avere alcune soluzioni
che non avevi intenzione quando lo hai costruito.Un modo per aiutare a evitare di perdere
Alcuni devono lanciare una rete molto più ampia considerando tutte le potenziali soluzioni.In questo passaggio, per ogni potenziale soluzione di soracle per Ioracle, devi dare un motivo per cui non lo è
una soluzione valida o mapparla a una soluzione salg = soluzione (SORAcle) per ialg.È finito se
Alcune delle soluzioni che map non sono valide.
Pianificazione del corso 3-cal ≤Poly: dato un programma sschedule che assegna il corso U a
Time Flots C, Definiamo scoloring = SolutionMap (sschedule) per essere la colorazione che
colori nodo u con colore c.
ATTENZIONE: quando l'istanza Ioracle che hai costruito ha soluzioni che hai fatto
Non aspettarti, ci sono due problemi.Innanzitutto, l'algoracolo dell'algoritmo sconosciuto May
Dai una di queste soluzioni inaspettate.Secondo, c'è il pericolo che iooracolo
ha soluzioni ma la tua istanza data non lo fa.Ad esempio, se, nel passaggio 5, il nostro
Ioracle ha permesso più di tre fasce orarie o più di k = 0 conflitti, quindi il
L'istanza potrebbe avere molte soluzioni inaspettate.In tali casi, potrebbe essere necessario
Resta il passaggio 5, aggiungendo ulteriori vincoli all'istanza in modo che non abbia più
queste soluzioni.
7) valido a valido: per dimostrare che l'algoritmo Algalg (IALG) funziona, è necessario
Dimostra che se Soracle è una soluzione valida per Ioracle = InstanceMap (IALG), allora Salg =
SolutionMap (Soracle) è una soluzione valida per IALG.
Pianificazione del corso 3-COL ≤Poly: supponendo che il programma sia valido, lo dimostriamo
che la colorazione è valida come segue.È costruita l'istanza da programmare
in modo che, per ogni bordo del grafico dato, c'è uno studente che richiede il
Corsi U e V associati ai nodi di questo bordo.Perché il programma è
valido, ci sono conflitti K = 0 del corso, e quindi questi corsi sono tutti programmati
in diverse fasce di tempo.La colorazione costruita quindi assegna colori diversi a questi nodi.
8) InversesesolutionMap: sebbene non ne abbiamo bisogno per il codice, per la prova di te
deve definire un algoritmo invertesesolutionmap (s ′
alg) mappatura nella direzione inversa
da ogni potenziale soluzione s ′
Alg per l'istanza ialg a una potenziale soluzione s ′
Oracle per
l'istanza Ioracle.

---
layout: 
title: Pagina 352
level: 3
---


Problemi di ottimizzazione
336
Pianificazione del corso 3-COL ≤Poly: data una colorazione S ′
da colorare nodo da colorare u con
Colore C, definiamo S ′
PROGRAMMA = inverseSesolutionMap (S ′
Colorazione) Essere il corso di assegnazione del corso U alle fasce di tempo c.
ATTENZIONE: InversesesolutionMap (S ′
Alg) non deve essere la mappa inversa di
SolutionMap (Soracle).È necessario definire la mappatura inversationmap (Salg)
Ogni possibile soluzione s ′
Alg, non solo quelli mappati da Solutionmap (Soracle).
Altrimenti, c'è il pericolo è che l'iaLG abbia soluzioni ma l'istanza costruita Ioracle no.
9) inverso valido a valido: devi anche dimostrare la direzione inversa: che se s ′
Alg è a
soluzione valida per ialg, quindi s ′
Oracle = InversesesolutionMap (S ′
Alg) è una soluzione valida per
Ioracle = InstanceMap (ialg).
Pianificazione del corso 3-COL ≤Poly: supponendo che la colorazione sia valida, dimostramo
che il programma è valido come segue.È costruita l'istanza da programmare
in modo che ogni studente richieda i corsi U e V associati a nodi di alcuni
bordo.Poiché la colorazione è valida, a questi nodi sono stati assegnati colori diversi e quindi i corsi sono tutti programmati in diverse fasce di tempo.Quindi, lì
sarà k = 0 conflitti del corso.
10) Algoritmo di lavoro: dati i passaggi precedenti, ora è possibile dimostrare che se il
Il presunto algoracolo algoritmo risolve correttamente Poracle, quindi il nostro algoritmo Algalg risolve correttamente Palg.
Sì a sì: iniziamo dimostrando che Algalg risponde sì quando viene data un'istanza
per il quale la risposta è sì.Se ialg è un'istanza sì, allora con la definizione di
Il problema Palg, deve avere una soluzione valida.Indichiamo da S ′
Alg uno di questi
soluzione valida.Quindi al passaggio 9, segue che s ′
Oracle = InversesesolutionMap (S ′
Alg)
è una soluzione valida per Ioracle = InstanceMap (IALG).Questo testimonia il fatto che
Ioracle ha una soluzione valida e quindi Ioracle è un'istanza per la quale la risposta
è sì.Se Algoracle funziona correttamente come supposto, allora restituisce sì e un valido
Soluzione Soracle.Il nostro codice per Algalg restituirà quindi la risposta corretta sì e
Salg = SolutionMap (Soracle), che per passaggio 7 è una soluzione valida per IALG.
No a no: ora dobbiamo dimostrare il contrario, che se l'istanza è stata data ad Algalg
è un'istanza, quindi Algalg risponde No. Il problema senza istanze lo è
che non hanno alcun testimonianza per dimostrare di non essere casi.Fortunatamente, per dimostrare
Qualcosa, è sufficiente dimostrare il contrapposto.Invece di provare A ⇒B, dove a = "ialg è un'istanza senza" e b = "Algalg risponde no", lo dimostreremo
¬B ⇒¬a, dove ¬B = "Algalg risponde Sì" e ¬a = "ialg è un'istanza sì".Convinti che questo è equivalente.
Se algalg viene data l'istanza e risponde sì, il nostro codice è tale che
L'algoracolo deve aver restituito sì.Se Algoracle funziona correttamente come supposto, l'istanza Ioracle = InstanceMap (IALG) che è stato dato deve essere un'istanza sì.Quindi,

---
layout: 
title: Pagina 353
level: 3
---


Riduzioni e completezza NP
337
Ioracle deve avere una soluzione valida.Indichiamo da Soracle una soluzione valida.
Quindi al passaggio 7, Salg = SolutionMap (Soracle) è una soluzione valida per IALG, Testimone
IALG essendo un'istanza sì.Questa è la conclusione richiesta ¬A.
Questo completa correttamente la prova che se il presunto algoracolo dell'algoritmo risolve correttamente
Poracle, quindi il nostro algoritmo Algalg risolve correttamente Palg.
11) Tempo di esecuzione: il passaggio rimanente è dimostrare che l'algoritmo costruito Algalg funziona in tempo polinomiale (| ialg | (1)).I passaggi 5 e 6 richiedono che entrambi
InstanceMap (IALG) e SolutionMap (SORAcle) funzionano in tempo polinomiale.Quindi, se Poracle
Può essere risolto rapidamente, quindi Algalg funziona in tempo polinomiale.In genere, per le riduzioni
La gente presume che l'Algoracle sia un oracolo, il che significa che risolve il suo problema in uno
passo temporale.L'esercizio 20.2.5 esplora ulteriormente il problema del tempo di esecuzione.
Ciò conclude la prova che la pianificazione del corso di PORACLE = è completa NP (supponendo, ovviamente, che Palg = 3-COL ha già dimostrato di essere NP-completo).
Esercizio 20.2.1 Abbiamo iniziato questa sezione dimostrando (qualsiasi problema di ottimizzazione) ≤poy
Cir-Sat.Per rendere questa prova più concreta, rifare, completando ciascuno dei passaggi precedenti
in particolare per Cir-SAT 3-COL ≤Poly.(Suggerimento: The Circuit Ioracle = InstanceMap (IALG)
dovrebbe avere una variabile x⟨u, c⟩ per ogni coppia ⟨u, c⟩.)
Esercizio 20.2.2 3-Sat è un sottoinsieme del problema CIR-Sat in cui il circuito di ingresso
Deve essere un grande e di clausole, ogni clausola deve essere o al massimo tre letterali e ogni letterale è una variabile o la sua negazione.Dimostrare che 3-Sat è NP-Conversione
dimostrando che 3-COL ≤Poly 3-Sat.(Suggerimento: la risposta è quasi identica a quella per
Esercizio 20.2.1.)
Esercizio 20.2.3 Sia CIR-SAT il complemento del problema CIR-Sat, vale a dire, la risposta è sì se e solo se il circuito di ingresso non è soddisfacente.Puoi dimostrare
CIR-SAT ≤POLY CIR-SAT usando riduzioni di cucina?Puoi dimostrarlo usando le riduzioni di Karp?
Esercizio 20.2.4 (vedi soluzione nella parte cinque.) Supponiamo che il problema P1 sia una versione limitata
di p2, in quanto sono gli stessi tranne che p1 è definito su un sottoinsieme i1 ⊆i2 delle istanze
Quel p2 è definito.Ad esempio, 3-Sat è una versione limitata di CIR-SAT, perché
Entrambi determinano se un determinato circuito ha un incarico soddisfacente;Tuttavia, 3-Sat
Considera solo tipi speciali di circuiti con clausole di tre letterali.Quanto è difficile
Dimostrare P1 ≤Poly P2?Quanto è difficile dimostrare P2 ≤Poly P1?
Esercizio 20.2.5 (vedi soluzione nella parte cinque.) Supponiamo che quando si dimostra Palg ≤Poly
Poracle, The Routines InstanceMap (IALG) e SolutionMap (Soracle) ciascuno correndo in O (| ialg | 3)
tempo e che la mappatura instancemap (ialg) costruisce dall'istanza ialg e

---
layout: 
title: Pagina 354
level: 3
---


Problemi di ottimizzazione
338
istanza Ioracolo che è molto più grande, vale a dire | Ioracle |= | Ialg | 2.Dati i seguenti due
tempi di esecuzione dell'algoracolo dell'algoritmo, determinare il tempo di esecuzione dell'algoritmo
Algalg.(Attento!)
1.
Tempo (algoracolo) = (2n
1
3)
2.
Tempo (algoracolo) = (NC) per qualche costante c.
20.3
Esempio: 3-color è NP-completo
Ora utilizzeremo di nuovo i passaggi per dimostrare che il 3-color è NP-completo.
0) In NP: il problema 3-COL è in NP perché, dato un grafico istanza IGRAPH e A
Soluzione Coloring Scoloring, è facile avere un controllo valido algoritmo (igraph, scoloring)
che ogni nodo è colorato con uno dei tre colori e che i nodi di ogni bordo
avere colori diversi.
1) Cosa ridurlo: ridurremo CIR-SAT a 3-COL dimostrando CIR-SAT
≤Poly 3-Col.Nella sezione 20.1 abbiamo dimostrato che (qualsiasi problema di ottimizzazione) ≤Poly Cirsat e quella pianificazione del corso 3-COL ≤Poly.Per transitività, questo ci dà che la pianificazione Cirsat, 3-COL e corsi sono problemi di completamento NP.
2) Cos'è cosa:
R Palg è il problema del circuito SATIS di capacità (CIR-SAT).
R iCircuit, un'istanza di esso, è un circuito.
R Sassignment, una potenziale soluzione, è un incarico alle variabili del circuito x1, x2, ..., xn.
R Poracle è il problema del grafico 3-color (3-COL).
R igraph, un'istanza ad essa, è un grafico.
r scolaring, una potenziale soluzione, è una colorazione dei nodi del grafico con tre
colori.
3) Direzione di riduzione e codice: per dimostrare che 3-col è almeno altrettanto difficile, dobbiamo
Dimostrare che il CIR-SAT è almeno altrettanto facile, cioè CIR-Sat ≤Poly 3-Col.Per fare questo, dobbiamo
Progettare un algoritmo per CIR-SAT somministrato un algoritmo per 3-COL.Il codice sarà identico a quello nella Sezione 20.2.
4) Cerca somiglianze: un incarico alloca valori vere o falsi a ciascuna variabile, che a sua volta induce valori veri o falsi all'output di ciascun gate.Una colorazione assegna uno dei tre colori a ciascun nodo.Questa somiglianza suggerisce di mappare le variabili
e uscite di ciascun gate ai nodi nel grafico e mappatura fedele a un colore e
falso a un altro.Con queste idee in mente, Steven Rudich ha fatto una ricerca di computer
Per il grafico più piccolo che si comporta come un o gate se colorato con tre colori.
Il grafico trovato è mostrato nella Figura 20.1.Lo chiama un o gadget.

---
layout: 
title: Pagina 355
level: 3
---


Riduzioni e completezza NP
339
v
F
VOUT
X
v
O gadget
v
Non gadget
T
v
R
G
B
G
Colorazione
R
R
(x o y)
v
v
fuori
(non z)
v
R
fuori
X
y
z
Circuito
T
F
F
F
F
Circuito
T
Grafico
G
R
G
B
R
G
B
R
G
O
O
NON
v
z
B
G
B
G
R
B
R
G
R
vf
R
v t
v
NON
O
O
X
v
y
v
v
Vy
4
v
fuori
v
F
v
VR
vt
(F o t) =
T
5
3
v
v2
1
v
VX
V6
G
R
G
B
G
G
R
B
(F o f) = f
R
G
R
B
R
G
B
G
R
R
G
R
B
Figura 20.1: Nella parte superiore, il primo diagramma è il o gadget.I prossimi due sono coloranti di questo
Gadget che dimostra (falso o vero) = vero e (falso o falso) = falso.Il diagramma in alto a destra
non è il gadget.Sul fondo, il primo diagramma è il circuito dato come istanza per sabato.
Il prossimo è il grafico in cui è tradotto.Il prossimo è un 3-color di questo grafico.L'ultimo è
l'assegnazione per il circuito ottenuto dalla colorazione.
Tradurre tra colori e vero/falso: i tre nodi VT, VF e VR in
Il gadget o è indicato come pallet.A causa dei bordi tra loro, quando il gadget è correttamente colorato, a questi nodi deve essere assegnato diversi
colori.Chiameremo qualunque colore sia assegnato al nodo vt il colore che indica
VERO;che assegnato a VF, il colore che indica falso;e quello assegnato a VR, il
colore rimanente.Ad esempio, in tutti i coloranti della Figura 20.1, il verde (g) indica vero, rosso (R) indica falso e blu (b) è il colore rimanente.
Valori di input e output: i nodi VX e VY nel gadget agiscono come input del gadget e il vout del nodo come output.Perché ciascuno di questi nodi ha un
da bordo a nodo VR, non possono essere colorati con il colore rimanente.Il nodo lo farà
si dice che abbia il valore vero, se viene assegnato lo stesso colore di VT e falso se
lo stesso di VF.La colorazione nella seconda figura nella Figura 20.1 imposta x = false, y = true e output = true.La colorazione nella terza figura imposta x = false, y = false e output = false.
Teorema 20.3.1: Rudich o gadget si comporta come un o gate, in quanto può sempre essere
e deve sempre essere colorato in modo che il valore del suo nodo di output sia il o di
I valori dei suoi due nodi di input VX e VY.Allo stesso modo per il non gate.
Prova: ci sono quattro istanze di input sul gate da considerare.
(falso o vero) = vero: se il nodo vx è colorato falso e vy è colorato vero, allora
Poiché V5 ha un bordo per ciascuno, deve essere colorato il colore rimanente.V6, con bordi a VF e V5, deve essere colorato vero.V4, con bordi a VR e V6,

---
layout: 
title: Pagina 356
level: 3
---


Problemi di ottimizzazione
340
deve essere colorato falso.VOUT, con bordi a VR e V4, deve essere colorato vero.IL
La colorazione nel secondo diagramma nella Figura 20.1 dimostra che una tale colorazione è
possibile.
(Falso o falso) = Falso: se i nodi VX e VY sono entrambi falsi colorati, allora né i nodi V1 né V3 possono essere colorati falsi.A causa del bordo tra loro, uno di loro deve essere vero e l'altro il colore rimanente.Perché V2 ha
Un bordo per ciascuno di essi, deve essere colorato falso.v4, con bordi a VR e
V2, deve essere colorato vero.VOUT, con bordi a VR e V4, deve essere colorato falso.
La colorazione nel terzo diagramma nella Figura 20.1 dimostra che una tale colorazione
è possibile.
(vero o vero) = vero e (vero o falso) = vero: vedi
Esercizio
20.3.1
per
questi casi e per il non gate.
5) InstanceMap, traduzione del circuito in un grafico: il nostro algoritmo per CIR-SAT
prende come ingresso un circuito iCircuit per essere soddisfatto e, al fine di ricevere aiuto dal
Algoritmo 3-COL, costrutti da esso un grafico igraph = instancemap (iCircuit) da colorare.Vedi i primi due diagrammi nella parte inferiore della Figura 20.1.Il grafico avrà
Un pallet di nodi VT, VF e VR con cui definire il vero e il falso colore.
Per ogni variabile XI del circuito, avrà un nodo etichettato XI.Ne avrà anche uno
nodo etichettato xout.Per ciascuno o gate e non gate nel circuito, il grafico avrà
Una copia del gadget o del non gadget.Le porte potrebbero essere tradotte in
un simile e gadget o tradotto in [x e y] = [non (non (x) o no (y))].Tutto di
Questi gadget condividono gli stessi tre nodi di pallet.Se nel circuito l'uscita di uno
Il gate è l'ingresso di un altro, quindi i nodi corrispondenti nel grafico sono gli stessi.
Infine, viene aggiunto un bordo aggiuntivo al grafico dal nodo VF al nodo VOUT.
6) Solutionmap, traduzione di una colorazione in un incarico: quando il presunto
L'algoritmo trova uno scolaring da colorare per il grafico igraph = instancemap (iCircuit), il nostro algoritmo deve tradurre questa colorazione in un assegnazione di sagoma = soluzioni
(Scoloring) delle variabili x1, x2 ,..., xn per il circuito.Vedere gli ultimi due diagrammi su
fondo della Figura 20.1.La traduzione viene eseguita impostando xi su true se nodo VXI
è colorato lo stesso colore del nodo VT e falso se lo stesso di VF.Se il nodo VXI ha il
Stesso colore di Node VR, allora questa non è una colorazione valida (perché c'è un bordo in
Il grafico dal nodo VXI al nodo VR) e quindi non deve essere considerato.
ATTENZIONE: supponiamo che il grafico costruito avesse un nodo separato per ogni volta
che il circuito utilizzava la variabile XI.L'istruzione “Imposta xi su true quando il nodo
VXI ha un po 'di colore "sarebbe quindi ambiguo, perché ai diversi nodi che rappresentano XI potrebbero essere dati colori diversi.
7) valido a valido: qui dobbiamo dimostrare che se il presunto algoritmo ci dà un
Scoloring da colorare valido per il grafico igraph = instancemap (iCircuit), quindi sassignment =
SolutionMap (scoloring) è un incarico che soddisfa il circuito.Dal gadget

---
layout: 
title: Pagina 357
level: 3
---


Riduzioni e completezza NP
341
Teorema, ogni gadget nel grafico deve essere colorato in un modo che agisce come il gate corrispondente.Quindi, quando applichiamo l'assegnazione al circuito, l'uscita di
Ogni gate avrà il valore corrispondente al colore del nodo corrispondente.Esso
è come se la colorazione del grafico stesse eseguendo il calcolo del circuito.Esso
segue che l'output del circuito avrà il valore corrispondente al colore
di nodo vout.Poiché Node Vout ha un bordo per VR e un bordo extra a VF, VOUT deve
essere colorato vero.Quindi, l'assegnazione è uno per il quale è l'uscita del circuito
VERO.
8) InversesesolutionMap: per la prova dobbiamo anche definire la mappatura inversa da ciascun smistamento di assegnazione a uno scoloring da colorare = inverseSesolutionMap
(Sassignment).Inizia colorando i nodi del pallet vero, falso e il colore rimanente.
Colora ogni nodo VXI vero o falso in base al compito.Quindi Teorema 20.3.1
afferma che non importa come sono colorati i nodi di input per un gadget, l'intero gadget
può essere colorato con il nodo di output con il colore indicato dall'uscita del
gate corrispondente.
9) invertire valido a valido: ora dimostriamo che se la sedetta al cedimento dell'assegnazione
Il circuito, quindi la colorazione scoloring = inversesesolutionmap (sassignment) è valido.Teorema 20.3.1 ha assicurato che ogni bordo in ciascun gadget abbia due colori diversi.L'unica
Il bordo rimanente da considerare è il bordo extra.Poiché i colori percolano il grafico, il vout del nodo deve avere un colore corrispondente all'uscita del circuito, che deve essere
Il vero colore, perché l'incarico soddisfa il circuito.Questo garantisce che anche il
Il bordo extra da VF a VOUT è colorato con due colori diversi.
10) e 11): questi passaggi sono sempre gli stessi.Mappe di InstanceMap (iCircuit) Sì
istanze per istanze da 3 colture e no a No. Quindi, se il presunto algoritmo
3-COL funziona correttamente in tempo polinomiale, quindi il nostro algoritmo progettato correttamente
Risolve CIR-SAT in tempo polinomiale.Ne consegue che Cir-sat ≤poly 3-col.In conclusione, il 3-coloring è NP-completo.
Esercizio 20.3.1
(a) Completare la prova del teorema 20.3.1 dimostrando i casi
(vero o vero) = vero e (vero o falso) = vero.(b) dimostrare un teorema simile per il
Non gadget.Vedi il diagramma in alto a destra nella Figura 20.1.
Esercizio 20.3.2 Verificare che ogni bordo nel grafico igraph = instancemap (iCircuit)
necessario, dimostrando che se non fosse lì, sarebbe possibile per il grafico
Avere una colorazione valida anche quando il circuito non è soddisfatto.
Esercizio 20.3.3 (vedi soluzione nella parte quinta.) Dimostrare che il set indipendente è NP-COMPETE
dimostrando quel set indipendente ≤poly 3-COL.(Suggerimento: un 3-color per il grafico G3-COL
può essere pensato come un sottoinsieme delle coppie ⟨u, c⟩where u è un nodo di g3-col e c è
un colore.Un set indipendente del grafico Gind seleziona un sottoinsieme dei suoi nodi.Quindi, a

---
layout: 
title: Pagina 358
level: 3
---


Problemi di ottimizzazione
342
modo per costruire il grafico gind nell'istanza ⟨gind, nind⟩ = instancemap (g3-col)
sarebbe avere un nodo per ogni coppia ⟨u, c⟩.Fare attenzione quando si definisce i bordi per
il grafico gind = instancemap (g3-col) in modo che ogni set indipendente valido di dimensione n in
Il grafico costruito corrisponde a un 3-color valido del grafico originale.Se la
Il grafico costruito ha set indipendenti inaspettati, potrebbe essere necessario aggiungere più bordi
ad esso.)
20.4
Un algoritmo per la corrispondenza bipartita utilizzando la rete
Algoritmo di flusso
Fino ad ora abbiamo giustificato la nostra convinzione che alcuni problemi computazionali
sono difficili riducendoli ad altri problemi ritenuti difficili.Qui, lo faremo
dare un esempio del contrario, dimostrando che il problema della corrispondenza bipartita può
essere risolto facilmente riducendolo al problema del flusso di rete, che già sappiamo
è facile perché abbiamo dato un algoritmo a tempo polinomiale per questo nel capitolo 15.
Abbinamento bipartito: la corrispondenza bipartita è un classico problema di ottimizzazione.Come sempre, definiamo il problema dando una serie di istanze, una serie di soluzioni per ciascuno
istanza e un costo per ogni soluzione.
Istanze: un'istanza di input al problema è un grafico bipartito.Un bipartito
Il grafico è un grafico i cui nodi sono partizionati in due set U e V e tutti i bordi
Nel grafico vai tra U e V. Vedi il primo diagramma nella Figura 20.2.
Soluzioni per un'istanza: data un'istanza, una soluzione è una corrispondenza.Una corrispondenza è un sottoinsieme M dei bordi in modo tale che nessun nodo appare più di una volta in M.
Vedi l'ultimo diagramma nella Figura 20.2.
Costo di una soluzione: il costo (o il successo) di una corrispondenza è il numero di coppie
abbinato.Si dice che sia una corrispondenza perfetta se ogni nodo è abbinato.
Obiettivo: dato un grafico bipartito, l'obiettivo del problema è trovare una corrispondenza
Abbina quante più coppie possibili.
Flusso di rete: il flusso di rete è un altro esempio di un problema di ottimizzazione che
implica la ricerca di una soluzione migliore da alcune grandi soluzioni.
Istanze: un'istanza ⟨g, s, t⟩consist di un grafico diretto G e nodi specifici
s e t.Ogni bordo ⟨u, V⟩ è associato a una capacità positiva c⟨u, v⟩.
Soluzioni per l'istanza: una soluzione per l'istanza è un flusso, che specifica
Un flace, v⟩≤c⟨u, v⟩through ogni bordi della rete senza perdite o flusso aggiuntivo in qualsiasi nodo.
Misura del successo: il costo (o il successo) di un flusso è la quantità di flusso di
nodo s.

---
layout: 
title: Pagina 359
level: 3
---


Riduzioni e completezza NP
343
grafico
Bipartito
Rete
Fluire
S
T
Abbinamento
S
T
Cap = 1
flusso = 1
flusso = 0
Figura 20.2: Il primo diagramma è il grafico bipartito indicato come istanza per la corrispondenza bipartita.
Il prossimo è la rete in cui è tradotto.Il prossimo è un flusso attraverso questa rete.IL
L'ultimo è l'abbinamento ottenuto dal flusso.
Obiettivo: data un'istanza ⟨g, s, t⟩, l'obiettivo è trovare una soluzione ottimale, cioè a
flusso massimo.
Flussi di rete bipartiti ≤poly: attraversiamo gli stessi passaggi di
Prima.
3) Direzione di riduzione e codice: ora progetteremo un algoritmo per la corrispondenza bipartita, dato un algoritmo per i flussi di rete.
4) Cerca somiglianze: una corrispondenza decide quali bordi conservare e un flusso decide quali bordi mettere il flusso.Questa somiglianza suggerisce di mantenere i bordi
che li hanno fluida.
5) InstanceMap, traduzione dei grafici bipartiti in una rete: il nostro algoritmo
Per la corrispondenza bipartita richiede come ingresso un grafico bipartito Gbipartite.Il primo passo è
Per tradurre questo in una rete Gnetwork = InstanceMap (Gbipartite).Vedere il primo
Due diagrammi nella Figura 20.2.La rete avrà i nodi U e V dal
grafico bipartito e per ogni bordo, contro il grafico bipartito, la rete ha
un bordo diretto ⟨u, v⟩.Inoltre, la rete avrà un nodo di origine S con
un bordo diretto da s a ciascun nodo u ∈U.Avrà anche un nodo di lavandino t con
un bordo diretto da ciascun nodo v ∈V a t.Ogni bordo fuori da S e ogni bordo
In T avrà la capacità uno.I bordi ⟨u, v⟩across Il grafico bipartito potrebbe essere
Data anche una capacità uno, ma potrebbero anche avere la capacità ∞.
6) Solutionmap, traduzione di un flusso in una corrispondenza: quando l'algoritmo di flusso di rete trova un flusso di flusso attraverso la rete, il nostro algoritmo deve tradurre questo
fluire in uno smotching corrispondente = Solutionmap (s fluoto).Vedere gli ultimi due diagrammi in
Figura 20.2.
Solutionmap: la traduzione mette il bordo ⟨u, contro la corrispondenza se c'è
un flusso di uno attraverso il bordo corrispondente nella rete e non se lì
non è un flusso nel bordo.

---
layout: 
title: Pagina 360
level: 3
---


Problemi di ottimizzazione
344
ATTENZIONE: fare attenzione a mappare ogni possibile flusso a una corrispondenza.Quanto sopra
La mappatura è mal definita quando c'è un flusso di 1
2 attraverso un bordo.Questo ha bisogno
essere fisso e potrebbe essere abbastanza problematico.
Flusso intero: per fortuna, l'esercizio 15.2.4 dimostra che se tutte le capacità in
Dati la rete sono numeri interi, quindi l'algoritmo restituisce sempre una soluzione in
che il flusso attraverso ogni bordo è un numero intero.Dato che le nostre capacità sono
Tutto uno, ogni bordo avrà un flusso di zero o di uno.Quindi, nella nostra traduzione, è ben definito se includere il bordo, contro la corrispondenza o
non.
7) valido a valido: qui dobbiamo dimostrare che se il flusso di flusso è valido, rispetto al
Anche lo schiacciamento corrispondente è valido.
Ogni u abbinata al massimo una volta: considera un nodo u ∈U.Il flusso in te può
essere al massimo uno, perché c'è solo un bordo e ha capacità
uno.Perché il flusso sia valido, il flusso di questo nodo deve eguagliarlo
Esso.Quindi, anche questo può essere al massimo.Perché ogni bordo da te ha nemmeno
fiorire zero o uno, ne consegue che al massimo un bordo da U ha flusso.Noi possiamo
concludere che u è abbinato al massimo un nodo v ∈V.
Ogni V abbinata al massimo una volta: vedere l'esercizio 20.4.1.
Costo al costo: per assicurarsi che la corrispondenza che otteniamo contiene il massimo
Numero di bordi, è importante che il costo dello smotching corrispondente =
Solutionmap (s fluoto) uguale al costo del flusso.Il costo del flusso è il
quantità di flusso fuori dal nodo s, che è uguale al flusso attraverso il taglio ⟨u, v⟩, che è uguale al numero di bordi ⟨u, v⟩with flusso di uno, che è uguale al
Numero di bordi nella corrispondenza, che equivale al costo della corrispondenza.
8) InversesesolutionMap: la mappatura inversa da ciascuna schiacciamento corrispondente a
Un flusso valido s fluoto = invertesesolutionmap (smatching) è semplice.Se il bordo
⟨U, v⟩is nella corrispondenza, quindi metti un flusso di uno dalla fonte s, lungo il bordo
⟨S, u⟩to nodo u, attraverso il bordo corrispondente ⟨u, v⟩ e poi via attraverso il
Edge ⟨v, t⟩to t.
9) Reverse valido a valido: dobbiamo anche dimostrare che se lo schiacciamento corrispondente è
Valido, quindi anche il flusso di flusso = inverseSesolutionMap (smatching) è valido.
Flusso in uguale flusso: poiché il flusso è una somma di percorsi, possiamo essere assicurati che il flusso è uguale al flusso di ogni nodo ad eccezione della sorgente
e il lavandino.Poiché la corrispondenza è valida, ogni U e ogni V sono abbinati a
La maggior parte una volta.Quindi i flussi attraverso i bordi ⟨s, u⟩, ⟨u, v⟩ e ⟨v, t⟩will be
Al massimo la loro capacità uno.

---
layout: 
title: Pagina 361
level: 3
---


Riduzioni e completezza NP
345
Costo per costare: ancora una volta, dobbiamo dimostrare che il costo del flusso di flusso =
InversesesolutionMap (Smatching) è uguale al costo della corrispondenza.Vedere
Esercizio 20.4.2.
10) e 11): questi passaggi sono sempre gli stessi.InstanceMap (Gbipartite) mappa istanze del grafico bipartito per le istanze di flusso di rete G con lo stesso costo.
Pertanto, poiché l'algoritmo alg flusso risolve correttamente i flussi di rete rapidamente, il nostro algoritmo progettato risolve correttamente la corrispondenza bipartita rapidamente.
In conclusione, la corrispondenza bipartita può essere risolta allo stesso tempo che il flusso di rete
è risolto.
Esercizio 20.4.1 Fornisci una prova per il caso in cui ciascuna V è abbinata al massimo una volta.
Esercizio 20.4.2 Dare la prova che il costo del flusso di flusso = InversivolutionMap
(Smatching) è lo stesso del costo della corrispondenza
Esercizio 20.4.3
Sezione 19.9 Costruisce tre algoritmi di programmazione dinamica
Usando riduzioni.Per ciascuno di questi, eseguire le fasi formali richieste per una riduzione.
Esercizio 20.4.4
C'è una raccolta di pacchetti software S1 ,..., Sn che sei
considerando l'acquisto.Questi sono divisi in due gruppi.Per quelli i ∈N ⊆ [n], il
costi per l'acquisto di modifica i benefici e quindi ti costa efficacemente un dato
Importo BI ≥0 per acquistarlo.Per quelli j ∈P ⊆ [n], i benefici per i costi di acquisto e quindi ti costa efficacemente un determinato importo BJ ≥0 per non acquistarlo.Alcuni
Questi pacchetti si affidano l'uno sull'altro;Se SI si basa su SJ, allora dovrai subire un ulteriore
Costo di A⟨i, j⟩≥0 Se acquisti SI ma non SJ.Fornire un algoritmo a tempo polinomiale per decidere il sottoinsieme S ⊆ [n] di S2 ,..., SN che dovresti comprare.Il costo della tua soluzione è
costo (s) =
i∈S∩n bi +
J∈S∩p BI +
i∈S, j∈S a⟨i, j⟩.(Suggerimento: non progettare un nuovo algoritmo
Ma fai una riduzione a Min Cut simile a quella fatta per abbinare i ragazzi e le ragazze.)

---
layout: 
title: Pagina 362
level: 3
---


346
21 algoritmi randomizzati
Per alcuni problemi computazionali, consentendo all'algoritmo di fluttuare monete (cioè, utilizzare a
Generatore di numeri casuali) rende un algoritmo più semplice, più veloce e più facile da analizzare.
I seguenti sono i tre motivi principali.
Nascondere i casi peggiori dall'avversario: il tempo di esecuzione di un randomizzato
Gli algoritmi vengono analizzati in modo diverso da quello di un algoritmo deterministico.A
volte, in questo modo è più giusto e più in linea con il modo in cui l'algoritmo funziona effettivamente
in pratica.Supponiamo, ad esempio, che un algoritmo deterministico dia rapidamente il
Risposta corretta sulla maggior parte delle istanze di input, ma è molto lenta o dà la risposta sbagliata
in alcuni casi.Il tempo di esecuzione e la sua correttezza sono generalmente misurati per essere
quelli su questi casi peggiori.A volte anche un algoritmo randomizzato potrebbe
Sii molto lento o dai la risposta sbagliata.(Vedi la discussione di Quick Ord, Sezione 9.1).
Tuttavia, accettiamo questo, fintanto che su ogni istanza di input, la probabilità di fare
Quindi (sopra la scelta delle monete casuali) è piccola.
Strumenti probabilistici: il campo dell'analisi probabilistica offre molte tecniche e lemmi utili che possono rendere semplice ed elegante l'analisi dell'algoritmo.
La soluzione ha una struttura casuale: quando la soluzione che stiamo tentando
Il costrutto ha una struttura casuale, un buon modo per costruirla è semplicemente le monete
Decidi come costruire ogni parte.A volte siamo quindi in grado di dimostrarlo con alto
Probabilità La soluzione ottenuta in questo modo ha proprietà migliori di qualsiasi soluzione
Sappiamo come costruire determinalmente.Inoltre, se possiamo dimostrare che la soluzione costruita in modo casuale ha proprietà estremamente buone con alcuni molto piccoli ma
probabilità diversa da zero (ad esempio, prob = 10-100), quindi questo dimostra l'esistenza di
Tale soluzione anche se non abbiamo un modo ragionevolmente rapido di trovare uno.Un'altra situazione interessante è quando molto probabilmente la soluzione costruita a caso
Le proprietà desiderate, ad esempio con probabilità 0.999999, ma non c'è rapida
modo di testare se ciò che abbiamo prodotto ha le proprietà desiderate.
Questo capitolo considera ulteriormente queste idee.

---
layout: 
title: Pagina 363
level: 3
---


Algoritmi randomizzati
347
21.1
Usando la casualità per nascondere i casi peggiori
Il modo standard di misurare il tempo di esecuzione e la correttezza di un deterministico
L'algoritmo si basa sull'istanza di input del caso peggiore scelto da un brutto avversario
che ha studiato in dettaglio l'algoritmo.Questo non è giusto se l'algoritmo fa molto bene
su tutti tranne un piccolo numero di istanze di input molto strane e improbabili.Dall'altra
mano, sapere che l'algoritmo funziona bene sulla maggior parte dei casi non è sempre soddisfacente, perché per alcune applicazioni sono solo quei casi difficili che vuoi
risolvere.In tali casi, potrebbe essere più confortante usare un algoritmo randomizzato che
garantisce che su ogni istanza di input, la risposta corretta verrà ottenuta rapidamente
con alta probabilità.
Un algoritmo randomizzato è in grado di fluttuare monete mentre procede a decidere quali azioni intraprendere successive.Equivalentemente, un algoritmo randomizzato A può essere pensato come un set
di algoritmi deterministici a 1, a 2, a 3 ,...dove AR è ciò che l'algoritmo A fa quando
Il risultato dei flussi di monete è r = ⟨heads, code, teste, teste ,..., Tails⟩.Ciascuno di questi
L'algoritmo deterministico AR avrà un piccolo insieme di istanze di input del caso peggiore
che dà la risposta sbagliata o funziona troppo lentamente.L'idea è che questi algoritmi A 1, A 2, A 3 ,...hanno diversi set di casi peggiori.Questo randomizzato
L'algoritmo è buono se per ogni istanza di input, la frazione degli algoritmi deterministici A 1, A 2, A 3 ,...Per il quale non è un caso peggiore è almeno p.Poi quando
Uno di questi AR è scelto in modo casuale, risolve rapidamente questa istanza con probabilità a
minimo p.
A volte mi trovo utile considerare l'analisi di algoritmi randomizzati come
gioco tra un designer di algoritmo e un avversario che cerca di costruire input
istanze che andranno male per l'algoritmo.Nel gioco, non è sempre giusto per il
Ingresso contraddittorio scelto per conoscere il primo algoritmo, perché allora può scegliere
L'istanza che è il caso peggiore per questo algoritmo.Allo stesso modo, non è sempre giusto
Per il progettista dell'algoritmo conoscere l'istanza di input prima o anche quali istanze
sono probabili, perché allora può progettare l'algoritmo per funzionare bene su questi.Il modo
Analizziamo il tempo di esecuzione di algoritmi randomizzati compromessi tra questi
due.In questo gioco, il designer dell'algoritmo, senza conoscere l'istanza di input, deve
Per prima cosa fa il suo algoritmo dato il risultato delle monete.Sapendo questo, ma
Non conoscendo i risultati delle monete, l'istanza scelga il caso peggiore
esempio.Quindi noi monete, eseguiamo l'algoritmo e vediamo quanto bene.
Tre modelli: i seguenti sono definizioni formali di tre modelli.
Caso peggiore deterministico: nel peggiore dei casi, un algoritmo deterministico a
Per un problema computazionale P deve sempre dare rapidamente la risposta corretta:
∀i, [a (i) = p (i) e tempo (a, i) ≤tupper (| i |)]
Las Vegas: si dice che l'algoritmo sia Las Vegas se è sempre garantito
la risposta corretta, ma il suo tempo di esecuzione dipende dai risultati del casuale

---
layout: 
title: Pagina 364
level: 3
---


Problemi di ottimizzazione
348
flussi di monete.L'obiettivo è dimostrare che su ogni istanza di input, il previsto in esecuzione
Il tempo è piccolo:
∀i, [∀r, ar (i) = p (i) ed expr [time (ar, i)] ≤tupper (| i |)]
Monte Carlo: si dice che l'algoritmo sia Monte Carlo se è garantito che l'algoritmo si fermi rapidamente, ma a volte può, a seconda dei risultati del
Fuggi di monete casuali, dare la risposta sbagliata.L'obiettivo è dimostrare che su ogni input, la probabilità che dà la risposta sbagliata è piccola:
∀i, [prr [ar (i) ̸ = p (i)] ≤pfails e ∀r, time (ar, i) ≤tupper (| i |)]
I seguenti esempi dimostrano queste idee.
Ordine rapida: ricorda l'algoritmo di ordinamento rapido dalla sezione 9.1.L'algoritmo sceglie
un elemento perno e partizioni l'elenco dei numeri da risolvere in quelli che sono
più piccolo del perno e quelli che sono più grandi di esso.Quindi si ripresenta su ciascuno di
queste due parti.Il tempo di esecuzione varia da (n logn) a (n2), a seconda del
scelte di perni.
Caso peggiore deterministico: una scelta ragionevole per il perno è usare sempre il
Elemento che si trova nel mezzo dell'array da risolvere.Per tutti
scopi pratici, questo probabilmente funzionerebbe bene.Funzionerebbe eccezionalmente bene
Quando l'elenco è già risolto.Tuttavia, ci sono alcuni strani input, cotti
per l'unico scopo di essere brutto per questa particolare attuazione del
Algoritmo, su cui l'algoritmo funziona in tempo (N2).L'avversario fornirà
Un tale input, che dà una complessità del tempo peggiore di (N2).
Las Vegas: In pratica, ciò che viene spesso fatto è scegliere l'elemento pivot in modo casuale dagli elementi di input.Ciò lo rende irrilevante in cui l'ordine dell'avversario mette gli elementi nell'istanza di input.Il tempo di calcolo previsto
è (n log n).
Il problema del gioco: l'input I al problema del gioco specifica che specifica
di n porte hanno dei premi dietro di loro.Almeno la metà delle porte è promessa di avere
Premi.Un algoritmo A è in grado di guardare dietro le porte in qualsiasi ordine che gli piace, ma
nient'altro.Risolve correttamente il problema quando rileva un premio.Il tempo di esecuzione
è il numero di porte aperte.
Caso peggiore deterministico: qualsiasi algoritmo deterministico fissa l'ordine in cui
Guarda dietro le porte.Conoscendo questo ordine, l'avversario non colpisce premi dietro il primo n
2 porte guardarono dietro.
Las Vegas: al contrario, un algoritmo casuale guarderà dietro le porte a caso
ordine.Non importa dove l'avversario metta i premi;la probabilità che
non si trova dopo le porte a T è 1/2T e il tempo atteso fino a quando non viene trovato un premio
è exp [t] =
t pr [t = t] · t = 2.

---
layout: 
title: Pagina 365
level: 3
---


Algoritmi randomizzati
349
Monte Carlo: se la promessa è che almeno la metà delle porte ha premi o
Nessuno di loro lo fa e se l'algoritmo si ferma dopo 10 porte vuote e lo afferma
Non ci sono premi, quindi questo algoritmo è sempre veloce, ma dà la risposta sbagliata
con probabilità 1/210.
Test di primalità randomizzato: si dice che un intero x è composito se ha fattori
diverso da uno e se stesso.Altrimenti, si dice che sia Prime.Ad esempio, 6 = 2 × 3 è
Composito e 2, 3, 5, 7, 11, 13, 17 ,...sono primi.Vedere il capitolo 23.1, Esempio 23.2, per
Spiegazioni del perché ci vogliono 2 (n) tempo per tener conto di un numero n-bit.1 Qui do un facile
Algoritmo randomizzato, a causa di Rabin e Miller, per questo problema.
Il piccolo teorema di Fermat: non preoccuparti della matematica, ma Fermat è piccolo
Il teorema dice che se x è primo, quindi per ogni ∈ [1, x −1], è il caso che
ax - 1 ≡ (mod x) 1.
Se vogliamo testare se X è primo, allora possiamo scegliere A casuali nell'intervallo
E vedi se l'uguaglianza vale.Se l'uguaglianza non vale per un valore di A, allora x
è composito.Se l'uguaglianza vale per molti valori di A, allora possiamo dirlo
X è probabilmente Prime o come ciò che chiamiamo pseudoprime.
Il problema del gioco mostra: trovare una a per la quale un x - 1 ̸th (mod x) 1 è come trovare a
premio dietro la porta a.Vedi Esercizio 21.1.1.
Conteggio randomizzato: in molte applicazioni, si vuole contare il numero di
occorrenze di qualcosa.Questo problema può spesso essere espresso come segue: dato
l'istanza di input x, conta il numero di y per il quale f (x, y) = 1. è probabilmente molto
Difficile per determinare il numero esatto.Tuttavia, un buon modo per approssimare questo
Il numero è scegliere casualmente un gran numero di valori y.Per ciascuno, test
se f (x, y) = 1. quindi la frazione di y per la quale f (x, y) = 1 può essere approssimata da [il numero che hai trovato]/[il numero che hai provato].Il numero di y per il quale
f (x, y) = 1 può essere approssimato da [la frazione che hai trovato] × [il numero totale
di y].
Ad esempio, supponiamo che tu abbia avuto una forma strana e
Volevi trovare la sua area.Quindi x specificare la forma, y ​​specificherebbe un punto all'interno di una scatola circostante e
f (x, y) = 1 se il punto è all'interno della forma.Quindi il numero
di y per il quale f (x, y) = 1 ti dà l'area della tua forma.
y per il quale f (x, y) = 0
y per il quale f (x, y) = 1
X
Esercizio 21.1.1 Dato un numero intero x, supponiamo di avere una porta per ogni ∈
[1, x −1].Diremo che c'è un premio dietro questa porta se un X - 1 ̸ (Mod X) 1. Fermat's
Piccolo teorema dice che se x è pseudoprime, allora nessuna delle porte ha dei premi dietro
1 Una grande svolta di Agrawal et al.Nel 2002 è stato quello di trovare un algoritmo deterministico a tempo polinomiale per determinare se un numero di n-bit è PRIME.

---
layout: 
title: Pagina 366
level: 3
---


Problemi di ottimizzazione
350
loro, e se è composito, almeno la metà delle porte ha premi.L'algoritmo
tentativi di determinare quale sia il caso aprendo le porte scelte in casualmente per alcuni
intero t.
1.
Se l'algoritmo finisce un premio, cosa sai del numero intero?Se non lo fa
trovare un premio, cosa sai?
2.
Se l'algoritmo deve sempre dare la risposta corretta, quante porte devono essere
Aperto, in funzione del numero n di cifre nell'istanza x?
3.
Se le porte sono aperte e l'istanza di input x è uno pseudoprime, qual è la probabilità che l'algoritmo dia la risposta corretta?Se l'istanza è composita, cos'è questa probabilità?
Esercizio 21.1.2
Sezione 4.3 ha progettato un algoritmo iterativo per separare N VLSI
patatine in quelli che sono buoni e quelli che sono cattivi testando due patatine alla volta e
imparare o che sono uguali o che sono diversi.Per aiutare, almeno la metà di
I chip sono promessi di essere buoni.Ora progetta (molto più facile) un algoritmo randomizzato
Per questo problema.Ecco alcuni suggerimenti.
r Seleziona casualmente uno dei chip.Qual è la probabilità che il chip sia buono?
r Come puoi imparare se il chip selezionato è buono o meno?
r Se va bene, come puoi facilmente partizionare le patatine in patatine buone e cattive?
r Se il chip non è buono, cosa dovrebbe fare il tuo algoritmo?
r Quando dovrebbe fermarsi l'algoritmo?
R Qual è il tempo di esecuzione previsto di questo algoritmo?
21.2
Soluzioni di problemi di ottimizzazione con una struttura casuale
I problemi di ottimizzazione comportano la ricerca della soluzione migliore per un'istanza.A volte le buone soluzioni hanno una struttura casuale.In tali casi, un buon modo per costruire
Uno è semplicemente di fluire monete per decidere come costruire ogni parte.Dando due esempi.
Il primo, il taglio massimo, essendo NP-completo, probabilmente richiede tempo esponenziale per trovare
la migliore soluzione.Tuttavia, in o (n) tempo, possiamo trovare una soluzione che è probabile che lo facciano
Sii almeno la metà come ottimale.Il secondo esempio, i grafici di espansione, è persino
più estremo.Sebbene ci siano algoritmi deterministici per la costruzione di grafici
Con proprietà di espansione abbastanza buone, un grafico casuale quasi sicuramente ha proprietà di espansione molto migliori (con probabilità P ≥0.999999).Una complicazione, tuttavia, è che non esiste un algoritmo a tempo polinomiale che verifica se questo grafico costruito in modo casuale ha le proprietà desiderate.Spingendo ulteriormente i limiti, può essere dimostrato
che lo stesso grafico casuale ha proprietà estremamente buone con alcuni molto piccoli
ma probabilità diversa da zero (ad es. P ≥10-100).Anche se non abbiamo un modo rapido per costruire
Tale grafico, questo dimostra che esiste un tale grafico.
Il problema del taglio massimo: l'input per il problema di taglio massimo è un grafico non indirizzato.
L'output è una partizione dei nodi in due set U e V in modo tale che il numero di

---
layout: 
title: Pagina 367
level: 3
---


Algoritmi randomizzati
351
I bordi che attraversano da una parte all'altro sono il più grandi possibile.Questo problema
è NP-completo, e quindi l'algoritmo più noto per trovare una soluzione ottimale
richiede 2 (n) tempo.Il seguente algoritmo randomizzato funziona nel tempo (N) ed è
previsto per ottenere una soluzione per la quale la metà dei bordi si incrocia.Questo algoritmo è
incredibilmente semplice.Fa semplicemente scoppiare una moneta per ogni nodo per decidere se inserirla
U o in V. Ogni bordo si attraverserà con la probabilità 1
2. Quindi, il numero previsto
di bordi da attraversare è | e |
2.La soluzione ottimale non può avere più di tutti i bordi
attraversare, quindi si prevede che l'algoritmo randomizzato si esibirà almeno la metà e
La soluzione ottimale può fare.
Grafici di espansore: si dice che un grafico NODE NODE DETRO-D sia un grafico Expander se
Spostarsi da un set dei suoi nodi attraverso i suoi bordi ci espande a un set ancora più grande
di nodi.Più formalmente, per 0 <α <1 e 1 <β <d, un grafico g = ⟨v, e⟩is an ⟨α, β⟩espander se per ogni sottoinsieme s ⊆v dei suoi nodi, se | s |≤αn quindi | n (s) |≥β | s |.Qui
N (s) è il quartiere di s, cioè l'insieme di tutti i nodi con un bordo di alcuni
nodo in S.
Set non sovrapplattici di vicini D: perché ogni nodo v ∈V ha i vicini D
N (v), un set s ha d | s |bordi che lasciano questi nodi.Tuttavia, se questi set n (v) di
I vicini si sovrappongono molto, quindi il numero totale di vicini n (s) =
v∈s n (v) di
S potrebbe essere molto piccolo.Non possiamo aspettarci che n (s) siano più grandi di d | s |, ma lo facciamo
voglio che abbia dimensioni almeno β | s |dove 1 <β <d.Se S è troppo grande, non possiamo aspettarci
si espande ulteriormente.Quindi, richiediamo solo questa proprietà di espansione per le serie di
dimensioni al massimo αn.Perché prevediamo che set di dimensioni αn si espandono in un quartiere
Della dimensione βαn, richiediamo che αβ <1.
Collegato a percorsi brevi: se αβ> 1
2, quindi ogni coppia di nodi in G è collegata con un percorso di lunghezza al massimo 2 log (n/2)
Log β
.
Prova: considera due nodi U e v. Il nodo U ha d vicini, n (u).Questi
I vicini n (u) devono avere almeno β | n (u) |= vicini βd n (n (u)).Questi
I vicini N (N (U)) devono avere almeno vicini β2D.Ne consegue
sono almeno nodi βi - 1D con la distanza I da u.L'ultima volta che ci è permesso
Per fare ciò espande il set di vicini di dimensioni | s |= αn a | n (s) |≥β | s |= βαn.
Dal requisito che αβ> 1
2, questo nuovo set di vicini ha dimensioni maggiori di
N
2 nodi.La distanza di questi nodi da u è al massimo I = logβ
N
2.Questo set
potrebbe non contenere v. Tuttavia, a partire da v c'è un'altra serie di più
della metà dei nodi distanti i = logβ
N
2 da v. Questi due set devono
Oltre il giro in qualche nodo w.Quindi, c'è un percorso da u a w a v di lunghezza
La maggior parte del log 2 (n/2)
Log β
.
Usi: i grafici di espansore sono molto utili sia nella pratica che per dimostrare
teoremi.

---
layout: 
title: Pagina 368
level: 3
---


Problemi di ottimizzazione
352
Reti tolleranti ai guasti: come abbiamo visto, ogni coppia di nodi in un grafico di espansione è collegata.Questo è ancora vero se un gran numero di nodi
o i bordi falliscono.Quindi, questo è un buon modello per il cablaggio di una comunicazione
rete.
Generatori di pseudorandom: fare una breve passeggiata casuale in un espansore
Il grafico ti porta rapidamente a un nodo casuale.Questo è utile per generare a lungo
stringhe dall'aspetto casuale da una corda corda di semi.
Concentrazione e riciclaggio di bit casuali: se abbiamo una fonte che ha
un po 'di casualità in essa (diciamo che N moneta si lancia con una probabilità sconosciuta
e con dipendenze sconosciute tra le monete), possiamo usare l'espansore
grafici per produrre una stringa di bit m che sembrano essere il risultato di m equo e
monete indipendenti.
Codici di correzione degli errori: i grafici di espansione sono utili anche nella progettazione di modi
di codificare un messaggio in un codice più lungo in modo che se una frazione ragionevole
del codice più lungo è corrotto, il messaggio originale può ancora essere recuperato.
I bit difettosi sono collegati da brevi percorsi per correggere i bit.
Se αβ <1, allora esistono grafici di espansione: ora dimostreremo per eventuali costanti
α e β per i quali αβ <1 esiste un grafico ⟨α, β⟩-espander con n nodi e
Grado D per qualche costante sufficientemente grande d.Ad esempio, se α = 1
2, β = 3
2, quindi d = 5
è sufficiente.Per semplificare l'analisi, considereremo i grafici diretti in cui ciascuno
Il nodo U è collegato ai nodi D scelti in modo indipendente a caso.(Se ignoriamo il
Indicazioni dei bordi, quindi ogni nodo ha una laurea media 2D e set di quartiere
sono solo più grandi.) Dimostriamo che la probabilità che non otteniamo un tale grafico espansore
è rigorosamente meno di uno.Quindi, si deve esistere.
Evento ES, T: il grafico G non sarà un ⟨α, β⟩-espander se c'è alcuni set s
per quale | s |≤αn e n (s) <β | s |.Quindi, per ogni coppia di set s e t, con
| S |≤αn e | t |<β | s |, lasciano, t indica il cattivo evento che n (s) ⊆t.Lasciateci
lega la probabilità di ES, t quando scegliamo G in caso.Ogni nodo nelle esigenze s
D Vicini, per un totale di D | S |vicini scelti casualmente.La probabilità di a
In particolare uno di questi atterraggi in t è | t |/n.Poiché questi bordi sono scelti in modo indipendente, la probabilità che tutti atterrano in t lo sono

| T |/n
D | S |.
Probabilità di un brutto evento: la probabilità che G non sia un espansore è il
probabilità che almeno uno di questi cattivi eventi, t accada, che è al massimo
La somma delle probabilità di questi eventi individuali:
Pr [g non un espansore] = pr [almeno uno degli eventi, si verifica]
≤

S, t
Pr [es, t] =

(S≤αn)

(S | | S | = S)

(T | | t | = βs)
Pr [es, t]
=

s≤αn
n
S
n
βs
| T |
N
D | S |

---
layout: 
title: Pagina 369
level: 3
---


Algoritmi randomizzati
353
Ora usiamo il risultato che
n
UN

≤
en
UN
A:
Pr [g non un espansore] ≤

s≤αn
en
S
s en
βs
β β
N
ds
=

s≤αn

en
S
en
βs
β β
N
d s
≤

s≤αn

en
αn
en
βαn
β βαn
N
d s
=

s≤αn
Eβ+1
α
·

αβ
d - β

S
IL
Requisiti
È
Quello
αβ <1.
Quindi, se
D
È
sufficiente
grande
(D ≥
tronco d'albero

2eβ+1/α

/ tronco d'albero

1/αβ

+ β

, quindi la somma tra parentesi è al massimo 1
2:
Pr

G non un espansore

≤

s≤αn
1
2

S
<1
Ne consegue che pr [g è un espansore]> 0, il che significa che esiste almeno uno
Tale g che è un espansore.

---
layout: 
title: Pagina 370
level: 3
---


---
layout: 
title: Pagina 371
level: 3
---


Parte quarta
Appendice

---
layout: 
title: Pagina 372
level: 3
---


---
layout: 
title: Pagina 373
level: 3
---


357
22 Quanti ﬁ fr esistenziali e universali
I quantità esistenziali e universali forniscono un linguaggio estremamente utile per fare dichiarazioni formali.Devi capirli.Un gioco tra un prover e un
Il verificatore è un livello di astrazione all'interno del quale è facile da capire e dimostrare tale
dichiarazioni.

---
layout: 
title: Pagina 374
level: 3
---


Appendice
358
L'esempio degli anni: supponiamo che la relazione (predicato) amo (p1, p2) significhi che la persona p1 ama la persona p2.Poi abbiamo
Espressione
Senso
∃P2 Loves (Sam, P2)
"Sam ama qualcuno."
∀P2 Loves (Sam, P2)
"Sam ama tutti."
∃p1∀p2 ama (p1, p2)
"Qualcuno ama tutti."
∀p1∃p2 ama (p1, p2)
"Tutti amano qualcuno."
∃p2∀p1 ama (p1, p2)
“C'è una persona che è amata
da tutti. "
∃p1∃p2 (amori (p1, p2) e ¬loves (p2, p1))
"Qualcuno ama invano."
Definizione della relazione: a
relazione
Piace
Loves (P1, P2) stati per ogni coppia di oggetti
(diciamo p1 = sam e p2 = mary) che la relazione è tra loro o lo fa
non.Sebbene utilizzeremo la relazione di parola, gli amori (p1, p2) sono anche considerati un predicato.La differenza è che un predicato prende
solo un argomento e quindi si concentra su
se la proprietà è vera o falsa sul
Dato tuple ⟨p1, p2⟩ = ⟨sam, Mary⟩.
Rappresentazioni: le relazioni (predicati) possono essere rappresentate in vari modi.
Funzioni: una relazione può essere visualizzata come una funzione mappatura delle tuple di oggetti a true o false, ad esempio, ama: {p1 | p1 è una persona} × {p2 | p2
è una persona} ⇒ {true, false}.
Set di tuple: in alternativa, può essere visualizzato come un set contenente le tuple per
Che è vero, ad esempio ama = {⟨sam, Mary⟩, ⟨sam, Ann⟩, ⟨bob, Ann⟩ ,...}.
⟨Sam, mary⟩∈Laves Iff i loves (Sam, Mary) è vero.
Rappresentazione grafica diretta: se la relazione ha solo due argomenti, può essere
rappresentato da un grafico diretto.I nodi sono costituiti dagli oggetti nel dominio.
Posizioniamo un bordo diretto ⟨p1, p2⟩ tra coppie per le quali la relazione è vera.Se
I domini per i primi e secondi oggetti sono disgiunti, quindi il grafico è bipartito.Naturalmente, la relazione amorosa potrebbe essere definita per includere gli amori (Bob, Bob).
Vedi Figura 22.1.
Quantificatori: utilizzerai i seguenti quantità e proprietà.
Il quantificatore esistenziale: i ∃mei quantificano che esiste almeno un oggetto nel dominio con la proprietà.Questo quantificatore si riferisce al booleano

---
layout: 
title: Pagina 375
level: 3
---


Quantitazioni esistenziali e universali
359
Sam
Bob
Ron
Jone
Ann
Maria
Sam
Maria
Bob
Ron
Jone
Ann
Figura 22.1: una rappresentazione grafica diretta della relazione amorosa.
operatore
O.
Per
Esempio, ∃p1
Amori (sam, p1) ≡ [amori (Sam, Maria)
O
Ama (Sam, Ann) o Loves (Sam, Bob) o...].
Il quantificatore universale: i ∀mei quantificanti in cui tutti gli oggetti in
Il dominio ha la proprietà.Si riferisce all'operatore booleano e.Per
Esempio, ∀P1 Loves (Sam, P1) ≡ [Loves (Sam, Mary) e Loves (Sam, Ann) e
Ama (Sam, Bob) e...].
Combinazione di quantitazioni: possono essere combinati i quantiti.L'ordine delle operazioni è tale che ∀p1∃p2
Gli amori (P1, P2) sono intesi come trappola come
∀p1 [∃p1 loves (p1, p2)], cioè "Ogni persona ha la proprietà" Lo adora qualche altra
persona'."Si riferisce alla seguente formula booleana:
Amori (Sam, Mary)
Amori (Sam, Ann)
Amori (Sam, Jone)
O
Maria
Ann
Jone
Amo (Bob, Mary)
Amori (Bob, Ann)
Amori (Bob, Jone)
O
Maria
Ann
Jone
Amori (Ron, Mary)
Loves (Ron, Ann)
Amori (Ron, Jone)
O
Maria
Ann
Jone
E
Ron
Sam
Bob
Ordine di quantitazioni: l'ordine dei quantitazioni materiale.Ad esempio, se B è il
Classe di ragazzi e g è la classe di ragazze, ∀b∃g loves (b, g) e ∃g∀b loves (b, g) media
cose differenti.Il secondo afferma che la stessa ragazza è amata da ogni ragazzo.Per
Per essere vero, ci deve essere una specie di ragazza di Marilyn Monroe che tutti i ragazzi amano.
La prima dichiarazione dice che ogni ragazzo ama una ragazza.Una specie di ragazza di Marilyn Monroe
renderà vera questa affermazione.Tuttavia, è anche vero in una situazione monogama in
che ogni ragazzo ama una ragazza diversa.Quindi, la prima affermazione può essere vera in più
modi diversi rispetto al secondo.In effetti, la seconda affermazione implica la prima
Uno, ma non viceversa.
Definizione delle variabili libere e legate: il
dichiarazione
∃p2
Amori (Sam, P2)
significa "Sam ama qualcuno".Questa è una dichiarazione su Sam.Allo stesso modo, l'affermazione ∃P2 ama (P1, P2) significa "P1 ama qualcuno".Questa è una dichiarazione su
persona P1.Se l'affermazione è vera dipende da chi P1 si riferisce.IL
La dichiarazione non riguarda P2.La variabile P2 viene utilizzata come variabile locale (simile a
per (i = 1; i <= 10; i + +)) per esprimere "qualcuno".Potrebbe essere un fratello o un amico o un
cane.In questa espressione, diciamo che la variabile P2 è legata, mentre P1 è gratuito, perché
P2 ha un quantificatore e P1 no.

---
layout: 
title: Pagina 376
level: 3
---


Appendice
360
Sam
Maria
Ann
Jone
Bob
VERO
Sam
Bob
Maria
Ann
Falso
Figura 22.2: ∀g∃b∃p (amori (b, g) e amori (b, p)
e G ̸ = P).A sinistra è un esempio di situazione
in cui l'affermazione è vera, e a destra è
uno in cui è falso.
Definizione di altre relazioni: puoi definire altre relazioni dando un'espressione
con variabili gratuite.Ad esempio, puoi definire la relazione unaria LovessomeOne
(P1) ≡∃p2 ama (p1, p2).
Costruire espressioni: supponiamo che tu volesse affermare che ogni ragazza è stata ingannata
On, usando la relazione amorosa.Può essere utile rompere il problema in tre passaggi.
Passaggio 1. Supponendo altre relazioni: supponiamo di avere i trucchi di relazione (Sam, Mary), indicando che Sam imbroglia su Mary.Come esprimeresti l'affermazione che ogni ragazza è stata tradita?Il vantaggio di utilizzare questa funzione
è che possiamo concentrarci su questa parte dell'affermazione.Non lo stiamo sostenendo
Ogni ragazzo imbroglia.Un ragazzo potrebbe aver spezzato il cuore di ogni ragazza.
Detto questo, la risposta è ∀g∃b cheat (b, g).
Passaggio 2. Costruire l'altro predicato: qui non abbiamo una funzione cheat.
Quindi, dobbiamo costruire una frase dalla funzione ama affermando che Sam
trucchi su Mary.
Chiaramente, ci deve essere qualcun altro coinvolto oltre a Mary, quindi iniziamo
con ∃p.Ora, affinché si verifichi tradire, chi ha bisogno di amare chi?(Per
semplicità, supponiamo che imbrogliare significhi amare più di una persona allo stesso tempo.) Certamente, Sam deve amare p.Deve anche amare Maria.
Se non la amasse, allora non la tradirebbe.Deve Mary Love
Sam?No. Se Sam dice a Mary che la ama molto e poi un momento dopo
dice a Sue che la ama molto, poi ha tradito Mary indipendentemente da come
Mary si sente per lui.Pertanto, Maria non deve amare Sam.In conclusione, potremmo definire trucchi (Sam, Mary) ≡∃p (Loves (Sam, Mary) e Loves (Sam, P)).
Tuttavia, abbiamo fatto un errore qui.Nel nostro esempio, l'altra persona
e Maria non può essere la stessa persona.Quindi, dobbiamo definire la relazione come
Trucchi (Sam, Mary) ≡∃p (amori (Sam, Mary) e Loves (Sam, P) e P ̸ = Mary).
Passaggio 3. Combinazione delle parti: combinare insieme le due relazioni
∀g∃b∃p (amori (b, g) e amori (b, p) e p ̸ = g).Questa affermazione esprime che ogni ragazza è stata tradita.Vedi Figura 22.2.
Il dominio di una variabile: ogni volta che indichi ∃g o ∀g, ci deve essere un insieme compreso di valori che la variabile G potrebbe assumere.Questo set è chiamato dominio di
la variabile.Può essere esplicitamente dato o implicito, ma deve essere compreso.Qui

---
layout: 
title: Pagina 377
level: 3
---


Quantitazioni esistenziali e universali
361
Il dominio è "il" set di ragazze.Devi chiarire se questo significa tutte le ragazze
La stanza, tutte le ragazze attualmente nel mondo o tutte le ragazze che sono mai esistite.Per
Esempio, ∀x∃y x × y = 1
afferma che ogni valore ha un reciproco.Non è certamente vero per il dominio degli interi, perché due non hanno un reciproco intero.Sembra essere vero per
Domain of Reals.Fai attenzione, tuttavia: zero non ha un reciproco.Sarebbe
Meglio scrivere
∀x ̸ = 0, ∃y x × y = 1
o equivalentemente
∀x∃y (x × y = 1 o x = 0).
La negazione di un'affermazione: la negazione di un'affermazione è formata mettendo a
Segno di negazione sul lato sinistro.(Le staffe a volte aiutano.) Un'affermazione negata, tuttavia, è meglio compresa spostando la negazione come profonda (fino a destra) nel
Dichiarazione possibile.Questo viene fatto come segue.
Negare e / o /: una negazione all'esterno di un e o una dichiarazione
Può essere spostato più in profondità nell'affermazione usando la legge di De Morgan.Ricordiamo che il
Ed è sostituito da un o e il Or viene sostituito con un e.
¬ (amori (s, m) e amori (s, a)) iff ¬loves (s, m) o ¬loves (s, a): la negazione di "Sam ama Mary e Ann" è "o Sam non amaMaria o lui
non ama Ann. "Può amare una delle ragazze, ma non entrambe.
Un errore comune è quello di fare la negazione ¬loves (Sam, Mary) e
¬loves (Sam, Ann).Tuttavia, questo dice che Sam non ama né Mary né Ann.
¬ (amori (s, m) o amori (s, a)) iff ¬loves (s, m) e ¬loves (s, a): la negazione
di "Sam o ama Mary o Loves Ann" è "Sam non ama Maria e
Non ama Ann. "
Negating di quantitazioni: Allo stesso modo, una negazione può essere spostata oltre uno o più
quantificanti a destra o a sinistra.Tuttavia, devi quindi cambiarli
Quantificanti da esistenziale a universale e viceversa.Supponiamo che D sia l'insieme di
cani.Poi abbiamo:
¬ (∃d loves (sam, d)) iff ∀d ¬loves (sam, d): la negazione di “C'è un cane
che Sam ama "è" non c'è un cane che Sam ama "o" Tutti i cani sono non amati
di Sam. "Un errore comune è quello di indicare la negazione come ∃d ¬loves (sam, d).
Tuttavia, questo dice che "c'è un cane che non è amato da Sam".
¬ (∀d loves (sam, d)) iff ∃d ¬loves (sam, d): la negazione di "Sam ama ogni cane" è "C'è un cane che Sam non ama".

---
layout: 
title: Pagina 378
level: 3
---


Appendice
362
¬ (∃b∀d loves (b, d)) iff ∀b¬ (∀d loves (b, d)) iff ∀b∃d ¬loves (b, d): la negazione di “C'è un ragazzo che amaogni cane "è" non ci sono ragazzi che amano
ogni cane "o" per ogni ragazzo, non è il caso che ami ogni cane "o" per
Ogni ragazzo, c'è un cane che non ama. "
¬ (∃d1∃d2 ama (sam, d1) e amori (sam, d2) e d1 ̸ = d2) iff
∀d1∀d2 ¬ (Loves (Sam, D1) e Loves (Sam, D2) e D1 ̸ = D2) IFF
∀d1∀d2 ¬loves (sam, d1) o ¬loves (Sam, d2) o d1 = d2: la negazione di
"Ci sono due cani (distinti) che Sam ama" viene "data qualsiasi coppia di (distinti)
Cani, Sam non ama sia "o" dato alcun paio di cani, o Sam lo fa
non amare il primo o non ama il secondo, o mi hai dato lo stesso
cane due volte. "
Il dominio non cambia: la negazione di ∃x ≥5, x + 2 = 4 è ∀x ≥5, x +
2 ̸ = 4. La negazione non inizia ∃x <5.... sia l'affermazione che la sua negazione sono circa numeri maggiori di 5. C'è o non c'è un numero con il
Proprietà tale che x + 2 = 4?
Dimostrare una dichiarazione vera: ci sono una serie di tecniche apparentemente diverse
Per dimostrare che è vera un'affermazione esistenziale o universale.Il nucleo di tutti questi
Le tecniche, tuttavia, sono le stesse.Personalmente, mi piace vedere la prova come una strategia
vincere una partita contro un avversario.
Tecniche per dimostrare ∃d loves (sam, d):
Prova per esempio o per costruzione: la tecnica classica per dimostrarlo
Qualcosa con una determinata proprietà esiste è l'esempio.O fornisci direttamente un esempio o descrivi come costruire tale oggetto.Allora lei
Dimostra che il tuo esempio ha la proprietà.Per la dichiarazione di cui sopra, la prova
Dichiarerebbe "Let D essere Fido" e poi dimostrerebbe che Sam ama Fido.
Prova da parte di un gioco contraddittorio: supponiamo di affermare a un avversario
Un cane che Sam ama.Cosa dirà l'avversario?Chiaramente, sfida: “Oh, sì?Quale cane? "Quindi affronti la sfida producendo un cane specifico
d e dimostrando che ama (sam, d), cioè che Sam ama d.La dichiarazione è
Vero se hai una strategia garantita per battere qualsiasi avversario in questo gioco.
r Se l'affermazione è vera, allora puoi produrre qualche cane d.
r Se l'affermazione è falsa, allora non sarai in grado di farlo.
Tecniche per dimostrare ∀d loves (sam, d):
La prova dell'esempio non funziona: dimostrare che Sam ama Fido è interessante, ma non dimostra che ama tutti i cani.

---
layout: 
title: Pagina 379
level: 3
---


Quantitazioni esistenziali e universali
363
Prova per analisi del caso: il modo laborioso per dimostrare che Sam ama tutti i cani
è considerare ogni cane, uno alla volta, e dimostrare che Sam lo adora.
Questo metodo è impossibile se il dominio dei cani è infinito.
Prova per esempio arbitrario: la tecnica classica per dimostrare che ogni oggetto di alcuni domini ha una determinata proprietà è di lasciare che un simbolo rappresenti un oggetto arbitrario dal dominio e quindi dimostrare che quell'oggetto
ha la proprietà.Qui la prova inizierebbe "Sia D essere qualsiasi cane arbitrario".
Poiché in realtà non sappiamo quale cane D, dobbiamo (1) dimostrare
Ama (sam, d) semplicemente dalle proprietà che D ha perché d è un cane o
(2) Torna a fare un'analisi del caso, considerando ogni cane D separatamente.
Prova da parte di un gioco contraddittorio: supponiamo di affermare a un avversario che Sam
Ama ogni cane.Cosa dirà l'avversario?Chiaramente sfida: “Oh, sì?E Fido? "Si incontrano la sfida dimostrando che Sam ama
Fido.In altre parole, l'avversario fornisce un cane d ′.Vinci se puoi
Dimostrare che ama (Sam, D ′).
L'unica differenza tra questo gioco e quello per i quantità esistenziali è chi fornisce l'esempio.È interessante notare che il gioco ne ha solo uno
girare.L'avversario viene data solo un'opportunità per sfidarti.
Una prova dell'affermazione ∀d loves (Sam, d) consiste in una strategia per vincere il gioco.Tale strategia prende un cane arbitrario d ′, fornito dal
avversario e dimostra che "Sam ama d ′."Ancora una volta, perché in realtà non
Sappi quale cane d ′, dobbiamo (1) dimostrare che ama (sam, d ′) semplicemente
Dalle proprietà che D ′ ha perché è un cane o (2) torna a fare un
Analisi del caso, considerando ogni cane D ′ separatamente.
r Se l'affermazione ∀d ama (sam, d) è vera, allora hai una strategia.
Non importa come gioca l'avversario, non importa quale cane d ′ dà
Tu, Sam lo adora.Quindi, puoi vincere il gioco dimostrandolo
Ama (Sam, D ′).
r Se l'affermazione è falsa, allora c'è un cane d ′ che Sam non ama.
Qualsiasi vero avversario (non solo un amico) produrrà questo cane e lo farai
perso il gioco.Quindi, non puoi avere una strategia vincente.
Prova per contraddizione: una tecnica classica per dimostrare la dichiarazione
∀d loves (sam, d) è la prova per contraddizione.Tranne il modo in cui è espresso, è esattamente lo stesso della prova di un gioco avversario.
A titolo di contraddizione presumi che l'affermazione sia falsa, cioè, ∃d ¬loves (sam, d) è vero.Sia D ′ un cane di questo tipo che Sam non ama.
Quindi devi dimostrare che in effetti Sam ama d ′.Ciò contraddice l'affermazione secondo cui Sam non ama d ′.Quindi, il presupposto iniziale è falso e
∀d loves (sam, d) è vero.
Prova da parte di un gioco contraddittorio per dichiarazioni più complesse: il vantaggio a questo
La tecnica è che si generalizza in un bel gioco per dichiarazioni arbitrariamente lunghe.

---
layout: 
title: Pagina 380
level: 3
---


Appendice
364
I passaggi del gioco:
Da sinistra a destra: il gioco si sposta da sinistra a destra, fornendo un oggetto per
ogni quantificatore.
Prover fornisce ∃b: tu, come Prover, devi fornire eventuali oggetti esistenziali.
L'avversario fornisce ∀D: l'avversario fornisce oggetti universali.
Per vincere, dimostrare la relazione ama (b ′, d ′): una volta che tutti gli oggetti sono stati
a condizione, tu (il prover) devi dimostrare che la relazione più interna è in
Fatto vero.Se puoi, allora vinci.Altrimenti, perdi.
Una prova è una strategia: una prova della dichiarazione consiste in una strategia tale che
Vinci la partita, non importa come gioca l'avversario.Per ogni possibile mossa
Che l'avversario prende, tale strategia deve specificare quale mossa farai
contrastare con.
Negazioni davanti: per dimostrare una dichiarazione con una negazione nella parte anteriore, ha prima messo la dichiarazione in forma standard con la negazione spostata al
Giusto.Quindi prova l'affermazione allo stesso modo.
Esempi:
∃b∀d loves (b, d): per dimostrare "c'è un ragazzo che ama ogni cane", tu
Deve produrre un ragazzo specifico B ′.Quindi l'avversario, conoscendo il tuo ragazzo
B ′, cerca di dimostrare che ∀d loves (b ′, d) è falso.Lo fa fornendo
Un cane arbitrario d ′ che spera che B ′ non ami.Devi dimostrare “B ′
ama d ′. ”
¬ (∃b∀d loves (b, d)) iff ∀b∃d ¬loves (b, d): con la negazione spostata a
Il diritto, il primo quantificatore è universale.Quindi, il primo avversario produce un ragazzo B ′.Quindi, conoscendo il ragazzo dell'avversario, produci un cane d ′.
Infine, dimostri che ¬loves (B ′, D ′).
La tua prova dell'affermazione potrebbe essere vista come una funzione g che
prende come input il ragazzo b ′ dato dall'avversario e produce il cane
d ′ = d (b ′) contrastato da te.Qui, D ′ = D (B ′) è un esempio di un cane che
Boy B ′ non ama.La prova deve dimostrare che ∀b¬loches (b, d (b)).
Esercizio 22.0.1 Let Loves (b, g) indica quel ragazzo B ama la ragazza g.Se Sam ama Maria e
Mary non ama Sam, quindi diciamo che Sam ama invano.
1.
Esprimi le seguenti affermazioni utilizzando quantità universali ed esistenziali.Mossa
eventuali negazioni a destra.
(a) "Sam ha amato invano".
(b) "C'è un ragazzo che ha amato invano".

---
layout: 
title: Pagina 381
level: 3
---


Quantitazioni esistenziali e universali
365
(c) "Ogni ragazzo ha amato invano".
(d) "Nessun ragazzo ha amato invano".
2.
Per ciascuna delle dichiarazioni di cui sopra e ciascuna delle due relazioni di seguito
che l'affermazione è vera per la relazione o che è falsa:
Sam
Bob
Maria
Sam
Maria
Esercizio 22.0.2 (vedere la soluzione nella parte cinque.) Per ciascuno, dimostrare se vero o meno quando
Ogni variabile è un valore reale.Assicurati di giocare al gioco corretto su chi fornisce
Quale valore:
1.
∀x ∃y x + y = 5.
2.
∃y ∀x x + y = 5.
3.
∀x ∃y x · y = 5.
4.
∃y ∀x x · y = 5.
5.
∀x ∃y x · y = 0.
6.
∃y ∀x x · y = 0.
7.
[∀x ∃y p (x, y)] ⇒ [∃y ∀x p (x, y)].
8.
[∀x ∃y p (x, y)] ⇐ [∃y ∀x p (x, y)].
9.
∀a ∃y ∀x x · (y + a) = 0.
10.
∃a ∀x ∃y [x = 0 o x · y = 5].
Esercizio 22.0.3 Il gioco del gioco ha due round.Il giocatore A va prima.Lascia che Ma
1 indica
la sua prima mossa.Il giocatore B va dopo.Lascia che MB
1 indica la sua mossa.Allora il giocatore A va MA
2, e
Il giocatore B va in MB
2.La relazione Awins (MA
1, MB
1, ma
2, MB
2) è il vero giocatore IFF con cui vince
queste mosse.
1.
Usa i quantità universali ed esistenziali per esprimere il fatto che il giocatore ha a
Strategia con cui vince, indipendentemente da ciò che fa il giocatore B.Usa MA
1, MB
1, ma
2, MB
2 AS
variabili.
2.
Quali passaggi sono richiesti nella tecnica Prover -Adoversario per dimostrare questa affermazione?
3.
Qual è la negazione dell'istruzione di cui sopra in forma standard?
4.
Quali passaggi sono richiesti nella tecnica prover -avversario per dimostrare questo negato
dichiarazione?
Esercizio 22.0.4
Perché [∀n0, ∃n> n0, p (n)] implica che ci sia un infinito
Numero di valori n Per cui la proprietà P (n) è vera?

---
layout: 
title: Pagina 382
level: 3
---


366
23 complessità temporale
È importante classificare gli algoritmi in base se risolvono a
Dato il problema computazionale e, in tal caso, quanto velocemente.Allo stesso modo, esso
è importante classificare i problemi computazionali in base se
Possono essere risolti e, in tal caso, quanto velocemente.
23.1
La complessità del tempo (e dello spazio) di un algoritmo
Scopo:
Stimare la durata: stimare per quanto tempo verrà eseguito un algoritmo o un programma.
Stimare la dimensione dell'input: stimare il più grande input che può essere ragionevolmente dato
al programma.
Confronta gli algoritmi: per confrontare l'efficienza di diversi algoritmi per risolvere lo stesso problema.
Parti del codice: per aiutarti a focalizzare la tua attenzione sulle parti del codice che sono
eseguito il maggior numero di volte.Questo è il codice che devi migliorare
ridurre il tempo di esecuzione.
Scegli l'algoritmo: per scegliere un algoritmo per un'applicazione:
r Se la dimensione dell'input non sarà più grande di sei, non perdere tempo a scrivere un
Algoritmo estremamente efficiente.
r Se la dimensione di input è di mille, assicurarsi che il programma sia in fase di tempo polinomiale, non esponenziale.
r Se stai lavorando al progetto GNOME e la dimensione dell'input è un miliardo, quindi
Assicurati che il programma sia in fase di tempo lineare.

---
layout: 
title: Pagina 383
level: 3
---


Complessità temporale
367
Le complessità del tempo e dello spazio sono funzioni, t (n) e s (n): il
tempo
La complessità di un algoritmo non è un singolo numero, ma è una funzione che indica come
Il tempo di esecuzione dipende dalla dimensione dell'input.Lo indichiamo spesso con t (n), dando il numero di operazioni eseguite sull'istanza di input del caso peggiore delle dimensioni
N.Un esempio sarebbe t (n) = 3n2 + 7n + 23. Allo stesso modo, s (n) dà la dimensione del
Memoria riscritta dell'algoritmo richiesto.
Ignorando i dettagli, (t (n)) e O (t (n)): in generale, ignoriamo i termini di basso ordine
Nella funzione t (n) e la costante moltiplicativa davanti.Ignoriamo anche la funzione per piccoli valori di N e ci concentriamo sul comportamento asintotico man mano che N diventa molto
grande.Alcuni dei motivi sono i seguenti.
Modello-dipendente: la costante moltiplicativa davanti al tempo dipende da
Quanto è veloce il computer e sulla definizione precisa di "dimensioni" e "operazione".
Troppo lavoro: contare ogni operazione che l'algoritmo esegue in dettaglio preciso è più lavoro di quanto valga la pena.
Non significativo: è molto più significativo se la complessità del tempo è
T (n) = n2 o t (n) = n3 rispetto al fatto che sia t (n) = n2 o t (n) = 3n2.
Solo grande N Matter: si potrebbe dire che consideriamo solo grandi istanze di input
Nella nostra analisi, perché il tempo di esecuzione di un algoritmo diventa solo un problema
Quando l'ingresso è grande.Tuttavia, il tempo di esecuzione di alcuni algoritmi su piccoli
Le istanze di input sono abbastanza critiche.In effetti, la dimensione N di un'istanza di input realistica
Dipende sia dal problema che dall'applicazione.La scelta è stata fatta
Considera solo grandi n al fine di fornire un matematico pulito e coerente
Definizione.
Vedi il capitolo 25 sulle notazioni Theta e Bigoh.
Definizione della dimensione: la definizione formale della dimensione di un'istanza è il numero
delle cifre binarie (bit) necessarie per codificarlo.Più praticamente, la dimensione potrebbe essere considerata il numero di cifre o caratteri richiesti per codificarlo.Intuitivamente, il
La dimensione di un'istanza potrebbe essere definita come l'area della carta necessaria per scrivere
l'istanza o il numero di secondi necessari per comunicare l'istanza
un canale stretto.Queste definizioni sono tutte all'interno di una costante moltiplicativa di ciascuno
altro.
Un numero intero: supponiamo che l'input sia il valore n = 8.398.346.386.236.876.IL
Numero di bit richiesti per codifica è dimensione (n) = log2 (n) = log2 (8.398.346, 386.236.876) = 53 e il numero di cifre decimali è dimensione (n) = log10 (8.398, 346.386.236.876) = 16.Spiega perché questi si trovano all'interno di una costante moltiplicativa l'una dell'altra.L'unica definizione che non è necessario utilizzare è il valore

---
layout: 
title: Pagina 384
level: 3
---


Appendice
368
del numero intero, dimensione (n) = n = 8.398.346.386.236.876, perché è esponenzialmente
diverso dalla dimensione (n) = log2 (n) = 53.
A tupla: supponiamo che l'input sia la tupla dei numeri interi B i = ⟨x1, x2 ,..., xb⟩.
Il numero di bit richiesti per codifica è dimensione (i) = log2 (x1) + log2 (x2) + · · · +
log2 (xb) ≈log2 (xi) · b.Una definizione naturale delle dimensioni di questa tupla è il numero
di numeri interi in esso, dimensione (i) = b.Con questa definizione, è un'affermazione molto più forte
dire che un algoritmo richiede solo tempo (b) operazioni intera indipendenti da
Quanto sono grandi gli interi.
Un grafico: supponiamo che l'ingresso sia il grafico g = ⟨v, e⟩with | v |nodi e | e |
bordi.Il numero di bit richiesti per codifica è dimensione (g) = 2 dimensioni (nodo) · | e |=
2 log2 (| v |) · | e |.Un'altra definizione ragionevole della dimensione di G è il numero di
bordi, g (n) = | e |.Spesso il tempo è dato in funzione di entrambi | v |e | e |.Questo
è all'interno di un fattore di registro delle altre definizioni, che per la maggior parte delle applicazioni è
infine.
Definizione di un'operazione: la definizione di un'operazione può essere ragionevole
operazione su due bit, caratteri, nodi o numeri interi, a seconda che il tempo sia
misurato in bit, caratteri, nodi o numeri interi.Un'operazione potrebbe anche essere definita
essere qualsiasi linea di codice ragionevole o il numero di secondi che il calcolo
Assume il tuo computer preferito.
Quale input: t (n) è il numero di operazioni richieste per eseguire l'algoritmo dato su un input di dimensioni n.Tuttavia, ci sono 2N istanze di input con n bit.Qui
sono tre possibilità:
Un input tipico: il problema con la considerazione di un'istanza di input tipica questo è
che diverse applicazioni avranno input tipici molto diversi.
Caso medio o previsto: il problema con la media su tutti gli input
istanze di dimensione n è che presuppone che tutte le istanze siano ugualmente probabili
verificarsi.
Caso peggiore: la solita misura è considerare l'istanza della dimensione n su cui il
Dato l'algoritmo è il più lento, vale a dire, t (n) = maxi∈ {i || I | = n} time (i).Questa misura fornisce una bella definizione matematica pulita ed è la più semplice da analizzare.
L'unico problema è che a volte l'algoritmo fa molto meglio del
caso peggiore, perché il caso peggiore non è un input ragionevole.Uno di questi algoritmo
è rapido (vedere la sezione 9.1).
Complessità temporale di un problema: la complessità temporale di un problema è la corsa
Tempo dell'algoritmo più veloce che risolve il problema.

---
layout: 
title: Pagina 385
level: 3
---


Complessità temporale
369
Esempio 23.1
Tempo polinomiale vs tempo esponenziale
Supponiamo che il programma P1 richieda T1 (N) = N4 Operations e P2 richiede T2 (N) = 2N.Supponiamo che la macchina esegui 106 operazioni al secondo.Se n = 1.000, qual è il
tempo di esecuzione di questi programmi?
Risposta:
1. T1 (N) = (1.000) 4 = 1012 operazioni, che richiedono 106 secondi o 11,6 giorni.
2. Operazioni T2 (N) = 2 (103).Il numero di anni è
2 (103)
106 × 60 × 60 × 24 × 365.Questo è troppo grande
per il mio calcolatore.Il registro di questo numero è 103 × log10 (2) −log10 106 −log10 (60 ×
60 × 24 × 365) = 301,03 −6 −7,50 = 287,53.Pertanto, il numero di anni è
10287.53 = 3.40 × 10287. Non aspettare.
Esempio 23.2
Dimensione dell'istanza N vs Valore dell'istanza n
Due semplici algoritmi, somma e factoring.
I problemi e gli algoritmi:
Somma: l'attività è di sommare le voci N di un array, cioè a (1) + a (2) +
A (3) + · · · + A (N).
Factoring: il compito è trovare i divisori di un numero intero N., sull'input n =
5917 Output che n = 97 × 61. (Questo problema è fondamentale per la crittografia.) Il
L'algoritmo controlla se n è divisibile di 2, per 3, di 4 ,...di N.
Tempo: entrambi gli algoritmi richiedono operazioni T = N (aggiunte o divisioni).
Quanto è difficile?L'algoritmo di somma è considerato molto veloce, mentre il factoring
L'algoritmo è considerato che richiede molto tempo.Tuttavia, entrambi gli algoritmi prendono
T = n tempo per completare.La complessità temporale di questi algoritmi spiegherà il perché.
Valori tipici di N: In pratica, la N per il factoring è molto più grande di quella per somma.Anche se si somma tutte le voci sull'intero disco rigido da 8 g di byte, allora è
Ancora solo N ≈1010.D'altra parte, i militari vogliono fare conto di numeri interi N ≈10100.
Tuttavia, la misura della complessità di un algoritmo non dovrebbe basarsi su come esso
capita di essere usato in pratica.
Dimensione dell'ingresso: l'ingresso per la somma contiene è n. ≈32n bit.L'input per
Il factoring contiene è n = log2 n bit.Pertanto, con qualche centinaio di bit puoi scrivere
Down un esempio di factoring difficile che è apparentemente impossibile da risolvere.
Complessità del tempo: il tempo di esecuzione della somma è t (n) = n =
1
32n, che è lineare
Nella sua dimensione di input.Il tempo di esecuzione del factoring è t (n) = n = 2n, che è esponenziale
Nella sua dimensione di input.Questo è il motivo per cui l'algoritmo di somma è considerato fattibile, mentre
L'algoritmo di factoring è considerato impossibile.

---
layout: 
title: Pagina 386
level: 3
---


Appendice
370
Esercizio 23.1.1 (vedere la soluzione nella parte cinque.) Per ciascuno dei due programmi considerati
Nell'esempio 23.1, se vuoi che completi in 24 ore, quanto è grande il tuo contributo?
Esercizio 23.1.2 Nell'esempio 23.1, per quali dimensioni di input, approssimativamente, i programmi hanno gli stessi tempi di esecuzione?
Esercizio 23.1.3 Questo problema confronta i tempi di esecuzione dei seguenti due algoritmi per moltiplicare:
Algoritmo asilo nido (a, b)
⟨Pre-Cond⟩: a e b sono numeri interi.
⟨Post-Cond⟩: emette a × b.
inizio
c = 0
Loop i = 1...UN
c = c + b
End Loop
restituzione (c)
Algoritmo di fine
Algoritmo Gradeschooladd (A, B)
⟨Pre-Cond⟩: a e b sono numeri interi.
⟨Post-Cond⟩: emette a × b.
inizio
Lascia che AS - 1...a3a2a1a0 essere le cifre decimali di a, in modo che a = s - 1
i = 0 Ai × 10i.
Lascia che Bt - 1...b3b2b1b0 essere le cifre decimali di b, in modo che b = t - 1
J = 0 BJ × 10J.
c = 0
Loop i = 1...S
Loop j = 1...T
C = C + Aibj × 10i + J.
End Loop
End Loop
restituzione (c)
Algoritmo di fine
Per ciascuno di questi algoritmi, rispondere alle seguenti domande.
1.
Supponiamo che ogni aggiunta a C richieda tempo 10 secondi e ogni altra operazione
(Ad esempio, moltiplicando due singole cifre come 9 × 8 e spostamento di zero)
gratuito.Qual è il tempo di esecuzione di ciascuno di questi algoritmi, sia in funzione di
A e B o in funzione di S e T?Dai tutto per tutta questa domanda, cioè non bigoh.

---
layout: 
title: Pagina 387
level: 3
---


Complessità temporale
371
2.
Lascia che a = 9.168.391 e b = 502. (Senza consegnarlo, traccia l'algoritmo.) Con
10 secondi per aggiunta, quanto tempo (secondi, minuti, ecc.) Richiede il calcolo?
3.
La dimensione formale di un'istanza di input è il numero di bit necessari per scriverlo.
Che cosa è n in funzione della nostra istanza ⟨a, b⟩?
4.
Supponiamo che il tuo compito sia scegliere l'istanza del caso peggiore ⟨a, b⟩ (cioè, quella che massimizza il tempo di esecuzione), ma sei limitato in quanto puoi usare solo n bit per
rappresenta la tua istanza.Imposta un grande e b piccolo, un piccolo e b grande, o a e
b le stesse dimensioni?Dare il caso peggiore a e b, o s e t, in funzione di n.
5.
Il tempo di esecuzione di un algoritmo è formalmente definito essere una funzione t (n) da n
al tempo richiesto per il calcolo sull'istanza peggiore della dimensione n.Dare
T (n) per ciascuno di questi algoritmi.È questo tempo polinomiale?
Esercizio 23.1.4 (vedi soluzione nella quinta parte.) Supponiamo che qualcuno abbia sviluppato un
Algoritmo per risolvere un certo problema, che funziona nel tempo t (n, k) ∈ (f (n, k)), dove
n è la dimensione dell'input e k è un parametro che siamo liberi di scegliere (possiamo sceglierlo
dipendere da n).In ciascun caso determinare il valore del parametro k (n) per ottenere il
(asintoticamente) Il miglior tempo di esecuzione.Giustifica la tua risposta.Consiglio di non provare molto
Matematica fantasiosa.Pensa a N come a un numero di grandi dimensioni.Prova un po 'di valore di k, diciamo k = 1, k = na o k = 2an per qualche costante a.Quindi notare se aumentare o diminuire
K aumenta o diminuisce f.Ricordiamo che "asintoticamente" significa che abbiamo solo bisogno del
minimo a all'interno di una costante moltiplicativa.
1.
Potresti voler dimostrare che g + h = (max (g, h)).
2.
f (n, k) = n+k
Log k.Questo è necessario per l'ordinamento Radix - Contaggio nella Sezione 5.4.
3.
f (n, k) = n3
K + K · n.
4.
f (n, k) = log3 k + 2n
K .
5.
f (n, k) = 8nn2
K
+ k · 2n + k2.
23.2
La complessità temporale di un problema computazionale
La definizione formale della complessità del tempo di un problema: come detto, il tempo
La complessità di un problema è il tempo di esecuzione dell'algoritmo più veloce che risolve il
problema.Ora lo definiremo più attentamente, usando l'esistenziale e universale
Quantiochi che sono stati definiti nel capitolo 22.
La complessità temporale di un problema: la complessità temporale di un computazionale
Il problema P è il tempo minimo necessario da un algoritmo per risolverlo.
Upper Bound: il problema P si dice che sia calcolabile nel tempo t
superiore (n) se c'è
Un algoritmo A che emette la risposta corretta, vale a dire a (i) = p (i), all'interno

---
layout: 
title: Pagina 388
level: 3
---


Appendice
372
Il tempo limitato, vale a dire il tempo (a, i) ≤t
Upper (| i |), su ogni istanza di input
I. L'istruzione formale è
∃a, ∀i, [a (i) = p (i) e tempo (a, i) ≤tupper (| i |)]
Si dice che Tupper (N) sia solo un limite superiore sulla complessità del problema
P, perché potrebbe esserci un altro algoritmo che funziona più velocemente.Ad esempio, P = l'ordinamento è calcolabile nel tempo di Tupper (N) = O (N2).È anche calcolabile
in tupper (n) = o (n logn).
Limite inferiore di un problema: un limite inferiore sul tempo necessario per risolvere un
Il problema afferma che non importa quanto tu sia intelligente, non puoi risolvere il problema più velocemente del tempo dichiarato tlower (n), perché tale algoritmo lo fa semplicemente
non esiste.Potrebbero esserci algoritmi che forniscono la risposta corretta o eseguono sufficientemente rapidamente su alcune istanze di input.Ma per ogni algoritmo, c'è a
almeno un istanza I per il quale l'algoritmo dà la risposta sbagliata, cioè a (i) ̸ = p (i), oppure ci vuole troppo tempo, cioè tempo (a, i) ≥tlower (| i |).IL
L'istruzione formale è la negazione (ad eccezione di ≥vs>) di quella per la parte superiore
limite:
∀a, ∃i, [a (i) ̸ = p (i) o tempo (a, i) ≥tlower (| i |)]
Ad esempio, dovrebbe essere chiaro che nessun algoritmo può ordinare solo i valori
Tlower = √n tempo, perché in quel tanto tempo l'algoritmo non poteva nemmeno
Guarda tutti i valori.
Prove che utilizzano il gioco prover -avversario: ricorda la tecnica descritta in
Capitolo 22 per la prova di dichiarazioni con quantità esistenziali e universali.
Upper Bound: possiamo usare il gioco prover -avversario per dimostrare la tomaia
Dichiarazione vincolata ∃a, ∀i, [a (i) = p (i) e tempo (a, i) ≤tupper (| i |)] come segue: tu, il prover, fornisci l'algoritmo A.
Un input I. Quindi devi dimostrare che la tua A su input i fornisce l'output corretto nel tempo assegnato.Nota Questo è quello che abbiamo fatto in tutto il
Libro: fornire algoritmi e dimostrare che funzionano.
Legato inferiore: una prova del limite inferiore ∀a, ∃i, [a (i) ̸ =
P (i) o tempo
(A, i) ≥Tlower (| i |)] è costituito da una strategia che, quando viene dato un algoritmo A di
Un avversario, tu, il prover, studia il suo algoritmo e fornisci un input I.
Quindi dimostri che la sua A su input i dà l'output sbagliato o che esso
funziona in più del tempo assegnato.
Esercizio 23.2.1 (vedi soluzione nella parte quinta.) Lascia che le opere (p, a, i) a vere se algoritmo
Un arresto e risolve correttamente il problema p sull'istanza di input I. Sia p = l'arresto sia il
fermare il problema che richiede un programma Java I come input e ti dice se questo
si ferma sulla stringa vuota.Sia P = l'ordinamento sia il problema di smistamento che prende un elenco di

---
layout: 
title: Pagina 389
level: 3
---


Complessità temporale
373
Numeri I come input e li ordina.Per ogni parte, spiega il significato di ciò che tu
stanno facendo e perché non lo fai in un altro modo.
1.
Ricordiamo che un problema è calcolabile se e solo se esiste un algoritmo che si ferma
e restituisce la soluzione corretta su ogni input valido.Espressa logica di primo ordine
Quell'ordinamento è calcolabile.
2.
Espresse logica di primo ordine che l'arresto non è calcolabile.
3.
Espresse logica di primo ordine secondo cui ci sono problemi non pubblicabili.
4.
Spiega cosa significhi il seguente (non semplicemente dicendo lo stesso con parole), e
o dimostrarlo: ∀i, ∃a, Works (Halting, a, i).
5.
Spiega cosa significhi i seguenti, e dimostralo o smentito: ∀a, ∃p, ∀i, opere (p, a, i).(Suggerimento: un algoritmo A su un input posso fermarmi e dare il
Risposta corretta, fermare e dare la risposta sbagliata o correre per sempre.)

---
layout: 
title: Pagina 390
level: 3
---


374
24 logaritmi ed esponenziali
Logaritmi log2 (n) e esponenziali 2n si presentano spesso quando si analizzano gli algoritmi.
Usi: questi sono alcuni dei luoghi che li vedrai.
Dividi un numero logaritmico di volte: molti algoritmi tagliano ripetutamente l'istanza di input a metà.Un esempio classico è la ricerca binaria (sezione 1.4): prendi
qualcosa di taglia N e lo tagli a metà, quindi taglia una di queste metà
metà e uno di questi a metà e così via.Anche per un oggetto iniziale molto grande, esso
Non richiede molto tempo fino a quando non si ottiene un pezzo di taglia inferiore a 1. Il numero di divisioni richieste riguarda il log2 (n).Qui la base 2 è perché li stai tagliando
a metà.Se dovessi tagliarli in terzi, allora il numero di volte da tagliare lo farebbe
riguardare log3 (n).
Un numero logaritmico di cifre: i logaritmi sono utili anche perché la scrittura
verso il basso un dato valore intero n richiede ⌈log10 (n + 1) ⌉ cifre decimali.Ad esempio, supponiamo che n = 1.000.000 = 106. Dovresti dividere questo numero per 10 sei
tempi per arrivare a 1. Quindi, per definizione, log10 (n) = 6. Questo, tuttavia, è il numero di zeri, non il numero di cifre.Abbiamo dimenticato la cifra principale 1. la formula
⌈Log10 (n + 1) ⌉ = 7 fa il trucco.Per il valore n = 6.372.845, il numero di cifre è dato da Log10 (6.372.846) = 6.804333, arrotondato fino a 7. Essere sul computer
Science, archiviamo i nostri valori usando bit.Argomenti simili danno che ⌈log2 (n + 1) ⌉
è il numero di bit necessari.
Altezza e dimensione dell'albero binario: un albero binario bilanciato completo di altezza H ha
2h foglie e n = 2H+1 −1 nodi.Al contrario, se ha n nodi, allora la sua altezza è
H ≈log2 n.
Ricerca esponenziale: supponiamo che una soluzione al tuo problema sia rappresentata da n cifre.Ci sono 10 N di tali stringhe di n cifre.Fare una ricerca cieca attraverso tutti loro
richiederebbe troppo tempo.

---
layout: 
title: Pagina 391
level: 3
---


Logaritmi ed esponenziali
375
Regole: ci sono molte regole su registri ed esponenziali che si potrebbero imparare.Personalmente, mi piace confinarli a quanto segue:
bn =
N



B × B × B × · · · × B: questa è la definizione dell'esponentezione.BN è moltiplicato da N B insieme.
bn × bm = bn+m: questo è dimostrato semplicemente contando il numero di B
moltiplicato:
(
N



B × B × B × · · · × B) × (
M



B × B × B × · · · × B) =
n+m



B × B × B × · · · × B.
b0 = 1: si potrebbe immaginare che lo zero b si moltiplica insieme è zero, ma deve farlo
Sii uno.Un argomento per questo è il seguente.bn = b0+n = b0 × bn.Per questo
È vero, B0 deve essere uno.
B
1
2 = √n: per definizione, √n è il numero positivo che se moltiplicato da solo
dà n.B
1
2 incontra questa definizione perché B
1
2 × b
1
2 = b
1
2 + 1
2 = b1 = b.
b - n = 1/bn: il fatto che questo deve essere vero può essere discusso in modo simile.
1 = bn+( - n) = bn × b - n.Perché questo sia vero, B -N deve essere 1/bn.
(bn) m = bn × m: di nuovo contiamo il numero di B:
M



(
N



B × B × B × · · · × B) × (
N



B × B × B × · · · × B) × · · · × (
N



B × B × B × · · · × B)
=
n × m



B × B × B × · · · × B.
Se x = logb (n) allora n = bx: questa è la definizione dei logaritmi.
logb (1) = 0: questo segue da B0 = 1.
logb (bx) = x e blogb (n) = n: sostituire n = bx in x = logb (n) dà il primo e sostituendo x = logb (n) in n = bx dà il secondo.
logb (n × m) = logb (n) + logb (m): il numero di cifre per scrivere il prodotto di due numeri interi è il numero per scrivere ciascuno di essi separatamente (su
agli errori di arrotondamento).Lo dimostriamo applicando la definizione dei logaritmi e
Le regole sopra: blogb (n × m) = n × m = blogb (n) × blogb (m) = blogb (n)+logb (m).Segue
che logb (n × m) = logb (n) + logb (m).
logb (nd) = d × logb (n): questa è un'estensione della regola sopra.
logb (n) −logb (m) = logb (n) + logb (1
m) = logb (n
m): questa è un'altra estensione del
Sopra la regola.
DCLOG2 (N) = NCLOG2 (D): questa regola afferma che puoi spostare le cose tra la base
e l'esponente fintanto che si inserisce o rimuovi un registro.La prova è la seguente.

---
layout: 
title: Pagina 392
level: 3
---


Appendice
376
dc log2 (n) = (2log2 (d)) c log2 (n) = 2log2 (d) × c log2 (n) = 2log2 (n) × c log2 (d) = (2log2 (n)) c log2 (d) =
NC log2 (d).
log2 (n) = 3.32...× log10 (n): il numero di bit necessari per esprimere l'intero n
è 3,32 ... volte il numero di cifre decimali necessarie.Questo può essere visto come segue.
Supponiamo x = log2 n.Quindi n = 2x, dando log10 n = log10 (2x) = x · log10 2. infine, x =
1
log10 2 log10 (n) = 3.32...log10 n
Quale base: scriveremo (log (n)) senza dare una base esplicita.Una scuola superiore
Lo studente potrebbe usare la base 10 come impostazione predefinita, una base scienziata E = 2,718...e una base di informatica 2. La mia politica è quella di escludere la base quando non ha importanza.COME
Visto sopra, log10 (n), log2 (n) e loge (n) differiscono solo per costanti moltiplicative.In
Generale, ignoriamo le costanti moltiplicative e quindi la base utilizzata è irrilevante.IO
Includi la base solo quando la base è importante.Ad esempio, 2n e 10n differiscono di molto
più di una costante moltiplicativa.
Il log del rapporto a
Log B: quando si calcola il rapporto tra due logaritmi, la base utilizzata
non importa, perché cambiare la base introdurrà la stessa costante su entrambi
La parte superiore e il fondo, che si annulleranno.Quindi, quando si calcola un tale rapporto, tu
può scegliere qualunque base rende il calcolo più semplice.Ad esempio, per calcolare il registro 16
Log 8, la base ovvia da usare è 2, perché log2 16
log2 8 = 4
3. D'altra parte, per calcolare il registro 9
Log 27, la base ovvia da usare è 3, perché log3 9
log3 27 = 2
3.
Esercizio 24.0.1 (vedi soluzione nella parte cinque.) Semplificare i seguenti esponenziali: A3 ×
A5, 3A × 5A, 3A + 5A, 26 Log4 N + 7, N3/ Log2 N.

---
layout: 
title: Pagina 393
level: 3
---


377
25 Crescita asintotica
Classi di tassi di crescita: è importante essere in grado di classificare le funzioni f (n)
Su quanto velocemente crescono: la seguente tabella delinea le poche semplici regole con cui
Per classificare le funzioni con il modulo di base f (n) = (Ban · nd · Logen).
C
ba
D
e
Classe

Esempi
> 0
> 1
Qualunque
Qualunque
Esponenziali
2 (N)
2n, 30.001n
N100
= 1
> 0
Qualunque
Polinomi:
n (1)
N4, 5N0.0001
log100 (n)
= 2
Qualunque
r quadratico
(N2)
5n2, 2n2 + 7n + 8
= 1
= 1
tempo di smistamento
(n logn)
5n logn + 3n
= 1
= 0
r lineare
(N)
5n + 3
= 0
> 0
Polilogaritmi:
Log (1) (N)
5 log3 (n)
= 1
r logaritmi
(Logn)
5 log (n)
= 0
Costanti
(1)
5, 5 + sinn
<0
Qualunque
Polinomi in diminuzione
1
n (1)
1
N4, 5 log100 (N)
N0.0001
<1
Qualunque
Qualunque
Esponenziali in diminuzione
1
2 (1)
1
2n, N100
30.001n
Notazione asintotica: quando vogliamo limitare la crescita di una funzione mentre
Ignorando le costanti moltiplicative, utilizziamo la seguente notazione:
Nome
Notazione standard
La mia notazione
Senso
Theta
f (n) = (g (n))
f (n) ∈ (g (n))
f (n) ≈c · g (n)
Bigoh
f (n) = o (g (n))
f (n) ≤o (g (n))
f (n) ≤c · g (n)
Omega
f (n) = (g (n))
f (n) ≥ (g (n))
f (n) ≥c · g (n)

---
layout: 
title: Pagina 394
level: 3
---


Appendice
378
Scopo:
Complessità temporale: in generale, le funzioni che classificheremo saranno le
complessità tempo o spaziali dei programmi.D'altra parte, queste idee possono anche
essere utilizzato per classificare qualsiasi funzione.
Crescita della funzione: lo scopo di classificare una funzione è dare un'idea di come
Veloce cresce senza andare troppo nei dettagli.
Tasso di crescita asintotico: quando si classificavano gli animali, Darwin ha deciso di non considerare se l'animale dorme durante il giorno, ma di considerare se ha i capelli.
Quando si classificano le funzioni, i teorici della complessità hanno deciso di non considerare il suo comportamento per piccoli valori di N o anche se sta aumentando il monotono, ma quanto velocemente
Cresce quando il suo input N diventa davvero grande.Questo è indicato come gli asintotici del
funzione.Ecco alcuni esempi di diversi tassi di crescita:
Valore approssimativo di t (n) per n =
Funzione
T (n)
10
100
1.000
10.000
Animale
5
5
5
5
5
Virus
log2 n
3
6
9
13
Ameba
√n
3
10
31
100
Uccello
N
10
100
1.000
10.000
Umano
n logn
30
600
9.000
130.000
Gigante
N2
100
10.000
106
108
Elefante
N3
1.000
106
109
1012
Dinosauro
2n
1.024
1030
10300
103000
L'universo
Nota: l'universo contiene circa 1080 particelle.
Polinomio esponenziale vs: la tabella mostra che una funzione esponenziale come
f (n) = 2n cresce molto rapidamente.In effetti, per sufficientemente grande N, questo esponenziale
2n cresce molto più velocemente di qualsiasi polinomio, anche N1.000.000.Per portarlo all'estremo, la funzione f (n) = 20.001n è anche esponenziale.Anche questo cresce molto più velocemente
di N1.000.000 per n.
Polinomiale vs logaritmico: la tabella mostra anche che una funzione logaritmica come
f (n) = log2 n cresce, ma molto lentamente.Quindi, per sufficientemente grande n, è più grande
di qualsiasi costante, ma più piccolo di qualsiasi polinomio.
Esercizio 25.0.1
Dai un valore di n per il quale N1.000.000 <10n.
Dai un valore di n per il quale N1.000 <100,001N.
Esercizio 25.0.2
Dai un valore di n per il quale (log10 n) 1.000.000 <n.
Dai un valore di n per il quale (log10 N) 1.000 <n0,001.

---
layout: 
title: Pagina 395
level: 3
---


Crescita asintotica
379
25.1
Passaggi per classificare una funzione
Data una funzione f (n), la classificheremo in base alla sua crescita usando quanto segue
Passi.
1) Metti F (n) in forma di base: sebbene ci siano strane funzioni là fuori, la maggior parte
le funzioni f (n) possono essere inserite in una forma di base costituita dalla somma di un numero di
Termini, dove ogni termine ha la forma di base c · ban · nd · (logn) e, dove a, b, c, d ed e
sono vere costanti.
Esempi:
R se f (n) = 3 · 24n · n7 · (logn) 5, quindi a = 4, b = 2, c = 3, d = 7 ed e = 5.
R Supponiamo f (n) = n2.Questo non ha divieto di parte esponenziale, ma può essere visto come
Avere a = 0 o b = 1 o AB = 1. (richiamo x0 = 1 e 1x = 1.) L'esponente
Sul polinomile è d = 2. Non esiste un fattore logaritmico, quindi abbiamo E = 0.
Infine, la costante di fronte è c = 1.
r in f (n) = 1/n6 = n - 6, è anche utile vedere che d = −6.
R se f (n) = n2/ logn + 5, allora la funzione ha due termini.Nel primo, AB = 1, C = 1, D = 2 ed E = −1.Nel secondo, AB = 1, C = 5, D = 0 ed E = 0.
2) Ottieni la crescita di grande immagine: classifichiamo l'insieme di tutti gli animali vertebrati
mammiferi, uccelli, rettili e così via.Allo stesso modo, classificheremo le funzioni nei gruppi principali esponenziali 2 (n), polinomi N (1), log di polilogaritmi (1) (n) e costanti (1).
Esponenziali 2 (n): se la funzione f (n) è la somma di un mucchio di cose, una di
che è c · ban · nd · (logn) e, dove Ba> 1, quindi f (n) è considerato un esponenziale.
Esempi inclusi:
r f (n) = 2n e f (n) = 35n
r f (n) = 2n · n2 log2 n −7n8 e f (n) = 2n
N2
Esempi non inclusi:
r f (n) = 1n = 20 · n = 1, f (n) = 2−1 · n =
1
2
n, e
f (n) = n1.000.000
(pure
piccolo)
r f (n) = n!≈nn = 2n log2 n e f (n) = 2n2 (troppo grande)
Definizione di un algoritmo impossibile: un algoritmo è considerato impossibile se funziona in tempo esponenziale.Questo perché tali funzioni crescono
Molto rapidamente quando N diventa più grande.
(ba) n: abbiamo bisogno di b a> 1 perché ban = (ba) n, che cresce fino a lungo il
Base BA è almeno una.
La notazione 2 (n): vedremo più tardi che (1) indica qualsiasi costante maggiore
che zero.La notazione 2 (n) = 2 (1) · n viene utilizzata per rappresentare la classe di

---
layout: 
title: Pagina 396
level: 3
---


Appendice
380
esponenziali, perché ban = 2 (a log2 b) · n e costante a log2 b = log2 (ba) è
maggiore di zero fintanto che BA è maggiore di 1. Registra log2 1 = 0.
Limitato tra: per queste regole, f (n) = c · ban · nd · (logn) e è esponenziale
Se Ba> 1, non importa quali siano le costanti C, D, E e F.Considera f (n) =
2N/N100.La regola afferma che è un esponenziale perché Ba = 21> 1 e D =
−100.Potremmo metterlo in discussione, pensando che dividere per N100 non lo permetterebbe
crescere abbastanza più velocemente da essere considerato un esponenziale.Vediamo che lo fa
crescere abbastanza velocemente dimostrando che è delimitato tra i due esponenziali
Funzioni 20.5n e 2n.
Polinomiale n (1): se f (n) = c · ban · nd · (logn) e è tale che ba = 1, allora possiamo
Ignora il divieto, dando f (n) = c · nd · (logn) e.Se d> 0, la funzione f (n) è considerata un polinomio.
Esempi inclusi:
r f (n) = 3n2 e f (n) = 7n2 −8n logn + 2n −17
r f (n) = √n = n1/2 e f (n) = n3.1
r f (n) = n2 log2 n e f (n) =
N2
log2 n
r f (n) = 7n3 log7 n −8n2 logn + 2n −17
Esempi non inclusi:
r f (n) = n0 = 1, f (n) = n - 1 = 1
n e f (n) = logn (troppo piccolo)
r f (n) = nlogn e f (n) = 2n (troppo grande)
Definizione di un algoritmo fattibile: un algoritmo è considerato fattibile
Se funziona in tempo polinomiale.(Questo non è in realtà vero se f (n) = n1.000.000.)
La notazione n (1): (1) indica qualsiasi costante maggiore di zero, e quindi
n (1) rappresenta qualsiasi funzione f (n) = nd dove d> 0.
Limitato tra: sebbene non sarebbe considerato uno in uno studio matematico dei polinomi, consideriamo anche f (n) = 3n2 logn come un polinomio, perché è delimitato tra N2 e N3, che chiaramente sono polinomiali.
Polylogarithms Log (1) (N): i poteri di tronchi come (Log) 3 sono indicati come polilogaritmi.Questi sono spesso scritti come log3 n = (logn) 3.Questo è diverso da
Log (N3) = 3 Logn.
Esempio incluso:
r f (n) = 7 (log2 n) 5, f (n) = 7 log2 n e f (n) = 7

log2 n
r f (n) = 7 (log2 n) 5 + 6 (log2 n) 3 −19 + 7 (log2 n) 2/n

---
layout: 
title: Pagina 397
level: 3
---


Crescita asintotica
381
Esempio non incluso:
r f (n) = n (troppo grande)
Costanti (1): una funzione costante è quella la cui uscita non dipende da
il suo input, ad esempio, f (n) = 7. Un algoritmo per il quale si presenta questa funzione
Fare un elemento da uno stack che viene archiviato come elenco collegato.Questo richiede forse
Sette operazioni, indipendenti dal numero N di elementi nello stack.
La notazione n (1): usiamo la notazione (1) per sostituire qualsiasi costante quando
Non ci interessa quale sia la costante reale perché determinare se
IS 7, 9 o 8.829 potrebbe essere più lavoro e più dettagli di quanto abbiamo bisogno.Sul
Altro mano, nella maggior parte delle applicazioni è negativo [f (n) = −1] o zero [f (n) =
0] sarebbe una questione piuttosto diversa.Quindi, questi sono esclusi.
Limitato tra: una funzione come f (n) = 8 + sinn cambia continuamente
tra 7 e 9 e f (n) = 8 + 1
n cambia continuamente sull'avvicinarsi
8. Tuttavia, se non ci interessa se è 7, 9 o 8.829, perché dovremmo preoccuparci se
sta cambiando tra loro?Quindi, entrambe queste funzioni sono incluse in
(1).D'altra parte, la funzione f (n) = 1
n non è incluso, perché il
Solo costante che sia limitato di seguito da è zero e la funzione zero non lo è
incluso.
Esempi inclusi:
r f (n) = 7 e f (n) = 8.829
r f (n) = 8 + sinn, f (n) = 8 + 1
N
Esempi non inclusi:
r f (n) = −1 e f (n) = 0 (fallisce c> 0)
r f (n) = sinn (fallisce c> 0)
r f (n) = 1
n (troppo piccolo)
r f (n) = log2 n (troppo grande)
3) Determinare (f (n)): classifichiamo ulteriormente i mammiferi in esseri umani, gatti, cani e così
SU.Allo stesso modo, classifichiamo ulteriormente i polinomi N (1) in funzioni lineari (N), il
Tempo per l'ordinamento (N Log), quadratics (N2) e così via.Queste sono classi che ignorano
La costante moltiplicativa.
Passaggi: uno "prende il theta" di una funzione f (n) facendo cadere i termini di ordine basso
e quindi far cadere la costante moltiplicativa C di fronte al termine più grande.
Lasciare cadere termini di ordine basso: se f (n) è un insieme di cose aggiunte o sottratte insieme, ognuna di queste cose è chiamata termine.Determiniamo quale del
I termini crescono più velocemente man mano che N diventa grande.I termini che coltivano più lenti sono indicati
come termini di ordine basso.Li lasciamo cadere perché non sono significativi.

---
layout: 
title: Pagina 398
level: 3
---


Appendice
382
Termini di ordinazione: il termine in più rapida crescita è determinato dalla prima presa
il termine c · ban · nd · (logn) e con il più grande valore BA.Se il BA dei termini
sono uguali, quindi prendiamo il termine con il valore D più grande.Se sono i D.
Inoltre, quindi prendiamo il termine con il valore E più grande.
Lasciare cadere la costante moltiplicativa: il tempo di esecuzione di un algoritmo
potrebbe essere f (n) = 3n2 o f (n) = 100n2.Diciamo che è (n2) quando non lo facciamo
CURA CHE COSA COSTANTE CHILIPLICATIVE C.La funzione f (n) = c · ban · nd ·
(logn) e è nella classe di funzioni indicate (ban · nd · (logn) e).
Esempi di funzioni:
r f (n) = 3n3 logn −1000n2 + n −29 è nella classe (N3 logn).
r f (n) = 7 · 4n · n2/ log3 n + 8 · 2n + 17 · n2 + 1000 · n è in classe (4n · n2/
log3 n).
R
1
N + 18 è nella classe (1).Dal 1
n è un termine di ordine inferiore a 18, viene lasciato cadere.
R
1
N2 + 1
n è in classe (1
n), perché 1
N2 è un termine più piccolo.
Esempi di lezioni:
Funzioni lineari (N): la classica funzione lineare è f (n) = c · n + b.IL
la notazione (n) esclude qualsiasi con c ≤0 ma include qualsiasi funzione che è
delimitato tra due di queste funzioni.
Cosa si può fare in (n) tempo: dato un input di n.
tempo semplicemente per guardare l'input.Looping sugli oggetti e fare un
La quantità costante di lavoro per ciascuno richiede un altro (n) tempo.Dire che prendiamo
T1 (N) = 2n e T2 (N) = 4N per un totale di 6N.Ora se non vuoi
Per fare più del tempo lineare, puoi fare più lavoro?Sicuro.
Puoi fare qualcosa che takest3 (n) = 3n tempo e qualcos'altro che
Prende T4 (n) = 5n Tempo.Ti è persino permesso di fare alcune cose che prendono
una quantità costante di tempo, totale dire T5 (n) = 13. L'intero algoritmo
Quindi prende la somma di questi, t (n) = 14n + 13 tempo.Questo è ancora considerato
essere tempo lineare.
Esempi inclusi:
r f (n) = 7n e f (n) = 8.829n
r f (n) = (8 + sinn) n e f (n) = 8n + log10 n + 1
n -1.000.000
Esempi non inclusi:
r f (n) = −n e f (n) = 0n (fallisce c> 0)
r f (n) =
N
log2 n (troppo piccolo)
r f (n) = n log2 n (troppo grande)
Funzioni quadratiche (N2): due loop nidificati da 1 a N Prendi (N2) tempo se
Ogni iterazione interna richiede un tempo costante di tempo.Una matrice N × N richiede uno spazio (N2) se ogni elemento assume spazio costante.

---
layout: 
title: Pagina 399
level: 3
---


Crescita asintotica
383
Tempo per l'ordinamento, (n log n): un altro tempo di esecuzione che si presenta spesso in algoritmi è (n logn).Ad esempio, questo è il numero di confronti necessari
Per ordinare n elementi.
Non lineare: la funzione f (n) = n logn cresce leggermente troppo rapidamente per essere
Nella classe lineare di funzioni (N).Questo perché n logn è times logn
N e Logn non sono costante.
Un polinomio: le classi (n), (n logn) e (n2) sono sottoclassi di
La classe delle funzioni polinomiali n (1).Ad esempio, sebbene la funzione f (n) = n logn sia troppo grande per (n) e troppo piccola (n2), è in n (1)
Perché è delimitato tra N1 e N2, entrambi i quali sono in N (1).
Logaritmi (log (n)): vedere il capitolo 24 per come funziona logaritmica come
log2 (n) sorgere e per alcune delle loro regole.
Quale base: scriviamo (log (n)) senza dare una base esplicita.COME
mostrato nell'elenco delle regole sui logaritmi, log10 (n), log2 (n) e loge (n)
differiscono solo per una costante moltiplicativa.Perché stiamo comunque ignorando le costanti moltiplicative, che la base viene utilizzata è irrilevante.Le regole
Indicare anche che 8 Log2 (N5) differisce anche solo per una costante moltiplicativa.
Tutte queste funzioni sono includono in (log (n)).
Esercizio 25.1.1 Che cresce più velocemente, 34n o 43N?
Esercizio 25.1.2 La notazione ((1)) n significa la stessa cosa di 2θ (n)?
Esercizio 25.1.3 Dimostrare che 20,5N ≤2n/n100 ≤2n per suffignitosamente grandi n.
Esercizio 25.1.4 (vedi soluzione nella parte cinque.) Dimostrare che n2 ≤3n2 logn ≤n3 per suffignitosamente grande n.
Esercizio 25.1.5 (vedi soluzione nella parte cinque.) Ordinare i termini in f (n) = 100n100 + 34n +
Log1.000 N + 43N + 20.001N/N100.
Esercizio 25.1.6
Per ciascuna delle seguenti funzioni, ordinare i suoi termini per tasso di crescita.
Ottieni la crescita del quadro generale classificandola in 2 (n), n (1), log (1) (n), (1) o in a
Classe simili e appropriate.Dare anche la sua approssimazione theta.
1.
f (n) = 5n3 −17n2 + 4
2.
f (n) = 5n3 logn + 8n3
3.
f (n) = 225n
4.
f (n) = 73 log2 n
5.
f (n) = {1 se n è dispari, 2 se n è pari}
6.
f (n) = 2 · 2n · n2 log2 n −7n8 + 7 3n
N2

---
layout: 
title: Pagina 400
level: 3
---


Appendice
384
7.
f (n) = 100n100 + 34n + log1000 (n) + 43n
8.
f (n) = 6
N4
log3 n + 8n1002−5n + 17
9.
f (n) =
1
N2 + 5 LOGN
N
10.
f (n) = 7 5
√n + 6 3
√n
11.
f (n) = 6n5.2+7n7.5
2n3.1+7n2.4
12.
f (n) = −2n
13.
f (n) = 5nlog3 n
Esercizio 25.1.7
Per ogni coppia di classi di funzioni, come sono simili?Come sono
Sono diversi?Se possibile, dare una funzione che è inclusa nel primo ma non
incluso nel secondo.Se possibile, fare il contrario, dando una funzione inclusa in
il secondo ma non nel primo.
1.
(22n) e (23n)
2.
(2n) e 3 (N)
25.2
Maggiori informazioni sulla notazione asintotica
Altre notazioni utili:
Nome
Notazione standard
La mia notazione
Senso
Theta
f (n) = (g (n))
f (n) ∈ (g (n))
f (n) ≈c · g (n)
Bigoh
f (n) = o (g (n))
f (n) ≤o (g (n))
f (n) ≤c · g (n)
Omega
f (n) = (g (n))
f (n) ≥ (g (n))
f (n) ≥c · g (n)
Piccolo oh
f (n) = o (g (n))
f (n) << o (g (n))
f (n) << g (n)
Little Omega
f (n) = ω (g (n))
f (n) >> ω (g (n))
f (n) >> g (n)
Tilde
f (n) = ~
(G (N))
f (n) ∈ ~
(G (N))
f (n) ≈log (1) · g (n)
Lo stesso: 7 · n3 è all'interno di una costante di N3.Quindi, è in (N3), O (N3) e (N3).
Tuttavia, perché non è molto più piccolo di N3, non è in O (N3) e perché è
non è molto più grande, non in ω (N3).
Più piccolo: 7 · N3 è asintoticamente molto più piccolo di N4.Quindi, è in O (N4) e
In O (N4), ma non è in (N4), (N4) o ω (N4).
Più grande: 7 · N3 è asintoticamente molto più grande di N2.Quindi, è in (n2) e in
ω (N2), ma non è in (N2), O (N2) o O (N2).
Fattori di registro: 7n3 log2 n = ~
(N3) ignora i fattori logaritmici.
Considerazioni sulla notazione:
“∈” vs “=”: considero (n) una classe di funzioni, quindi dovrei usare l'insieme
Notazione, f (n) ∈ (g (n)), per indicare l'appartenenza.

---
layout: 
title: Pagina 401
level: 3
---


Crescita asintotica
385
D'altra parte, ignorando i fattori moltiplicativi costanti, F (n) ha il
Stessa crescita asintotica di G (N).Per questo motivo, la notazione 7n = (n) fa
senso.Questa notazione è standard.
Anche le dichiarazioni 3N2 + 5N −7 = N (1) e 23n = 2 (n) hanno un senso migliore
Quando pensi al simbolo significare "qualche costante".Tuttavia, assicurati di
Ricorda che anche 4n · n2 = 2 (n) è vero.
“=” Vs “≤”: 7n = O (N2) è anche una notazione standard.Questo ha meno senso per me.
Perché significa che 7n è al massimo alcuni tempi costanti N2, una notazione migliore
sarebbe 7n ≤o (N2).La notazione standard è ancora più imbarazzante, perché
O (n) = O (N2) dovrebbe essere vero, ma O (N2) = O (N) dovrebbe essere falso.Che senso fa
che compongono?
Maggiori dettagli: puoi decidere quante informazioni su una funzione vuoi
svelare.Se f (n) = 5n2 + 3n, si potrebbe dire
r f (n) ∈N (1), cioè un polinomio
r f (n) ∈ (n2), cioè un quadratico
r f (n) ∈ (5 + o (1)) n2 = 5n2 + O (n2), cioè 5n2 più alcuni termini di ordine basso.
r f (n) ∈5n2 + O (n), cioè 52 più al massimo alcuni termini lineari.
Le definizioni formali di Theta e Bigoh:
f (n) ∈ (g (n))
iff
∃c1, c2> 0 ∃n0 ∀n ≥n0, c1 · g (n) ≤f (n) ≤c2 · g (n)
f (n) ∈o (g (n))
iff
∃C> 0
∃n0 ∀n ≥n0, 0 ≤f (n) ≤c · g (n)
f (n) ∈ (g (n))
iff
∃C> 0
∃n0 ∀n ≥n0, c · g (n) ≤f (n)
f (n) ∈N (1)
iff
∃c1, c2> 0 ∃n0 ∀n ≥n0, nc1 ≤f (n) ≤nc2
f (n) ∈2 (n)
iff
∃c1, c2> 0 ∃n0 ∀n ≥n0, 2c1n ≤f (n) ≤2c2n
f (n) ̸∈ (g (n))
iff
∀c1, c2> 0 ∀n0 ∃n ≥n0, [c1 · g (n)> f (n) o f (n)> c2 · g (n)]
Limitato tra: l'affermazione f (n) ∈ (g (n)) significa che la funzione f (n) è
delimitato tra C1 · G (N) e C2 · G (N).Vedi Figura 25.1.
Requisiti su C1 e C2: gli unici requisiti sulle costanti sono che C1
essere sufficientemente piccolo (ad esempio, 0,001) ma positivo e C2 essere sufficientemente grande (ad esempio, 1.000) per funzionare e che siano fissati (cioè non dipendono da n).Permettiamo a valori irragionevolmente estremi come C2 = 10100, di fare la definizione matematicamente
pulire e non orientato a un'applicazione specifica.
Suffignitosamente grande n: data fissata C1 e C2, l'affermazione C1G (N) ≤F (N) ≤C2G (N)
dovrebbe essere vero per tutti i valori sufficienti di N, (cioè, ∀n ≥n0).
Definizione di n0 sufficientemente grande: di nuovo per rendere pulita la matematica e
Non orientato a un'applicazione specifica, richiederemo semplicemente che esistano alcuni
Definizione di N0 sufficientemente grande che funziona.L'esercizio 25.0.2 fornisce un esempio in
che N0 deve essere irragionevolmente grande.

---
layout: 
title: Pagina 402
level: 3
---


Appendice
386
C2
1
C
F (N)
C G (N)
2
C1G (N)
F (N)
G (N)
Figura 25.1: f (n) ∈ (1) e f (n) ∈ (g (n)).
Dimostrando f (n) ∈ (g (n)): usa il gioco prover -avversario.
R You come Prover fornisce C1, C2 e N0.
r un po 'di avversario ti dà un n che è almeno il tuo N0.
r dimostra quindi che C1G (N) ≤F (N) ≤C2G (N).
Esempio: ad esempio, 2n2 + 100n = (N2).Sia C1 = 2, C2 = 3 e N0 = 100.
Quindi, per tutti N ≥100, abbiamo C1G (N) = 2n2 ≤2n2 + 100n = f (n) e f (n) =
2n2 + 100n ≤2n2 + n · n = 3n2 = c2g (n).I valori di C1, C2 e N0 non sono
unico.Ad esempio, N0 = 1, C2 = 102 e N0 = 1 funzionano anche perché per tutti N ≥1
Abbiamo f (n) = 2n2 + 100n ≤2n2 + 100n2 = 102n2 = c2g (n).
Le definizioni formali di Little Oh e Little Omega:
Classe
limn → ∞
F (N)
g (n) =
Una definizione praticamente equivalente
f (n) = (g (n))
Un po 'costante
f (n) = o (g (n)) e f (n) = (g (n))
f (n) = o (g (n))
Zero
f (n) = o (g (n)), ma f (n) ̸ = (g (n))
f (n) = ω (g (n))
∞
f (n) ̸ = o (g (n)), ma f (n) = (g (n))
Esempi:
r 2n2 + 100n = (n2) e limn → ∞2n2 + 100n
N2
= 2
r 2n + 100 = O (N2) e limn → ∞2n + 100
N2
= 0
r 2n3 + 100n = ω (n2) e limn → ∞2n3 + 100n
N2
= ∞
Esercizio 25.2.1
Come nell'esercizio 25.1.7, confronta le classi (5 + O (1)) N2 e 5N2 +
SU).
Esercizio 25.2.2 (vedi soluzione nella parte quinta.) Prova formalmente o smorza quanto segue:
1.
14n9 + 5.000n7 + 23n2 logn ∈O (N9)
2.
2n2 −100n ∈ (N2)
3.
14n8 −100n6 ∈o (N7)

---
layout: 
title: Pagina 403
level: 3
---


Crescita asintotica
387
4.
14n8 + 100n6 ∈ (N9)
5.
2n+1 ∈o (2n)
6.
22n ∈o (2n)
Esercizio 25.2.3
Dimostra che se f1 (n) ∈ (g1 (n)) e f2 (n) ∈ (g2 (n)), allora f1 (n) +
f2 (n) ∈max ((g1 (n)), (g2 (n))).
Esercizio 25.2.4
Dimostra che se f1 (n), f2 (n) ∈N (1), allora f1 (n) · f2 (n) ∈N (1).
Esercizio 25.2.5 Sia f (n) una funzione.Come sapete, (f (n)) fa cadere termini di ordine basso
e il coefficiente principale.Spiega cosa fa ciascuno dei seguenti: 2 (log2 f (n)) e
log2 ((2f (n))).Per ciascuno, spiega a che misura la funzione è approssimata.
Esercizio 25.2.6 Sia X un valore reale.Come sapete, ⌊x⌋ lo fa giù al successivo
numero intero.Spiega cosa fa ciascuno dei seguenti: 2 · ⌊x
2⌋, 1
2 · ⌊2 · x⌋ e 2⌊log2 x⌋.
Esercizio 25.2.7
Supponiamo che y = (log x).Quali delle seguenti sono vere: x =
(2y) e x = 2 (y)?Perché?
Esercizio 25.2.8 (vedi soluzione nella parte quinta.) È impossibile risolvere algebicamente il
Equazione x = 7y3 (log2 y) 18 per y.
1.
Approssimarsi 7y3 (log2 y) 18 e quindi risolvere per y.Questo approssima il valore di y.
2.
Ottieni una migliore approssimazione come segue.Collegare la tua approssimazione sopra per y a
Express (log2 y) 18 in termini di x.Colleglo in x = 7y3 (log2 y) 18.Ora risolvi per y
Ancora.(Potresti ripetere questo passaggio per approssimazioni migliori.)
3.
Osservare come una tecnica simile è stata utilizzata negli esercizi 25.0.1 e 25.0.2 per approssimare una soluzione per (log10 N) 1.000.000 = n.

---
layout: 
title: Pagina 404
level: 3
---


388
26 Approssimazioni di Aggiunta di fabbriche
Algoritmo EG (N)
Loop i = 1..n
Loop j = 1..i
Loop K = 1..J
Metti "Ciao"
End Loop
End Loop
End Loop
Algoritmo di fine
Il ciclo interno richiede tempo j
k = 1 1 = j.
Il prossimo richiede io
j = 1
j
k = 1 1 = i
j = 1 j = (i2).
Il totale è n
i = 1
io
j = 1
j
k = 1 1 = n
i = 1 (i2) = (n3).
Le somme sorgono spesso nello studio degli algoritmi informatici.
Ad esempio, se l'ith Iterazione di un loop richiede tempo
f (i) e it loops n volte, quindi il tempo totale è f (1) +
f (2) + f (3) + · · · + f (N).Questo indiciamo come n
i = 1 f (i).Esso
può essere approssimato dall'integrale
n
x = 1 f (x) Δx, perché la prima è l'area sotto le scale di altezza f (i)
e il secondo sotto la curva f (x).(In effetti, entrambi
(dalla lettera greca Sigma) e

(dal vecchio lungo
S) sono S per la somma.) Si noti che, anche se l'individuo
I termini sono indicizzati da I (o x), il totale è una funzione di
N.L'obiettivo ora è di approssimare n
i = 1 f (i) per vari
funzioni f (i).
N
f (i)
io
1
F (x)
M
F (N)
Oltre ad apprendere le tecniche classiche per il calcolo n
i = 1 2i, n
i = 1 i, e
n
i = 1
1
Io, non studiamo come valutare esattamente le somme, ma solo come approssimare
loro a un fattore costante.Sviluppiamo regole facili che la maggior parte degli informatici usa, ma per qualche ragione di solito non viene insegnata, in parte perché non sono sempre vere.Abbiamo dimostrato formalmente quando sono veri e quando no.Li chiamiamo
Collettivamente la tecnica aggiuntiva-facile.

---
layout: 
title: Pagina 405
level: 3
---


Approssimazioni di aggiunta di fabbriche
389
26.1
La tecnica
La tabella seguente delinea le poche semplici regole con cui sarai in grado di calcolare
(n
i = 1 f (i)) per funzioni con la forma di base f (n) = (ban · nd · loge n).(Noi consideriamo
funzioni più generali alla fine di questa sezione.)
ba
D
e
Tipo di somma
n
i = 1 f (i)
Esempi
> 1
Qualunque
Qualunque
Aumento geometrico
(dominato da
ultimo termine)
(f (n))
n
i = 0 22i
≈1 · 22n
n
i = 0 bi
= (BN)
n
i = 0 2i
= (2n)
= 1
> −1
Qualunque
Aritmetico
(metà dei termini
circa
pari)
(n · f (n))
n
i = 1 id
= (n · nd) = (nd+1)
n
i = 1 i2
= (n · n2) = (n3)
n
i = 1 i
= (n · n) = (N2)
n
i = 1 1
= (n · 1) = (n)
n
i = 1
1
i0.99
= (n ·
1
n0.99) = (n0.01)
= −1
= 0
Armonico
(LNN)
n
i = 1
1
io
= loge (n) + (1)
<−1
Qualunque
Coda limitata
(dominato da
primo termine)
(1)
n
i = 1
1
i1.001
= (1)
n
i = 1
1
i2
= (1)
<1
Qualunque
Qualunque
n
i = 1 (1
2) i
= (1)
n
i = 0 b -i
= (1)
Quattro diverse classi di soluzioni: tutte le somme che considereremo
Una delle quattro diverse classi di soluzioni.L'intuizione per ciascuno è piuttosto semplice.
In aumento geometricamente: se i termini crescono molto rapidamente, il totale è dominato
Nell'ultimo e più grande termine f (n).Quindi, si può approssimare la somma solo
Considerando l'ultimo termine: n
i = 1 f (i) = (f (n)).
Esempi: considerare la somma classica in cui ciascuno dei termini N è due volte
Il precedente, 1 + 2 + 4 + 8 + 16 + · · · + 2n.O esaminando le aree all'interno
Figura 26.1.a o 26.1.b o usando una semplice induzione, si può dimostrare che il totale
è sempre uno in meno del doppio del termine più grande: n
i = 0 2i = 2 × 2n −1 = (2n).
Più in generale, n
i = 0 bi ≈
B
b - 1 · bn, che può essere approssimato da (f (n)) =
(BN).(Allo stesso modo, n
x = 0 bx Δx =
1
lnbbn.) Lo stesso vale per la crescita anche più veloce
funzioni come n
i = 0 22i ≈1 × 22n.
Exponentials a forma di base: la stessa tecnica, n
i = 1 f (i) = (f (n)), funziona
Per tutti gli esponenziali in forma di base, ovvero per f (n) = (ban · nd · loge n) con b a>
1, abbiamo quello n
i = 1 f (i) = (ban · nd · loge n).

---
layout: 
title: Pagina 406
level: 3
---


Appendice
390
1
4
16
8
32
64
4 2
8
16
32
2
1+2+4+8+16+32+64 = 2 × 64 –1

1
64
N+1
n = 10
= 2 –1/64
1+1/2+1/4+1/8+1/16+1/32+1/64
1/32
1/64
1/32
1
1/2
1/4
1/8
1
1/2
1/4
1/8
1/16
1/64
1/16
(UN)
(B)
(C)
(D)
(e)
Figura 26.1: Esempi di funzione geometricamente crescente, simile a aritmetica e a coda limitata.
Aritmetico simile all'aritmetica: se la metà dei termini ha all'incirca le stesse dimensioni, allora il totale è
all'incirca il numero di termini volte l'ultimo termine, vale a dire n
i = 1 f (i) = (n · f (n)).
Esempi:
Costante: chiaramente la somma di n è n, cioè n
i = 1 1 = n.Questo è (n ·
f (n)).
Lineare: l'esempio classico è la somma in cui ciascuno dei n termini
è solo uno più grande del precedente, n
i = 1 i = 1 + 2 + 3 + 4 + 5 + · · · +
n = n (n+
1)
2
.Questo può essere approssimato usando (n · f (n)) = (n2).Vedi Figura 26.1.
Polinomi: entrambi
n
i = 1 i2 = 1
3n3 + 1
2n2 + 1
6n
E
Di più
generalmente
n
i = 1 id =
1
D+1nd+1+(ND)
Potere
Essere
approssimato
con
(n · f (n)) = (n · nd) = (nd+1).(Allo stesso modo, n
x = 0 xD Δx =
1
d+1nd+1.)
Sopra l'armonica: n
i = 1
1
n0.999 ≈1.000 n0.001 può essere approssimato con
(n · f (n)) = (n · n - 0.999) = (n0.001).
Polinomi a forma di base: il
Stesso
Tecnica, n
i = 1 f (i) = (n · f (n)), funziona per tutti i polinomi a forma di base, le costanti e diminuendo lentamente
funzioni, cioè, per f (n) = (nd · loge n) con d> 1 abbiamo quel n.
i = 1 f (i) =
(ND+1 · Loge N).
Coda limitata: se i termini si riducono rapidamente, il totale è dominato dal primo e
termine più grande f (1), che si presume qui come (1), cioè n
i = 1 f (i) = (1).
Esempi: la somma classica qui è quando ogni termine è metà del precedente, 1 + 1
2 + 1
4 + 1
8 + 1
16 + · · · + 1
2n.Vedere la Figura 26.1.d e 26.1.e.Il totale si avvicina ma non ne raggiunge mai 2, così che n
i = 0 (1
2) i = 2 - (1
2) n = (1).Allo stesso modo, n
i = 1
1
N1.001 ≈1.000 = (1) e n
i = 1
1
N2 ≈
6 ≈1.5497 = (1).
Forma di base con coda limitata: il
Stesso
Tecnica, n
i = 1 f (i) = (1), funziona per tutte le funzioni di riduzione polinomia o esponenzialmente in forma di base, cioè per f (n) = (ban · nd · loge n) con b a = 1 e d <1o con
b a <1.

---
layout: 
title: Pagina 407
level: 3
---


Approssimazioni di aggiunta di fabbriche
391
La somma armonica: la somma n
i = 1
1
Sono indicato come la somma armonica perché
della sua connessione con la musica.Si presenta sorprendentemente spesso e ha un inaspettato
totale:
(1)
Σ
f (i) = 1/i1/3
1 = n
Σ
1
1
f (i) = 1/i
1
f (i) = 1
1
Θ
Θ (n)
1/i =
1/3
Σ
Θ.
1/i = ln n
+
(n f (n))
=
f (i) = 1/2
2
2
1/2
=
(1)
Σ
Θ
2/3
Sul confine: il confine tra quelle somme per le quali n
i = 1 f (i) =
(n · f (n)) e quelli per i quali n
i = 1 f (i) = (1) si verifica quando queste approssimazioni si incontrano, cioè quando (n · f (n)) = (1).Ciò si verifica all'armonica
funzione f (n) = 1
N.Dato che entrambe le approssimazioni dicono che il totale è n
i = 1
1
i =
(1), è ragionevole pensare che questa sia la risposta, ma non lo è.
Il totale: si scopre che il totale è entro 1 del logaritmo naturale, n
i = 1
1
i = loge n + (1).(Allo stesso modo, N+
1
x = 1
1
x Δx = loge n + (1).) Vedi Figura 26.2.
Altri esempi:
Aumento geometrico:
r n
i = 1 8 2i
i100 + i3 = (2n
N100)
r n
i = 1 3i logi + 5i + i100 = (3n logn)
r n
i = 1 2i2 + i2 logi = (2n2)
r n
i = 1 22i - i2 = (22n - n2)
Aritmetica (in aumento):
r n
i = 1 i4 + 7i3 + i2 = (N5)
r n
i = 1 i4.3 log3 i + i3 log9 i = (n5.3 log3 n)
Aritmetica (diminuendo):
r n
i = 2
1
logi = (
N
logn)
r n
i = 1
log3 i
i0.6 = (n0.4 log3 n)
Coda limitata:
r n
i = 1
log3 i
i1.6+3i = (1)
r n
i = 1
i100
2i = (1)
r n
i = 1
1
22i = (1)
Esempi più strani:
r un fatto utile è n
i = m f (i) = n
i = 1 f (i) - m - 1
i = 1 f (i).Quindi, n
i = m
1
i = (logn) -
(logm) = (log n
M).

---
layout: 
title: Pagina 408
level: 3
---


Appendice
392
F (n) è un esponenziale, geometrico:
–1
N
–1.0001
N
–0.9999
N
(1.0001) n
N10.000
Aritmetica:
f (n) è un polinomio o diminuendo lentamente,
(NF (N))
Σ f (n) = θ

Σ f (n) =
(1)
Θ
Coda limitata:
f (n) sta rapidamente diminuendo, θ
f (n) =
Σ
(log n)
f (n) = 1/n, armonica:
Σf (n) = (f (n)) θ
F (N)
Figura 26.2: confini tra coda geometrica, aritmetica, armonica e limitata.
r Se la somma è aritmetica, allora la somma è il numero di termini
termine.Questo dà m+n
i = m i2 = (n · (m + n) 2).
r per risolvere 5n2+n
i = 1
i3 logi, lascia che n = 5n2 + n denoti il ​​numero di termini.Poi n
i = 1
i3 logi = (n · f (n)) = (n 4 log n).Sostituire di nuovo per n dà 5n2+n
i = 1
i3 logi = ((5n2 + n) 4 log (5n2 + n)) = (n8 logn).
r tra i termini, cambia, ma n no.Quindi, n può essere trattato come una costante.
Ad esempio, n
i = 1 i · n · m = nm · n
i = 1 i = nm · (n2) = (n3m).
r in n
i = n
2
1
I2, i termini stanno diminuendo abbastanza velocemente da essere delimitati dal primo termine.
Qui, tuttavia, il primo termine non è (1), ma lo è

1
(N
2) 2

=
1
N2

r in caso di dubbio, inizia determinando il primo termine, l'ultimo termine e il numero di termini.In log2 n
i = 1
2log2 n -i · i2, il primo termine è f (1) = 2logn - - 1 · 12 = (n) e
L'ultimo termine è f (logn) = 2logn -logn · (logn) 2 = (log2 n).I termini diminuiscono geometricamente in i.Il totale è quindi (f (1)) = (n).
r n
i = 1
n
j = 0 i2 j 3 = n
i = 1 i2 [n
j = 0 j 3] = n
i = 1 i2 (n4) = (n4) [n
i = 1 i2] =
(N4) (N3) = (N7).
Esercizio 26.1.1 Dare l'approssimazione delle seguenti somme.Indicare quale
Regola che usi e mostri il tuo lavoro.
1.
n
i = 0 7i3 −300i2 + 16
2.
n
i = 0 i8 + 23i
i2
3.
n
i = 0
1
i1.1

---
layout: 
title: Pagina 409
level: 3
---


Approssimazioni di aggiunta di fabbriche
393
4.
n
i = 0
1
i0.9
5.
n
i = 0 7 i3.72
log2 i −300i2 log9 i
6.
n
i = 1
loge i
io
7.
Logn
i = 1 n · i2
8.
n
i = 0
m
j = 0
J
io
9.
n
i = 1
io
j = 1 ji
10.
n
i = 1
i2
j = 1 ij log (i)
26.2
Alcune prove per la tecnica di aggiunta
Questa sezione presenta alcune delle tecniche classiche per sommare e disegnare il
Prova della tecnica di aggiunta di fabbriche.
Semplici somme geometriche:
Teorema: quando b> 1, n
i = 1 bi = (f (n)) e quando b <1, n
i = 1 f (i) = (1).
Prova:
S = 1 + b + b2 + · · · bn
B · s = b + b2 + b3 + · · · bn +
1.
Sottraendo quelle due equazioni dà
(1 −b) · s = 1 −bn+
1
S = 1 −bn+
1
1 −b
o Bn+
1 −1
B −1
= (max (f (0), f (n)))
Rapporto tra i termini: per dimostrare che una somma geometrica non è più che una costante
volte il termine più grande, dobbiamo confrontare ogni termine f (i) con questo termine più grande.Uno
Il modo per farlo è di confrontare prima ogni coppia consecutiva di termini f (i) e f (i + 1).
Teorema: se per tutti i sufficati i, il rapporto tra i termini è limitato
da uno, cioè ∃b> 1, ∃n0, ∀i ≥n0, f (i + 1)/f (i) ≥b, quindi n
i = 1 f (i) = (f (n)).
Al contrario, se ∃b <1, ∃n0, ∀i ≥n0, f (i+1)
f (i)
≤b, quindi n
i = 1 f (i) = (1).
Esempi:
Tipico: con f (i) = 2i/i, il rapporto tra i termini consecutivi è
f (i + 1)
f (i)
= 2i+1
I + 1 · i
2i = 2 ·
io
i + 1 = 2 ·
1
1 + 1
io
che è almeno 1,99 per sufficiente i.Analogamente per qualsiasi f (n) = (ban ·
nd · loge n) con b a> 1.

---
layout: 
title: Pagina 410
level: 3
---


Appendice
394
N
f (i)
I - n0
B
F (N)
0
F (N)
n - i
1/b f (n)
N
= Θ (1)
f (i) = θ (n0f (n0))
f (i) = θ (n0f (n0))
f (i)
F (N)
Σn
(1)
f (i)
= Θ
N0
N0
F (N0)
Θ
1
Σ
= Θ (1)
1
N0
N0
N0
Σn
N0
Σ
F (N0)
f (i)
=
(f (n))
Figura 26.3: In entrambe le immagini, il totale prima di N diventa sufficientemente grande è un po 'costante.SU
La sinistra, il totale per N grande è delimitato da un esponenziale in crescita, e a destra da a
diminuendo esponenziale.
Non limitato via: d'altra parte, la funzione aritmetica f (i) = I ha
Un rapporto tra i termini di I+1
io
= 1 + 1
io .Anche se questo è sempre più grande di
Uno, non è limitato da uno da qualsiasi costante b> 1.
Prova: se ∀i ≥n0, f (i + 1)/f (i) ≥b> 1, allora segue la distorsione o l'induzione
f (i) ≤
1
B
1
f (i + 1) ≤
1
B
2
f (i + 2) ≤
1
B
3
f (i + 3) ≤ · · · ≤
1
B
n -i
F (N)
Vedi Figura 26.3.Questo lo dà
N

i = 1
f (i) =
N0

i = 1
f (i) +
N

i = n0
f (i) ≤ (1) +
N

i = n0
1
B
n -i
f (n) ≤ (1) + f (n) ·
N

j = 0
1
B
j
che abbiamo già dimostrato è (f (n)).
Una semplice somma aritmetica: dimostriamo come segue n
i = 1 i = (n · f (n)) = (n2):
S =
1
+
2
+
3
+ · · · + N −2 + n −1 +
N
S =
N
+ n −1 + n −2 + · · · +
3
+
2
+
1
2S = N + 1 + N + 1 + N + 1 + · · · + N + 1 + N + 1 + N + 1
= n · (n + 1)
S = 1
2n · (n + 1)
Somme aritmetiche: ora giustificheremo l'intuizione che se la metà dei termini lo sono
all'incirca le stesse dimensioni, quindi il totale è all'incirca il numero di termini per l'ultimo
termine, vale a dire n
i = 1 f (i) = (n · f (n)).
Teorema: se per sufficace N, la funzione f (n) non è piena e non è
f (n
2) = (f (n)), quindi n
i = 1 f (i) = (n · f (n)).

---
layout: 
title: Pagina 411
level: 3
---


Approssimazioni di aggiunta di fabbriche
395
Esempi:
Tipico: la funzione f (n) = nd per d ≥0 non è arescente e f (n
2) =
n
2
d =
1
2d f (n).Allo stesso modo
per f (n) = (nd · loge n).Consideriamo −1 <d <
0 più tardi.
Senza la proprietà: il
funzione
f (n) = 2n
non ha questa proprietà, perché f (n
2) =
2n/2 =
1
2n/2 f (n).
Prova: perché f (i) non è aressante, metà del
I termini sono almeno il medio termine f (n
2) e tutto
dei termini sono al massimo il termine più grande F (n).Quindi, f (i)
N/2
f (n/2)
N
F (N)
N
2 · f (n
2) ≤ n
i = 1 f (i) ≤n · f (n).Perché f (n
2) = (f (n)), questi limiti corrispondono, dando n
i = 1 f (i) = (n · f (n)).
La somma armonica: la somma armonica è una somma famosa che si presenta sorprendentemente
Spesso.Il totale n
i = 1
1
I è entro 1 di loge n.Tuttavia, non lo legato abbastanza
da vicino.
Teorema: n
i = 1
1
i = (logn).
Prova: un modo per approssimare la somma armonica è di romperla in log2 n
blocchi con termini 2k nel blocco KTH, quindi per dimostrare che il totale per ciascuno
Il blocco è tra 1
2 e 1:
N

i = 1
1
i =
≥1 · 1
2 = 1
2


1
1

≤1 · 1 = 1
+
≥2 · 1
4 = 1
2


1
2 + 1
3

≤2 · 1
2 = 1
+
≥4 · 1
8 = 1
2



1
4 + 1
5 + 1
6 + 1
7

≤4 · 1
4 = 1
+
≥8 · 1
16 = 1
2



1
8 + · · · + 1
15

≤8 · 1
8 = 1
+ · · ·
Da questo, ne segue 1
2 · log2 n ≤ n
i = 1
1
I ≤1 · log2 n.
Vicino all'armonica: ora useremo una tecnica simile per dimostrare i restanti due
Casi della tecnica aggiuntiva-facile.
Teorema: n
i = 1 1/id ′ è (1) se d ′> 1 ed è (n · f (n)) se d ′ <1. (Allo stesso modo per
f (n) = (nd · loge n) con d <−1 o> −1.)
Prova: come abbiamo fatto con la somma armonica, rompe la somma n
i = 1 f (n) in blocchi
Dove il blocco KTH ha i termini 2K 2K+1−1
i = 2k
f (i).Poiché i termini stanno diminuendo, il totale per il blocco è al massimo f (k) = 2k · f (2K).Il totale totale è quindi a
maggior parte
log2 n

k = 0
F (k) =
log2 n

k = 0
2k · f (2k) =
log2 n

k = 0
2k
(2k) d ′ =
N

k = 0
1
2K · (D′ - 1).

---
layout: 
title: Pagina 412
level: 3
---


Appendice
396
Se D ′> 1, questa somma viene esponenzialmente diminuendo e converge in (1).Se d ′ <
1, quindi questa somma aumenta esponenzialmente e diverge a (f (n)) = (2log2 n ·
f (n)) = (n · f (n))).
Funzioni senza la forma di base: (Attenzione: questo argomento può essere un po 'difficile.)
Fino ad ora abbiamo considerato solo funzioni con la forma di base f (n) = (ban · nd ·
loge n).Vorremmo generalizzare la tecnica aggiuntiva-facile come segue:
Geometrico
Crescente
Aritmetica
Armonico
Coda limitata
Se
f (n) ≥2 (n)
f (n) = n (1) −1
f (n) = (1
N)
f (n) ≤n - 1− (1)
poi n
i = 1 f (i) = (f (n)) n
i = 1 f (i) = (n · f (n)) n
i = 1 f (i) = (logn) n
i = 1 f (i) = (1)
Esempio: considera f (n) = n8+ 1
n o f (n) = n - 1
N .Sono delimitati tra ND1
e nd2 per costanti d2 ≥d1> 0 −1, e quindi per entrambi abbiamo f (n) ∈N (1) −1.
L'aggiunta di Made Easy indica quindi N
i = 1 f (i) = (n · f (n)), in modo che n
i = 1 i8+ 1
i =
(N9+ 1
n) e n
i = 1 i - 1
i = (N1−1
N ).
Controesempio: l'obiettivo qui è prevedere la somma n
i = 1 f (i) dal valore
dell'ultimo termine F (n).Non siamo in grado di farlo se i termini oscillano come quelli
Creato con sines, coseni, pavimenti e soffitti.Esercizio 26.2.4 dimostra che f (n) =
22⌈log2 n⌉and f (n) = 2 [1
2 cos (π log2 n) +1.5] · n sono controesampli per il caso geometrico
e quel f (n) = 22⌊log logn⌋ è uno per il caso aritmetico.
2n
22n
N/2
N
(Non ridimensionare)
F (N)
N
N
N
F (N)
(Non ridimensionare)
N
Semplici funzioni analitiche: possiamo dimostrare che la tecnica aggiuntiva e facile
Funziona per tutte le funzioni f (n) che possono essere espresse con n, costanti reali, più, meno, tempi, divisione, esponenziale e logaritmi.Si dice che tali funzioni siano semplici
analitico.
Schizzo a prova: darò solo uno schizzo della prova qui.Per il caso geometrico, dobbiamo dimostrare che se f (n) è semplice analitico e f (n) ≥2 (n), allora ∃b> 1,

---
layout: 
title: Pagina 413
level: 3
---


Approssimazioni di aggiunta di fabbriche
397
∃n0, ∀n ≥n0, f (n + 1)/f (n) ≥b.Da questo, il rapporto tra i termini
Sopra dà quello n
i = 1 f (i) = (f (n)).
Poiché la funzione sta crescendo esponenzialmente, lo sappiamo in generale
Cresce almeno velocemente quanto Bn per qualche costante b> 1 e quindi
f (n + 1)/f (n) ≥b o equivalentemente H (n) = log f (n + 1) −log f (n) −logb> 0 per
un numero infinito di valori per n.
Un profondo teorema delle semplici funzioni analitiche è che non possono oscillare per sempre e quindi possono cambiare il massimo del segno di un numero concreto di luoghi.Esso
ne consegue che ci deve essere un ultimo posto N0 in cui il segno cambia.Possiamo concludere che ∀n ≥n0, h (n)> 0 e quindi f (n + 1)/f (n) ≥b.
Il caso in declino geometricamente è lo stesso tranne f (n + 1)/f (n) ≤b.IL
Il caso aritmetico è simile tranne per il fatto che dimostra che se f (n) è semplice analitico e
f (n) = n (1) −1, quindi f (n
2) = (f (n)).
Esercizio 26.2.1 (vedi soluzione nella parte cinque.) Il classico paradosso di Zeno è che Achille è
Viaggiare 1 km/ora e ha 1 km per viaggiare.Prima deve coprire la metà della sua distanza, poi metà
della sua distanza rimanente, poi metà di questa distanza rimanente ,....Non arriva mai.Di
Bryan Magee afferma: “La gente lo ha trovato terribilmente sconcertante.Ci deve essere un difetto
Nella logica, hanno detto.Ma nessuno ha ancora avuto pienamente successo nel dimostrare
Cos'è."Risolvi questo antico paradosso aggiungendo il tempo richiesto per tutti i passaggi.
ESERCIZIO
26.2.2
Dimostra che se ∃b <1, ∃n0, ∀i ≥n0, f (i + 1)/f (i) ≤b, quindi
n
i = n0 f (i) = (f (n0)) = (1).
Esercizio 26.2.3 Un paradosso apparente è come si potrebbe avere una nave che ha finito
Volume e superficie in ﬁ nita.Questa nave (teorica) potrebbe essere riempita con un piccolo
quantità di vernice ma richiede una quantità infinita di vernice per la vernice.Per h ∈ [1, ∞), il suo
La sezione trasversale alle unità H dalla sua parte superiore è un cerchio con raggio r =
1
HC per qualche costante c.
Integrare (o aggiungere) la sua circonferenza trasversale per calcolare la sua superficie e
integrare (o aggiungere) la sua area trasversale per calcolare il suo volume.Dai un valore per C
in modo tale che la sua superficie sia in concomitanza e il suo volume è finito.
Esercizio 26.2.4 (vedi soluzione nella parte cinque.)
1.
Per f (n) = 22⌈log2 n⌉, dimostra che f (n) ≥2 (n)
2.
e quello n
i = 1 f (i) ̸ = (f (n)).
3.
Per f (n) = 22⌊log logn⌋, dimostra che f (n) = n (1) −1
4.
e quello n
i = 1 f (i) ̸ = (n · f (n)).
5.
Trama f (n) = 2 [1
2 cos (π log2 n) +1,5] · n e dimostra che è anche un controesempio per il
Caso geometrico.

---
layout: 
title: Pagina 414
level: 3
---


398
27 relazioni di ricorrenza
Un uomo saggio disse al re di dargli un chicco di riso per la prima piazza di un
scacchiera e per ogni piazza rimanente per dargli il doppio del numero per il
Piazza precedente.Trentadue giorni dopo, il re si rese conto che non c'è abbastanza riso
In tutto il mondo per premiarlo.Il numero di cereali sull'ennesimo quadrato è dato dal
relazione di ricorrenza t (1) = 1 e t (n) = 2t (n −1).
L'equazione algebrica x2 = x + 2 specifica il valore di un reale sconosciuto che
deve essere trovato.L'equazione differenziale ΔF (x)
Δx
= f (x) specifica le funzioni dai reali
per i reali che devono essere trovati.Allo stesso modo, relazioni di ricorrenza come t (n) = 2 × t (n −1)
Specificare le funzioni dagli interi ai reali.Un modo per risolvere ciascuno di questi è indovinare a
Soluzione e verificare se funziona.Qui t (n) = 2n funziona, cioè 2n = 2 × 2n - 1.Tuttavia, t (n) = c · 2n funziona anche per ogni valore di c.Sostenendo l'ulteriore requisito che
T (1) = 1 restringe la soluzione impostata su solo t (n) = 1
2 · 2n = 2n - 1.
27.1
La tecnica
Tempi di programmi ricorsivi: le relazioni ricorsive vengono utilizzate per determinare il
Tempo di esecuzione di programmi ricorsivi.(Vedi capitolo 8.) Ad esempio, se una routine, quando
Data un'istanza di dimensione n, f (n) funziona da sola e poi si riprende un tempo su sottoinstabilità della dimensione n
B, quindi il tempo di esecuzione è t (n) = a · t
n
B

+ f (n).
Vedi la Sezione 8.6 per saperne di più sull'albero dei cornici dello stack.Ogni cornice dello stack
è costituito da un'esecuzione della routine su una singola istanza, ignorando la subroutine
chiamate.Il frame dello stack di livello superiore viene chiamato dall'utente sull'istanza di input richiesta.
Si ricorre su una serie di sottoinstanze, creando il livello successivo di frame dello stack.
Questi a loro volta si ripresentano fino a quando l'istanza è sufficientemente piccola che lo stack
Il frame ritorna senza ricorso.Questi cornici finali dello stack sono indicati come base
casi.
Lascia che t (n) denoti il ​​numero di "hi" che l'intero albero dei cornici dello stack, dato il
seguendo il codice, stampe su un'istanza di dimensione n.Il telaio dello stack di livello superiore stampe "ciao"
f (n) volte.Quindi ricorresa volte su sottoinstabilità della dimensione n
B .Se t (n) è il numero di

---
layout: 
title: Pagina 415
level: 3
---


Relazioni di ricorrenza
399
"Ciao" per casi di dimensioni n, quindi segue che t
n
B

è il numero per i casi di
taglia n
B .Ripetere questo un tempo richiederà tempo a · t
n
B

.Ne consegue che il numero totale
soddisfa la relazione ricorsiva t (n) = a · t
n
B

+ f (n).L'obiettivo di questa sezione è di
Determinare quale funzione t (n) soddisfa questa relazione.
Se invece la routine si ripresenta a volte su istanze di dimensione n −b, allora il correlato
La relazione di ricorrenza sarà t (n) = a · t (n −b) + f (n).
Algoritmo EG (in)
⟨Pre-Cond⟩: in è un'istanza di dimensione n.
⟨Post-Cond⟩: stampe t (n) "hi" s.
inizio
n = | in |
if (n ≤1) allora
Metti "Ciao"
altro
Loop i = 1..f (n)
Metti "Ciao"
End Loop
Loop i = 1..A
In
b = un input di dimensioni n
B
Ad esempio (i n
B )
End Loop
finisci se
Algoritmo di fine
Quando l'ingresso ha dimensioni zero o uno, viene stampato solo un "hi".In generale, noi
Supponiamo che i programmi ricorsivi dediscano (1) tempo per casi di dimensioni (1).Noi
Esprimi questo come t (1) = 1, o più in generale come t ((1)) = (1).
Risoluzione delle relazioni di ricorrenza: considera t (n) = a · t
n
B

+ f (n), dove f (n) =
(nc · logd n) o f (n) = 0.
Log a
Log B vs C
D
Dominato da
T (n)
Esempio

log3 9
log3 3 = 2

Soluzione
<
Qualunque
Livello di alto livello
(f (n))
T (n) = 9 · t
n
3

+ N4
(N4)
=
> −1
Tutti i livelli
(f (n) logn)
T (n) = 9 · t
n
3

+ N 2
(n 2 logn)
<−1
Casi di base


N
loga
Logb

T (n) = 9 · t
n
3

+
N 2
log2n
(n 2)
>
Qualunque
t (n) = 9 · t
n
3

---
layout: 
title: Pagina 416
level: 3
---


Appendice
400
Considera t (n) = a · t (n −b) + f (n), dove f (n) = (nc · logd n) o f (n) = 0.
UN
F (N)
Dominato da
T (n)
Esempio
Soluzione
> 1
Qualunque
Casi di base
(a
N
B )
T (n) = 9 · t (n −3) + n4
(9
N
3)
= 1
≥1
Tutti i livelli
(n · f (n))
T (n) = t (n −3) + n4
(N5)
= 0
Casi di base
(1)
T (n) = t (n −3)
(1)
Un numero crescente di sottoinstabilità di dimensioni di riduzione: ogni istanza che ha
la sottoinstabilità significa che il numero di sottoinstanze cresce esponenzialmente di un fattore
di un.D'altra parte, le dimensioni delle sottoinstanze si riducono esponenzialmente di un fattore
di b.La quantità di lavoro che l'istanza deve svolgere è la funzione F di questa istanza
misurare.Se la crescita o la restringimento domina questo processo dipende da
relazione tra A, B e F (N).
Dominato da: quando il lavoro totale t (n) svolto nell'albero delle cornici dello stack è dominato
Dall'opera f (n) svolto dal telaio dello stack superiore, diciamo che il lavoro è dominato dal
Livello superiore della ricorsione.La soluzione in questo caso sarà t (n) = (f (n)).Al contrario, diciamo che è dominato dai casi di base quando il totale è dominato dalla somma
del lavoro svolto dai casi di base.Perché ogni caso di base fa solo una costante
quantità di lavoro, la soluzione sarà t (n) = (# dei casi di base), che è (nloga/ logb), (a
N
b) o (1) negli esempi sopra.Infine, se le quantità di lavoro in diverse
I livelli di ricorsione sono sufficientemente vicini l'uno all'altro, quindi diciamo che il lavoro totale
è dominato da tutti i livelli e il totale è il numero di livelli volte questo importo
di lavoro, vale a dire t (n) = (logn · f (n)) o (n · f (n)).
Il log del rapporto a
Log B: vedere il capitolo 24 per una discussione sui logaritmi.Un trucco che è
ci dà è che quando si calcola il rapporto tra due logaritmi, la base utilizzata
non importa, perché cambiare la base introdurrà la stessa costante entrambi
Nella parte superiore e in basso, che annullerà.Quindi, quando si calcola un tale rapporto, è possibile scegliere qualsiasi base rende il calcolo più semplice.Ad esempio, a
Calcola il registro 16
Log 8, la base ovvia da usare è 2, perché log2 16
log2 8 = 4
3. Questo è utile nel dare
That t (n) = 16 · t (n
8) + f (n) = (nlog 16/ log 8) = (n4/ 3).D'altra parte, per calcolare il registro 9
Log 27, la base ovvia da usare è 3, perché log3 9
log3 27 = 2
3, e quindi abbiamo t (n) =
9 · t (n
27) + f (n) = (n2/3).Un altro fatto interessante dato è quel log 1 = 0, che dà
That t (n) = 1 · t (n
2) + f (n), t (n) = (nlog 1/ log 2) = (n0) = (1).
Esercizio 27.1.1 (vedi soluzione nella parte cinque.) Fornire soluzioni per i seguenti esempi:
1.
T (n) = 2t (n
2) + n
2.
T (n) = 2t (n
2) + 1
3.
T (n) = 4t (n
2) + (
N3
log3 n)

---
layout: 
title: Pagina 417
level: 3
---


Relazioni di ricorrenza
401
4.
T (n) = 32t (n
4) + (logn)
5.
T (n) = 27T (n
3) + (n3 log4 n)
6.
T (n) = 8t (n
4) + ((
N
logn) 1.5)
7.
T (n) = 4t (n
2) + (n 2
logn)
Esercizio 27.1.2
Fornisci soluzioni per i seguenti esempi stranieri:
1.
T (n) = 4t (n
2) + (logn log n3)
2.
T (n) = 4t (n
2) + (2n)
3.
T (n) = 4t (n
2) + (log logn)
4.
T (n) = 4t (n
2 −√n + logn −5) + (n3)
27.2
Alcune prove
Ora presento alcune delle tecniche classiche per il calcolo delle relazioni di ricorrenza.COME
Il nostro esempio risolveremo t (n) = gt (n/0) + f (n), per f (n) = nc.
Indovina e verifica: per iniziare a considerare l'esempio t (n) = 4t
n
2

+ N e T (1) = 1.
Collegamento: se possiamo indovinare t (n) = 2n 2 −n, il primo modo per verificare che questo sia il
La soluzione è semplicemente collegarlo alle due equazioni e assicurarsi che lo siano
soddisfatto:
Lato sinistro
Lato destro
T (n) = 2n 2 −n
4t (n
2) + n = 4

2
n
2
2 -
n
2

−n = 2n 2 −n
T (1) = 2n 2 −n = 1
1
Prova per induzione: allo stesso modo, possiamo usare l'induzione per dimostrare che questa è la soluzione per tutte N (almeno per n = 2i).
Caso base: poiché t (1) = 2 (1) 2 −1 = 1, è corretto per n = 20.
Passaggio di induzione: Sia n = 2i.Supponiamo che sia corretto per 2i - 1 = n
2.Perché
T (n) = 4t (n
2) + n = 4

2
n
2
2 -
n
2

+ n = 2n 2 −n, è anche vero per n.
Calcola i coefficienti: supponiamo che invece siamo in grado di indovinare solo che il
La formula ha la forma t (n) = an 2 + bn + c per alcune costanti a, b e c:
Lato sinistro
Lato destro
T (n) = an 2 + bn + c
4t (n
2) + n = 4

UN
n
2
2 + b
n
2

+ c

−n = an 2 + (2b + 1) n + 4c
T (1) = a + b + c
1

---
layout: 
title: Pagina 418
level: 3
---


Appendice
402
Questi lati sinistro e destro devono essere uguali per tutti n.Entrambi hanno un coefficiente
di N 2, il che è buono.Per rendere il coefficiente di fronte a N è lo stesso, ne abbiamo bisogno
B = 2b + 1, che dà B = −1.Per rendere il coefficiente costante lo stesso, noi
necessita di quel c = 4c, che dà c = 0. per fare t (1) = a (1) 2 + b (1) + c = a (1) 2 -
(1) + 0 = 1, abbiamo bisogno che a = 2. Questo ci dà la soluzione t (n) = 2n 2 −n quella
avevamo prima.
Calcola esponente: se dovessimo indovinare che a · t
n
B

è molto più grande di f (n), quindi t (n) = a · t
n
B

+ f (n) ≈a · t
n
B

.Inoltre immaginiamo che t (n) = nα per
qualche costante α.Collegandolo in t (n) = a · t
n
B

dà nα = a ·
n
B
α o bα =
UN.L'assunzione del registro fornisce α · logb = loga e la risoluzione fornisce α = loga
Logb.In conclusione, t (n) = (nloga/ logb) = (nlog 4/ log 2) = (n 2).
Svolgimento: una tecnica utile è quella di rilassarti una relazione ricorsiva per alcuni passaggi e
Per cercare uno schema:
T (n) = f (n) + a · t
n
B

= f (n) + a ·

F
n
B

+ a · t
n
B 2

= f (n) + af
n
B

+ a2 · t
n
B 2

= f (n) + af
n
B

+ A2 ·

F
n
B 2

+ a · t
n
B3

= f (n) + af
n
B

+ A2f
n
B 2

+ A3 · T
n
B3

= · · ·
=
H - 1

i = 0
ai · f
n
bi

+ ah · t (1) =

H

i = 0
ai · f
n
bi

.
Riempimento della tabella: il mio modo consigliato per valutare le relazioni ricorsive è quello di riempire
Una tabella come quella nella Figura 27.1.
(a) Numero di frame dello stack a livello ITH: il livello 0 contiene l'unico iniziale
Frame di pila nella parte superiore dell'albero della cornice dello stack.Chiama in modo ricorsivo volte.Quindi, il livello 1 ha una cornici di stack.Ognuno di questi chiama in modo ricorsivo un tempo, dando uno stack A2
frame al livello 2. Ogni livello successivo, il numero di frame dello stack aumenta di a
Fattore di A, dando AI al livello I.
(b) Dimensione dell'istanza a livello ITH: il telaio dello stack superiore al livello 0 viene data un'istanza di dimensione n.Si ripresenta su una sottoinstabilità della dimensione n
B .Frame in pila al livello 1, date istanze di dimensione n
B, ricuruto sulla sottoinstabilità della dimensione N/B 2. ogni successivo
Il livello riduce la dimensione dell'istanza di un fattore B, dando dimensioni N/Bi al livello I.
(c) Tempo all'interno di un telaio dello stack: su un'istanza di dimensione N, un singolo telaio dello stack
richiede tempo f (n).Quindi, un telaio dello stack a livello ITH, con un'istanza di dimensioni
N/BI, richiede tempo F (n/bi).
(d) Numero di livelli: il programma ricorsivo smette di ricorrere quando l'istanza
diventa sufficientemente piccolo, diciamo della dimensione 0 o 1. Sia h denoti il ​​livello al quale questo

---
layout: 
title: Pagina 419
level: 3
---


403
Esempio
T (n) = 4t (n/2) + n
T (n) = 9t (n/3) + n2
T (n) = 2t (n/4) + n2
(a) No. di fotogrammi a livello ith
4i
9i
2i
(b) dimensione dell'istanza a livello
N
2i
N
3i
N
4i
(c) Tempo all'interno di un telaio dello stack
F
n
2i

=
n
2i

F
n
3i

=
n
3i
2
F
n
4i

=
n
4i
2
(d) No. di livelli
N
2H = 1
H = Logn
log 2 = (logn)
N
3H = 1
H = Logn
log 3 = (logn)
N
4H = 1
H = Logn
log 4 = (logn)
(e) No. di cornici dello stack di base di base
4h = 4
Logn
Log 2
= n
Log 4
log 2 = n 2
9h = 9
Logn
Log 3
= n
Log 9
log 3 = n 2
2H = 2
Logn
Log 4
= n
Log 2
log 4 = n
1
2
(f) t (n) come somma
H
i = 0 (# a livello) · (tempo ciascuno)
= (logn)
i = 0
4i ·
n
2i

= n · (logn)
i = 0
2i
H
i = 0 (# a livello) · (tempo ciascuno)
= (logn)
i = 0
9i ·
n
3i
2
= n 2 · (logn)
i = 0
1
H
i = 0 (# a livello) · (tempo ciascuno)
= (logn)
i = 0
2i ·
n
4i
2
= n 2 · (logn)
i = 0
1
8
io
(g) Dominato da?
Aumento geometrico:
Casi di base
Somma aritmetica:
tutti i livelli
Diminuzione geometrica:
Livello di alto livello
(h) (t (n))
T (n) =

nloga/ logb
=

N
Log 4
Log 2

=

N 2
T (n) =

f (n) logn

=

N 2 Logn

T (n) =

F (N)

=

N 2
Figura 27.1: Risoluzione t (n) = a · t
n
B

+ (NC) colpendo nella tabella.

---
layout: 
title: Pagina 420
level: 3
---


Appendice
404
si verifica.Abbiamo visto che le istanze al livello H hanno dimensioni n/bh.Impostazione n/bh = 1
e risolvere per H dà h = logn
Logb.
(e) Numero di telai dello stack del caso di base: il numero di frame dello stack al livello I
è ai.Quindi, il numero di frame dello stack del caso di base è Ah = alogn/ logb.Anche se
Questo sembra brutto, il capitolo 24 fornisce alogn/ logb = (2loga) logn/ logb = 2loga · logn/ logb =
(2logn) loga/ logb = nloga/ logb.Dato quel loga
logb è semplicemente un po 'costante, nloga/ logb è un
Polinomio semplice in n.
(f) t (n) come somma: ci sono cornici di stack AI al livello I e ciascuno richiede f (n/bi)
tempo, per un totale di Ai · F (N/BI) a livello.Otteniamo il tempo totale t (n) per il
ricorsione sommando i tempi a tutti questi livelli.Questo da
T (n) =

H - 1

i = 0
ai · f
n
bi

+ ah · t (1) =

H

i = 0
ai · f
n
bi

.
Collegamento di f (n) = nc dà
T (n) =

H

i = 0
ai ·
n
bi
c

=

NC ·
H

i = 0
a
avanti Cristo
io

(g) dominato da: le cose chiave da ricordare di questa somma sono che ha
(logn) Termini, il miglior termine è statoa f (n/b◦) = f (n) e il termine del caso base.
AN F (n/ bn) = alogn/ logb f (n) = nloga/ logb (nloga/ logb).Secondo le approssimazioni di Addingmade-Easy indicate nel capitolo 26, se il termine più alto o la base
Il termine del caso è sufficientemente più grande dell'altro, quindi il totale è dominato da questo
termine.D'altra parte, se sono all'incirca gli stessi, allora il totale è approssimativamente il numero di termini di un termine tipico.
(h) Valutazione della somma: se
loga
logb <c, quindi a/bc <1, dando che i termini in
T (n) =
(NC · H
i = 0 (a
bc) i) diminuire esponenzialmente, dando t (n) = (termine superiore) = (f (n)).
Allo stesso modo, se
loga
logb> c, quindi i termini aumentano in modo esponenziale, dando t (n) =
(termine del caso base) = (nloga/ logb).
Se
loga
logb = c, quindi
UN
bc = 1, dando
T (n) =
(NC · H
i = 0 (a
bc) i) = (nc · h
i = 0 1) = (nc · h) = (f (n) logn).
Esercizio 27.2.1 (vedi soluzione nella parte cinque.) Risolvi la famosa ricorrenza di Fibonacci
relazione fib (0) = 0, fib (1) = 1 e fib (n) = fib (n −1) + fib (n −2) collegando
FIB (N) = αn e risoluzione per α.
Esercizio 27.2.2 (vedi soluzione nella parte quinta.) Risolvi quanto segue, rilassandoli:
1.
T (n) = t (n −1) + n
2.
T (n) = 2 · t (n −1) + 1

---
layout: 
title: Pagina 421
level: 3
---


405
Esempio
T (n) = at (n −b) + nc
T (n) = t (n −b) + nc
T (n) = t (n −b) + 0
(a) No. di fotogrammi a livello ith
AI
1
(b) dimensione dell'istanza a livello
n −i · b
(c) Tempo all'interno di un telaio dello stack
f (n −i · b) = (n −i · b) c
f (n −i · b) = 0
Tranne il caso base, che ha lavoro (1)
(d) No. di livelli
n −h · b = 0, h = n
B
Avere un caso di base di dimensioni zero rende la matematica il più pulito.
(e) NO delle cornici dello stack di base di base
Ah = a
1
b n
1
(f) t (n) come somma
H
i = 0 (# a livello) · (tempo ciascuno)
= n/b
i = 0 ai · (n −i · b) c
H
i = 0 (# a livello) · (tempo ciascuno)
= n/b
i = 0 1 · (n −i · b) c
H
i = 0 (# a livello) · (tempo ciascuno)
=
N/B - 1
i = 0
1 · 0

+ 1 · (1)
= (1)
(g) dominato da
Aumento geometrico:
Casi di base
Somma aritmetica:
tutti i livelli
Diminuzione geometrica:
Casi di base
(h) (t (n))
T (n) =

an/b
T (n) =
n
B · nc
= (NC+1)
T (n) = (1)
Figura 27.2: Risoluzione di t (n) = a · t (n −b) + (nc) mediante riempire nella tabella.

---
layout: 
title: Pagina 422
level: 3
---


Appendice
406
Esercizio 27.2.3 L'impostazione delle dimensioni del caso di base su 5 ha qualche effetto pratico?
Che ne dici di impostare le dimensioni su zero, ovvero n/bh = 0?
Perché succede?Se invece le istanze a livello di Theith avessero la dimensione N -ItShape AB, una dimensione di istanza di 0, 1 o 2 sarebbe migliore?Quanti livelli H ci sono?
Esercizio 27.2.4 (vedere la soluzione nella parte cinque.) La sezione 27.2 risolve t (n) = at (n/b) +
f (n) per f (n) = nc.Se f (n) = nc logd n e loga
logb = c, allora la matematica è più difficile.Calcolare
La somma per d> −1, d = −1, d <−1.(Suggerimento: invertire l'ordine dei termini.)
Esercizio 27.2.5
Utilizzare il metodo nella Figura 27.2 per calcolare ciascuno dei seguenti
relazioni ricorsive.
1.
T (n) = nt (n −1) + 1
2.
T (n) = 2t (√n) + n
3.
T (n) = t (u · n) + t (v · n) + (n) dove u + v = 1.
Esercizio 27.2.6 Tempo di esecuzione:
Algoritmo Attenta (N)
⟨Pre-Cond⟩: n è un numero intero.
⟨Post-Cond⟩: Q (n) “hi” sono stampati per una funzione dispari q
inizio
if (n ≤1)
Printhi (1)
altro
Loop i = 1...N
Printhi (i)
End Loop
Loop i = 1...8
Attento (n
2)
End Loop
finisci se
Algoritmo di fine
Algoritmo Printhi (N)
⟨Pre-Cond⟩: n è un numero intero.
⟨Post-Cond⟩: n 2 “hi” sono stampati
inizio
Loop i = 1...n 2
Stampa ("HI")
End Loop
Algoritmo di fine

---
layout: 
title: Pagina 423
level: 3
---


Relazioni di ricorrenza
407
1.
Dare e risolvere la relazione di ricorrenza per il numero di "hi" s, q (n).Mostra il tuo
lavoro.Dai una frase o due dando l'intuizione.
2.
Qual è il tempo di esecuzione (complessità temporale) di questo algoritmo in funzione del
Dimensione dell'input?

---
layout: 
title: Pagina 424
level: 3
---


408
28 Una prova formale di correttezza
Anche se intendo non deve essere troppo formale, è utile almeno comprendere il richiesto
Passi in una prova formale di correttezza.
Specificazioni: prima di dimostrare che un algoritmo è corretto, dobbiamo sapere esattamente cosa dovrebbe fare.
Precondizioni: le affermazioni promesse sono vere sull'istanza di input.
Postconditions: affermazioni che devono essere vere per l'output.
Correzione: considera qualche istanza.Se questa istanza soddisfa i precondizioni, allora
Dopo che il codice è stato eseguito, l'output deve soddisfare i postcondizioni:
⟨Pre-Cond⟩ & codealg ⇒⟨post-conf⟩
La correttezza di un algoritmo è solo rispetto alle specifiche dichiarate.Esso
non garantisce che funzionerà in situazioni che non sono prese in considerazione da
Questa specifica.
Rompere il percorso di calcolo in frammenti: il metodo per dimostrare che un
L'algoritmo è corretto è il seguente.Le asserzioni sono inserite nel codice per fungere da punti di blocco.Ogni affermazione è una dichiarazione sullo stato attuale del calcolo
strutture di dati che sono vere o false.Se è falso, allora qualcosa è andato storto
Nella logica dell'algoritmo.Queste asserzioni rompono il percorso del calcolo
frammenti.Per ogni frammento di questo tipo, dimostriamo che se l'asserzione all'inizio
del frammento è vero e il frammento viene eseguito, quindi l'affermazione alla fine
del frammento sarà vero.La combinazione di tutti questi frammenti di ritorno lo dà
Se la prima affermazione è vera e l'intero calcolo viene eseguita, l'ultima affermazione sarà vera.
Un numero enorme di percorsi: è probabile che ci siano un numero esponenziale o persino un numero infinito di percorsi diversi che il calcolo potrebbe prendere, a seconda del
istanza di input e test che si verificano lungo la strada.Al contrario, non ce ne sono molti

---
layout: 
title: Pagina 425
level: 3
---


Una prova formale di correttezza
409
frammenti di percorso di calcolo diversi.Quindi, è molto più facile dimostrare la correttezza di ciascun frammento rispetto a ciascun percorso.
La tabella seguente delinea i frammenti del percorso computazionale che devono essere
Testato per diverse strutture di codice.
Singola riga di codice:
⟨Pre-Assignment-Cond⟩: le variabili xey hanno valori significativi.
z = x + y
⟨Post-Assignment-Cond⟩: la variabile z assume la somma del valore di x e
il valore di y.Il valore precedente di Z è perso.
Blocchi di codice:
⟨Assertion0⟩
Code1
⟨Assertion1⟩
Code2
⟨Assertion2⟩
[⟨Assertion0⟩ & code1 ⇒⟨assertion1⟩]
[⟨Assertion1⟩ & code2 ⇒⟨assertion2⟩]

⇒ [⟨assertion0⟩ & code1 e 2 ⇒⟨assertion2⟩]
Se dichiarazioni:
⟨Pre -if -cond⟩
if (⟨test⟩) allora
codetrue
altro
CodeFalse
finisci se
⟨Post -if -cond⟩
[⟨Pre -if -cond⟩ &
⟨Test⟩ & codetrue ⇒⟨post -if -cond⟩]
[⟨Pre -if -cond⟩ & ¬⟨test⟩ & codefalse ⇒⟨post -if -cond⟩]

⇒ [⟨pre -if -cond⟩ & Code ⇒⟨post -if -cond⟩]
Loop:
⟨Pre-loop-cond⟩
ciclo continuo
⟨Loop-invar⟩
uscite quando ⟨exit-conf⟩
Codeloop
End Loop
⟨Post-loop-Cond⟩
*
[⟨Loop-Invar′⟩ & ¬⟨exit-Cond⟩ & CodeLoop ⇒⟨Loop-Invar′′⟩]
[⟨Loop-invar⟩ &
⟨Exit-Cond⟩ Heapost-loop-Cond⟩]
Terminazione
⎫
⎪
⎪
⎪
⎬
⎪
⎪
⎪
⎭
⇒ [⟨pre-loop-conf⟩ & Code ⇒⟨post-loop-conf⟩]
Chiamata di funzione:
⟨Pre-Call-Cond⟩
output = func (input)
⟨Post-Call-Cond⟩
[⟨Pre-Call-Cond⟩ HeapRe-Cond⟩func]
[⟨Post-Cond⟩func ⇒⟨Post-Call-Cond⟩]

⇒ [⟨Pre-Call-Cond⟩ & Code ⇒⟨post-Call-Cond⟩]

---
layout: 
title: Pagina 426
level: 3
---


---
layout: 
title: Pagina 427
level: 3
---


411
Parte quinta
Soluzioni di esercizio
Capitolo 1. Algoritmi iterativi: misure di progresso e invarianti ad anello
1.4.1 Ordine di selezione: se l'input per l'ordinamento di selezione viene presentato come un marsupio di valori, quindi
L'ordinamento può accadere in atto.Le prime voci K dell'array memorizzano il sublist ordinato, mentre le voci rimanenti memorizzano il set di valori che si trovano sul lato.Trovare il
Valore più piccolo da un [k + 1]...A [n] implica semplicemente la scansione dell'elenco per questo.Una volta
si trova, spostandolo alla fine dell'elenco ordinato implica solo lo scambiarlo con il
valore a un [k + 1].Il fatto che il valore a [k + 1] sia spostato in un luogo arbitrario in
Il lato destro dell'array non è un problema, perché questi valori sono considerati
Essere comunque un set non desiderato.Il tempo di esecuzione viene calcolato come segue.Dobbiamo selezionare n volte.Selezionando da un sublist di dimensioni I richiede (i) tempo.Quindi, il tempo totale è
(N + (N - 1) + · · · + 2 + 1) = (N2) (vedi capitolo 26).
1.4.2 Ordina di inserimento: ci sono due passaggi coinvolti nell'inserimento di un elemento in un elenco ordinato.
Il passo più ovvio è individuare dove appartiene.Il secondo passo per spostare tutti gli elementi più grandi del nuovo elemento uno a destra per fare spazio.Voi
può trovare la posizione per il nuovo elemento rapidamente utilizzando una ricerca binaria.Tuttavia, lo è
più facile cercare e spostare gli elementi più grandi contemporaneamente.
Elenco collegato: avere gli elementi ordinati memorizzati in un elenco collegato consente di inserire il
Nuovo elemento in tempo costante.Tuttavia, quindi ci vuole tempo (k) per trovare dove il nuovo
l'elemento va.
Tempo di esecuzione: dobbiamo inserire n volte.Inserire in un sublist di dimensioni I richiede (i) tempo.
Quindi, il tempo totale è (1 + 2 + 3 + · · · + n) = (N2).
Ordine heap: vedremo nella Sezione 10.4 che ciascuno di questi passaggi può essere eseguito in (Logn)
Tempo in cui gli elementi sono archiviati in una struttura di dati chiamata heap.
1.4.3 L'algoritmo passa ripetutamente attraverso l'array, scambiando coppie adiacenti se necessario.
Dopo K tali passaggi, i più grandi elementi K hanno gorgogliato fino a dove appartengono.
Pertanto, richiede al massimo N passaggi fino a quando tutti gli elementi sono in atto.Ogni passaggio richiede
n confronti.

---
layout: 
title: Pagina 428
level: 3
---


Soluzioni di esercizio
412
1.5.1 Ci sono una serie di problemi.
1. Un loop invariante deve essere un quadro dello stato attuale e non dire cosa fa l'iterazione.L'invariante del loop dovrebbe essere semplicemente s = i
j = 1 j.
2. L'anello invariante non è stabilito correttamente.Coni = 1, richiede l'invariante in loop
s = 1
j = 1 j = 1, non s = 0. La scelta s = 0 e i = 0 sarebbe migliore.
3. L'anello invariante non viene mantenuto correttamente.Sia s ′ e i ′ essere i valori di s e i
quando in cima al ciclo.Sia S ′ ′ e i ′ ′ essere i valori dopo essere tornato in giro.IL
Loop invariant dà quell'e ′ = i ′
j = 1 j.Il codice fornisce che S ′ ′ = S ′ + I ′ e I ′ ′ = I ′ + 1.
Insieme questi danno che s ′ ′ = (i ′
j = 1 j) + i ′.Questo non è I ′+1
j = 1 j come richiesto, perché
Io ′ viene aggiunto in due volte.I ′ + 1 dovrebbe essere aggiunto per mantenere il loop
invariante.
4. La condizione di uscita non è molto ben dichiarata.Una condizione di uscita equivalente e più facile da vedere sarebbe "uscire quando i> I."
5. La condizione di uscita, i> i, e il loop invariante, s = i
j = 1 j, insieme non danno il
Postcondition.Invece, danno quello s = i+1
j = 1 j viene restituito.
6. L'algoritmo nel suo insieme funziona.Un rapido ﬁ x è cambiare il loop invariante
a s = i - 1
j = 1 j.
CAPITOLO 2. Esempi che utilizzano invarianti loop più di Input
2.2.1
Dividi: scusa, non fornito.
Calcolatrice:
Algoritmo Calculator ()
⟨Pre-Cond⟩: viene inserito un flusso di comandi.
⟨Post-Cond⟩: i risultati vengono visualizzati su una schermata.
inizio
Allocati accum, corrente ∈ {0..108 −1}
Allocati schermo ∈ {showa, showc}
accum = corrente = 0
Screen = showc
ciclo continuo
⟨Loop-invariant⟩: la memoria limitata della macchina ricorda il
Valore corrente dell'accumulatore e il valore corrente in cui viene inserito.Anche
ha una variabile booleana che indica se lo schermo dovrebbe visualizzare il
corrente o valore dell'accumulatore.
Ottieni (c)
if (c ∈ {0..9})
corrente = 10 × corrente + c mod 108
Screen = showc
else if (c = ′ +′) quindi
accum = accum + corrente mod 108
corrente = 0
Screen = ShowA
else if (c = ′ clr ′) quindi
accum = 0

---
layout: 
title: Pagina 429
level: 3
---


Soluzioni di esercizio
413
corrente = 0
Screen = showc
finisci se
if (screen = showc) quindi
Visualizza (corrente)
altro
Visualizza (accum)
finisci se
End Loop
Algoritmo di fine
Blocco più lungo di quelli:
Algoritmo LongestBlockOns (a, n)
⟨Pre-Cond⟩: L'ingresso è a, un array 0, 1 di lunghezza n.
⟨Post-Cond⟩: l'output è la posizione A [k1..k2] del blocco più lungo di quelli e il suo
lunghezza Leng.
inizio
i = 0;pMax = 1;qmax = 0;LengMax = 0;pcurrent = 1;LengCurrent = 0 ∈ {0..n}
ciclo continuo
⟨Loop-invariant⟩: a [pmax, qmax] è un blocco più lungo di quelli in un [1..I] e
LengMax = Qmax −Pmax+1 è la sua lunghezza.
Un [pcurrent, i] è il blocco più lungo di quelli in un [1..I] che terminano in un [i] e
LengCurrent = I −PCurrent+1 è la sua lunghezza.
uscita quando i = n
if (a [i+1] = 1) quindi
LengCurrent = LengCurrent + 1
altro
pcurrent = i+2
LongCurrent = 0
finisci se
if (LengMax <LengCurrent)
pMax = pcurrent
qmax = i + 1
LongMax = lunghezza
finisci se
i = i + 1
End Loop
restituire un [pMax, qmax]
Algoritmo di fine
2.3.1
(2): l'invariante in loop è:
UN.L'inizio [0, a] della torta è stato partizionato in | Q |pezzi disgiunti.
B.Ogni giocatore pi ∈q è stato assegnato un pezzo [ai, bi] del valore di almeno 1
n a lui.
C.L'intervallo restante [a, 1] della torta vale almeno (n - | q |)/n a ciascuno dei
giocatori rimanenti, cioè a quelli in p −q.

---
layout: 
title: Pagina 430
level: 3
---


Soluzioni di esercizio
414
(3):
Partizione algoritmo (P)
⟨Pre-Cond⟩: come sopra
⟨Post-Cond⟩: come sopra
inizio
a = 0 e q = ∅
ciclo continuo
⟨Loop-invariant⟩: come sopra.
Esci quando | Q |= n
Loop i ∈P −q
ci = taglio (pi, a, 1
N )
End Loop
imin = i ∈P −q che minimizza CI
[Aimin, bimin] = [a, cimin]
a = cimin
Q = Q + imin
End Loop
restituire tutte le parti [ai, bi] per ogni i ∈p
Algoritmo di fine
(1), (4) - (7): scusa, le soluzioni rimanenti non sono fornite.
Capitolo 3. Tipi di dati astratti
3.1.5 Invece di delimitare l'altezza data il numero di nodi, è più facile calcolare il
relazione inversa.Sia N (h) il numero minimo di nodi in un albero AVL di altezza h.
Affinché un albero sia di altezza H, deve avere almeno una metropolitana di altezza H −1.In
Ordine che sia un albero AVL, l'altro sottostruttura può differire al massimo, quindi deve averlo
Altezza almeno H −2.Ne consegue che il numero di nodi in questo albero è almeno n (h) =
N (H - 1) + N (H - 2) + 1. ad eccezione del +1 della radice, questo è lo stesso del famoso
Numeri di fibonacci definiti da FIB (n) = fib (n - 1) + fib (n - 2).L'esercizio 27.2.1 continua
per dimostrare che Fib (n) = (αn), dove α = 1+
√
5
2
.Se n (h) = (αn), allora H (n) = (logn).
3.2.4 I test verranno eseguiti nell'ordine in cui sono elencati.Se il prossimo = nullo viene testato per la prima volta e
passa, quindi perché c'è un o tra le condizioni, non è necessario testare il
secondo.Tuttavia, se il prossimo.info ≥Key è il primo test e successivo è nullo, quindi usando Next.info a
Recupera le informazioni nel nodo indicato da Next causerà un errore di runtime.
Capitolo 4. Restringendo lo spazio di ricerca: ricerca binaria
4.4.1 Fare la ricerca binaria nel tempo O (log (n × m)) è impossibile.Vedi il limite inferiore in questione (esercizio 7.0.7).Se prendi il tempo O (n logm) facendo ricerche binarie in ogni riga, allora
Stai prendendo troppo tempo.Può essere fatto esaminando le voci N + M −1.Osservare che i valori nella matrice aumentano da [1, 1] a [n, m].Quindi, il confine tra valori che sono inferiori o uguali a x e quelli che sono maggiori segue
Qualche percorso monotonico da un [1, m] a un [n, 1].L'algoritmo traccia questo percorso iniziando
a un [1, m].Quando è al punto un [i, j], l'invariante in loop è che abbiamo conservato il

---
layout: 
title: Pagina 431
level: 3
---


Soluzioni di esercizio
415
Migliore risposta da coloro che sono al di fuori del subrettangolo A [i..n, 1..j].Inizialmente, questo è vero per
[i, j] = [1, m], perché nessuna matrice è esclusa.Supponiamo ora che sia vero per un arbitrario [i, J].L'algoritmo quindi confronta un [i, j] con x.Se è meglio del nostro meglio attuale
Risposta, quindi il nostro meglio attuale viene sostituito.Se a [i, j] ≤x, allora perché i valori in
la riga A [i, 1..j] è tutte più piccole o uguali a un [i, j], queste sono risposte peggiori, e quindi
Possiamo concludere che ora abbiamo la migliore risposta da coloro che sono al di fuori del subrettangolo A [i + 1..n, 1..j].Manteniamo il ciclo invariante aumentando I di uno.Dall'altra
mano, se un [i, j]> x, allora è troppo grande e così sono tutti gli elementi nella colonna A [i..n, J]
che sono ancora più grandi.Possiamo concludere che abbiamo la migliore risposta da coloro che
del subrettangolo a [i..n, 1..j −1].Manteniamo l'invariante invariante diminuendo J
uno.La condizione di uscita è | i..n |= 0 o | 1..j |= 0 (cioè, i> n o j <1. quando ciò si verifica, il
Il subrettangolo A [i..n, 1..j] è vuoto.Quindi, la nostra migliore risposta, che dall'anello invariante è
Il meglio da quelli al di fuori di questo subrettangolo, deve essere il migliore in generale.La misura di
Progressi, | i..n |+ | 1..j |−1 = (n −i + 1) + (j) −1, inizialmente n + m −1 e diminuisce di
Uno ogni iterazione.Dopo iterazioni N + M −1, l'algoritmo si è già interrotto o
La misura ha raggiunto lo zero, a quel punto la condizione di uscita viene soddisfatta definitivamente.
Capitolo 6. Algoritmo GCD di Euclid
6.0.2
;del ciclo e presumi che ℓ ′ ×
R ′ + S ′ = X × Y.
Nel primo passaggio, se ℓ ′ è dispari, quindi ℓ ′ ′ = ℓ ′ −1 e S ′ ′ = S ′ + R ′.Questo dà che ℓ ′ ′ × r ′ ′ +
S ′ ′ = (ℓ ′ −1) × R ′ + (S ′ + R ′) = ℓ ′ × R ′ + S ′, che per loop invariante è x × y.
Nel secondo passaggio, ℓ ′ ′ ′ = ℓ ′ ′/2 e r ′ ′ ′ = 2r ′ ′.Questo dà che ℓ ′ ′ ′ × r ′ ′ ′ + S ′ ′ ′ = (ℓ ′ ′/2) ×
(2R ′ ′) + S ′ ′ = ℓ ′ ′ × R ′ ′ + S ′ ′, che per loop invariante è x × y.
(4): gli etiopi escono quando ℓ = 1. Ma è strano, devono aggiungere r a s.Noi
iterare ancora un altro tempo ed esci quando ℓ = 0. Questa condizione di uscita dà s = ​​ℓ × r + s e
L'anello invariante dà ℓ × r + s = x × y.Quindi, alla fine s = x × y.
(1), (3), (5) e (6): scusa, non fornito.
Capitolo 7. Il ciclo invariante per limiti inferiori
7.0.2 Il limite è n ≤rt.
Ogni round, seleziona una riga;Quindi, ci sono REGLIE RISPOSTE.Dopo T round, ci sono possibili combinazioni di risposte.
L'unica informazione che conosci è quale di queste combinazioni ti ha dato.
Quale carta che produci dipende determinalmente (nessuna magia) dalla combinazione di
Risposte date.Quindi, a seconda delle sue risposte, ci sono al massimo le carte RT che
potresti produrre.
Tuttavia, ci sono n carte, una delle quali può essere la carta selezionata.In conclusione, n ≤rt.
Il libro ha n = 21, r = 3 e t = 2. perché 21 = n ̸≤rt = 32 = 9, il trucco in
Il libro non funziona.
Due round non sono sufficienti.Ci devono essere tre round.

---
layout: 
title: Pagina 432
level: 3
---


Soluzioni di esercizio
416
7.0.3 È una domanda di trucco, perché con un equilibrio ci sono tre, non due, risultati e
Quindi sono necessarie solo operazioni di log3 n.Dividi gli oggetti in tre pile, due di uguali
dimensioni e la terza il più vicino possibile.Metti le prime due pile sulla scala.Se uno è più pesante, allora contiene l'oggetto più pesante;altrimenti la terza pila lo fa.Si ripresenta su questo
mucchio.
7.0.6 Nel limite inferiore per la parità, qualsiasi input iniziale che avrei funzionato ugualmente bene.Qui, tuttavia, c'è solo un input che funzionerà, e questo è la stringa all-zero.
Ciò garantisce che, come prima, cambiando il bit Jth di I, per qualsiasi j ∈J = [1, n], cambia il
Rispondi da e essendo zero a e essendo uno.Ciò dimostra che qualsiasi algoritmo
Risolvere il problema richiede tempo di almeno n.
Capitolo 8. Abstrazioni, tecniche e teoria
8.5.2ra: si potrebbe lamentarsi che se la mia istanza è ⟨n, M⟩, allora l'istanza del mio amico non può
essere ⟨n −1, 2m⟩, perché 2m non è più piccolo di m.Tuttavia, possiamo definire le dimensioni
di istanza ⟨n, m⟩to essere semplicemente n.Secondo questa misura, l'istanza del mio amico
è davvero più piccolo.Inoltre, quando l'istanza diventa di dimensioni zero o più piccole, quindi
n ≤0 e la ricorsione si ferma.Dimostriamo che la profondità della ricorsione è al massimo come segue.In istanza ⟨n, M⟩, la dimensione inizia da N e diminuisce di almeno uno ogni livello
di ricorsione, quindi dopo n livelli la dimensione è al massimo zero e l'algoritmo smette di ricorrere ulteriormente.Ad esempio, a partire da ⟨5, 2⟩, si ripresenta su ⟨4, 4⟩, ⟨3, 8⟩ ,..., ⟨0, 64⟩, quindi si ferma.
RB: Si potrebbe affermare che tutto va bene perché entrambi gli amici ottengono istanze (⟨n −1, m⟩and
⟨N, m −1⟩) che sono più piccoli.Tuttavia, affinché ciò sia vero per entrambi gli amici, le dimensioni devono
Sii qualcosa di simile a n + m.Tuttavia, secondo questa definizione, l'istanza ⟨5, −5⟩
è piccolo, ma l'algoritmo non si ferma.C'è un percorso lungo questo albero ricorsivo che
è in ﬁ nite, vale a dire ⟨n, m⟩, ⟨n, m −1⟩, ⟨n, m −2⟩ ,...⟨N, 1⟩, ⟨n, 0⟩, ⟨n, −1⟩, ⟨n, −2⟩....
RC: Qui le dimensioni dell'istanza ⟨n, m⟩can devono essere definite n + m.Secondo questo
Misura, a ogni amico viene data un'istanza più piccola.Inoltre, se le dimensioni sull'istanza
è zero, quindi n ≤0 o m ≤0.Ad ogni modo il programma si interrompe.La profondità della ricorsione può essere al massimo n + m perché questa è la dimensione iniziale e la dimensione diminuisce di
Uno ogni iterazione.
RD: Lascia che le dimensioni dell'istanza ⟨n, M⟩be 5n + 2m.Quindi la prima istanza dell'amico
⟨N −1, M + 2⟩HAS Dimensione 5 (N −1) + 2 (M + 2) = 5N + 2M −1, che è uno più piccolo.IL
istanza del secondo amico ⟨n + 1, m −3⟩HAS Dimensione 5 (n + 1) + 2 (m −3) = 5n + 2m −1, che è anche uno più piccolo.Inoltre, se la dimensione sull'istanza è zero, allora
n ≤0 o m ≤0.Ad ogni modo il programma si interrompe.La profondità della ricorsione può essere al massimo
5n + 2m perché questa è la dimensione iniziale e la dimensione diminuisce di una iterazione.
Ri: Affermo che esiste un percorso lungo questo albero di ricorsione che è in modo ﬁ nito.Se la mia istanza è
⟨N, m⟩, quindi il mio primo amico ha ⟨n −4, m + 2⟩, il suo primo amico ha ⟨n −8, m + 4⟩, suo
Il primo amico ha ⟨n −12, m + 6⟩, il suo secondo amico ha ⟨n −6, m + 3⟩ e il suo secondo
L'amico ha ⟨n, che è uguale alla mia istanza.Questo può essere ripetuto in modo ignitore
Spesso.
È interessante che gli ultimi due esempi possano essere generalizzati alle istanze dell'amico
di dimensioni ⟨n −a, m + b⟩and ⟨n + c, m −d⟩.Se ad> bc, allora il programma si interrompe, altrimenti
non.

---
layout: 
title: Pagina 433
level: 3
---


Soluzioni di esercizio
417
8.6.2
Divertente (1) = x
Divertente (2) = y
Divertente (3) = aybxc
Divertimento (4) = a aybxc b y c
Divertimento (5) = a aaybxcbyc b aybx c
Divertimento (6) = a aaaybxcbycbaybxc b aaybxcbyc c
8.7.2 Per dimostrare s (0), lascia che n = 0 nella fase induttiva.Non ci sono valori k in cui 0 ≤k <n.
Quindi, non vengono fatti ipotesi.Quindi, la tua prova dimostra S (0) da sola.
Capitolo 9. Alcuni semplici esempi di algoritmi ricorsivi
9.1.1 Ordine di inserzione e selezione.
9.1.2 1. Dato ⟨A1, A2 ,..., an⟩, rimuovo l'ultimo personaggio an.Do ⟨a1, a2 ,..., an - 1⟩to mio
amico, e restituisce la tupla invertita ⟨an - 1 ,..., a1⟩to me.Aggiungo una parte anteriore
della tupla, producendo ⟨an, an -1 ,..., a1⟩as richiesto.Se la mia tupla iniziale ha solo zero
(o un) elemento, quindi non c'è nulla da fare.
Algoritmo Reverse (⟨A1, A2,., An⟩)
⟨Pre-Cond⟩: un'istanza è una tupla.
⟨Post-Cond⟩: l'output è la tupla inversa ⟨an, an-1 ,..., A1⟩.
inizio
if (n = 0 o n = 1) quindi
restituzione (istanza invariata)
altro
restituzione (⟨an, reverse (⟨a1, a2,., an -1⟩)⟩)
finisci se
Algoritmo di fine
2. Il programma iterativo ha due loop (non -nestate).Il primo spinge ogni elemento
Sullo stack, uno alla volta, a partire da un.L'anda invariante è che dopo io
iterazioni ciò che rimane nella tupla è ⟨a1, a2 ,..., an -i - 1, an -i⟩ e lo stack contiene
⟨An - i+1, an -i+2 ,..., an⟩ con an -i+1 nella parte superiore.At thei = 0 iterazione, il loop invariante
è banalmente vero.L'iterazione successiva rimuove l'ultimo elemento an -i dalla tupla e
lo spinge sullo stack.Questo mantiene l'invariante invariante mentre fa progressi.In
la fine, coni = n, ⟨a1, a2 ,..., an⟩is sullo stack con A1 in cima.Il secondo ciclo
Fa emergere ogni elemento dallo stack e lo mette all'inizio della tupla.L'anello invariante è che dopo le iterazioni, lo stack contiene di nuovo ⟨ai+1, ai+2 ,..., an⟩ con ai+1
Nella parte superiore, ma ora la tupla è ⟨ai, ai - 1 ,..., A2, A1⟩.Coni = n, lo stack è vuoto e
La tupla è ⟨an, an -1 ,..., A2, A1⟩.
3. La ricorsione è implementata su un computer, utilizzando uno stack di cornici dello stack.Il primo
Il telaio stack è dato ⟨A1, A2 ,..., an⟩, e rimuove e ricorda l'ultimo personaggio e.Il suo amico è il secondo telaio dello stack, che viene dato ⟨A1, A2 ,..., an -1⟩.Rimuove e ricorda il suo ultimo personaggio AN - 1.Mentre ricordiamo più a fondo, le cornici dello stack
che non sono ancora completati vengono spinti su uno stack.Dopo che ho tali frame in pila, il
Loop invariant è che l'amico dell'amico...Amico viene dato il tupla

---
layout: 
title: Pagina 434
level: 3
---


Soluzioni di esercizio
418
⟨A1, A2 ,..., an -i - 1, an -i⟩ e lo stack contiene frame dello stack, ognuno ricordando uno
degli elementi an -i+1, an -i+2 ,..., an, con an -i+1 nella parte superiore.Nota questo è lo stesso
Loop invariant come programma iterativo.Il caso di base ricorsivo viene raggiunto quando
i = n e il telaio dello stack viene data la tupla vuota.Quindi, uno alla volta, al contrario
ordina i frame dello stack completare i loro calcoli aggiungendo il suo elemento a
l'inizio della tupla.L'anello invariante è che dopo tali ritorni, lo stack
di frame stack ricorda AI+1, AI+2 ,..., An con Ai+1 nella parte superiore e il telaio dello stack corrente sta restituendo la tupla ⟨ai, ai - 1 ,..., A2, A1⟩.Ancora una volta, nota che questo è il
Lo stesso ciclo invariante dell'algoritmo iterativo.Con i = n, lo stack è vuoto e il
Il primo telaio di stack restituisce la tupla ⟨an, an -1 ,..., A2, A1⟩.
9.2.1
1).Dati i numeri interi A e B, l'algoritmo iterativo crea due numeri x = B e
y = un mod b.Nota che GCD (A, B) = GCD (X, Y), e quindi può restituire GCD (X, Y)
Invece di GCD (A, B).Questo algoritmo è ancora più facile quando hai un amico.Diamo semplicemente la sottoinstance ⟨x, y⟩to all'amico e calcola GCD (x, y) per noi.Per
L'algoritmo iterativo, dobbiamo assicurarci di fare progressi e, per l'algoritmo ricorsivo, dobbiamo assicurarci di dare all'amico un'istanza più piccola.
Ad ogni modo, ci assicuriamo che in qualche modo ⟨x, sia più piccolo di ⟨a, b⟩.Per l'algoritmo iterativo, abbiamo bisogno di una condizione di uscita che alla fine ci incontreremo e per l'algoritmo ricorsivo, abbiamo bisogno di casi di base in modo tale da gestire ogni possibile istanza.Ad ogni modo, consideriamo il caso in cui Y o B sono zero.Il risultato
il codice è
Algoritmo GCD (A, B)
⟨Pre-Cond⟩: a e b sono numeri interi.
⟨Post-Cond⟩: restituisce GCD (a, b).
inizio
if (b = 0) quindi
restituire (a)
altro
restituzione (GCD (B, una mod b))
finisci se
Algoritmo di fine
2).Avremo bisogno di capire questa relazione y = un mod b migliore.Qui Y è il resto quando dividi a per b.Se lasciamo r = ⌊a
B ⌋, quindi a = r · b + y o y = a −r · b.
Quando generalizziamo il problema, l'amico, oltre a G, ci dà anche Usub
e vSub tale che usub · x + vsub · y = g = gcd (x, y) = gcd (a, b).Collegamento di x = b
e y = a −r · b dà usub · b + vsub · (a −r · b) = g o vsub · a + (usub −vsub · r) · b =
G.Quindi, se impostiamo u = vsub e v = usub −vsub · r, allora otteniamo u · a + v · b = g = gcd
(a, b) come richiesto.Fornisco semplicemente queste risposte.Per il caso di base con b = 0, abbiamo
G = GCD (A, B) = A.Quindi, u = 1 e v = 0 dà che u · a + v · b = g = gcd (a, b).IL
Il codice risultante è
Algoritmo GCD (A, B)
⟨Pre-Cond⟩: a e b sono numeri interi.
⟨Post-Cond⟩: restituisce interi g, u e v tale che u · a + v · b = g = gcd (a, b).

---
layout: 
title: Pagina 435
level: 3
---


Soluzioni di esercizio
419
inizio
if (b = 0) quindi
return (⟨a, 1, 0⟩)
altro
x = b
r = ⌊a
B ⌋
y = a −r · b
⟨G, usub, vsub⟩ = gcd (x, y)
u = vsub
v = usub −vsub · r
return (⟨g, u, v⟩)
finisci se
Algoritmo di fine
3).Il nostro obiettivo è quello di trovare due numeri interi U e V in modo tale che U · A + V · T = W.Quindi dai
Il magazzino U delle monete A e V delle monete B per un valore totale di dollari W.Se tu
o V è negativo, questo equivale al magazzino che ti dà monete come cambiamento.
Per trovare U e V, iniziamo chiamando l'algoritmo GC D su A e B.Questo ritorna
numeri interi g, u e v tale che u · a + v · b = g = gcd (a, b).
Se G si divide uniformemente in W, allora moltiplicando per W
g dà (uw
g) · A + (VW
g) · b =
G (W.
g) = W e abbiamo finito.
Con la definizione di g = gc d (a, b), sappiamo che G divide a e b, e quindi si divide
U · a + v · b uniformemente.Ne consegue che se G non si divide uniformemente, allora non c'è numero intero
Soluzione a u · a + v · b = w.
4).Soluzione non fornita.
Capitolo 10. Ricorsione sugli alberi
10.3.1
Algoritmo più piccolo (albero, k)
⟨Pre-Cond⟩: L'albero è un albero di ricerca binaria e K> 0 è un numero intero.
⟨Post-Cond⟩: emette l'elemento più piccolo KTH e il numero N di elementi.
Se questo indice è fuori portata, emettiamo s = notpossible.
inizio
if (albero = vuoto) quindi
risultato (⟨notPossible, 0⟩)
altro
⟨Sl, nl⟩ = più piccolo (sinistra (albero), k)
% Ci sono nodi NL + 1 prima della sottostruttura destra
⟨Sr, nr⟩ = più piccolo (dirittiB (albero), k - (nl + 1))
n = nl + 1 + nr
if (k ∈ [1..nl]) allora
s = sl
elseif (k = nl + 1) quindi
s = root (albero)
elseif (k ∈ [nl + 2..n]) quindi
s = sr

---
layout: 
title: Pagina 436
level: 3
---


Soluzioni di esercizio
420
altro allora
s = outfrange
finisci se
risultato (⟨s, n⟩)
finisci se
Algoritmo di fine
10.4.1 1. Dove nel mucchio può andare il valore 1?Deve essere in una delle foglie.Se 1 non era a un
Leaf, quindi i nodi sottostanti avrebbero bisogno di un numero più piccolo, di cui non ce ne sono.
2. Quali valori possono essere memorizzati nella voce A [2]?Può contenere qualsiasi valore nell'intervallo 7–14.
Non può contenere 15, perché 15 devono andare in un [1].Sappiamo già che un [2] deve essere
maggiore di ciascuno dei sette nodi nella sua sottostruttura.Quindi, non può contenere un valore in meno
di 7. Per ciascuno degli altri valori, un heap può essere costruito in modo tale che A [2] abbia quello
valore.
3. Dove nel mucchio può andare il valore 15?15 deve andare in un [1] (come abbiamo detto).
4. Dove nel mucchio può andare il valore 6?6 può andare ovunque tranne un [1], A [2] o un [3].
A [1] deve contenere 15 e A [2] e A [3] devono essere almeno 7.
10.5.1
algoritmo derivato (f, x)
⟨Pre-conf⟩: f è un'equazione e x è una variabile
⟨Post-Cond⟩: il derivato di F rispetto a X viene restituito.
inizio
if (f = "x") allora
risultato (1)
altrimenti se (f = un valore reale o una singola variabile diversa da "x")
risultato (0)
finisci se
% se f è della forma (GOPH)
g = copia (sinistra (f))
% Copia necessaria per "\*" e "/".
H = copia (dirittiB (f))
% Tre copie necessarie per "/".
g ′ = derivato (sinistra (f), x)
H ′ = Derivative (Rightsub (F), x)
if (f = g + h) quindi
% Vedi Figura 10.5.3.A
Risultato (G ′ + H ′)
altrimenti se (f = g −h) quindi
risultato (g ′ −h ′)
altrimenti se (f = g ∗ h) quindi
% Vedi Figura 10.5.3.b
Risultato (G ′ ∗ H + G ∗ H ′)
altrimenti se (f = g/h) quindi
% Vedi Figura 10.5.3.c
Risultato (G ′ ∗ H −g ∗ H ′)/(H ∗ H))
finisci se
Algoritmo di fine

---
layout: 
title: Pagina 437
level: 3
---


Soluzioni di esercizio
421
10.5.3
t = a '\*d = 0 \*d = 0
s = n - i = 0 - k = 1
semplifica (f ') = s/v = 1/(x \*x)
v = d \*d = x \*x
u = a \*d '= 1 \*1 = 1
D = x
D = x
A '= M/Q = 0/Q = 0
D = x
A = x/x = 1
D '= 1
m = n - p = x - x = 0
Q = x \*x
n = 1 \*x = x
p = x \*1 = x
Capitolo 11. Immagini ricorsive
11.1.1 Linea di caduta: questa costruzione è costituita da una singola riga con l'immagine N −1 sollevata, inclinata e ridotta:
11.1.2 Inclinazione binaria: questa immagine è la stessa della torta di compleanno.Le uniche differenze sono quelle
I due luoghi da ricorrere sono inclinati e uno di essi è stato messo a testa in giù:
Capitolo 12. Analisi con grammatiche senza contesto
12.0.1
S = (((1) \* 2 + 3) \* 5 \* 6 + 7)
| -exp ------------------------------- |
| -term -------------------------- |
| -Fact -------------------------- |
(| -exp --------------------------- |)
| -term ------------------ |+ t
| -Fact ---------- |\* f \* f
F
(| -exp ------- |)
5
6
7
| -t ----- |+ t
| -f- |\* F
F
(e)
2
3
T
F
1
S = (((1) \* 2 + 3) \* 5 \* 6 + 7)
Spiacenti, la soluzione per 2 e 3 non è inclusa.

---
layout: 
title: Pagina 438
level: 3
---


Soluzioni di esercizio
422
Capitolo 14. Algoritmi di ricerca del grafico
14.2.1 Il nodo V non può essere in vk ′ per k ′> k + 1, perché esiste un percorso di lunghezza k + 1 ad esso, vale a dire il percorso per u seguito dal bordo ⟨u, v,⟩.Se V non è stato trovato prima, allora noi
lo stanno solo trovando.Il suo d (v) viene impostato su d (u) + 1 = k + 1. per li1, questa deve essere la sua distanza
da s.Quindi, V deve essere in VK+1.Se V è stato trovato prima, è perché un percorso più breve
ci è già stato scoperto.Se il bordo ⟨u, v, è diretto, allora questo percorso precedente potrebbe
Avere una lunghezza k ′ ≤k + 1. Tuttavia, se questo bordo è non indirizzato, allora c'è una cattura.
Supponiamo che V sia in vk ′.Quindi un possibile percorso verso u è quello della lunghezza K ′ + 1 da S a V seguita
by the edge {u, v,} all'indietro a u.Perché il percorso più breve per U è di lunghezza k, abbiamo
K ′ + 1 ≥k o k ′ ∈ {k −1, k, k + 1}.
14.2.2 L'algoritmo più breve indicato in questa sezione è identico all'algoritmo di ricerca generico nella Sezione 14.1, tranne per il fatto che viene utilizzata una coda.Quindi, il tempo di esecuzione è (| e |).IL
Il tempo non è inferiore se stai cercando un percorso per un nodo specifico t.
14.3.2 Nonostante le differenze negli algoritmi, su un grafico con i pesi del bordo uno, prima
La ricerca e l'algoritmo di Dijkstra sono identici.La prima ricerca di larghezza gestisce il primo nodo
Nella sua coda, mentre l'algoritmo di Dijkstra gestisce il nodo con il prossimo d (V) più piccolo.
Tuttavia, l'invariante del terzo ciclo della prima ricerca in larghezza garantisce che i nodi vengano trovati
e aggiunto alla coda nell'ordine di distanza D (V).Quindi, gestire il successivo nel
La coda equivale alla gestione del prossimo d (V) più piccolo.La prima ricerca invariante della prima ricerca afferma che si ottiene la distanza minima corretta da D (V) a V quando il nodo V è
Prima trovata, mentre con l'algoritmo di Dijkstra non siamo sicuri di averlo fino a quando il nodo è
gestito.Tuttavia, con i pesi del bordo uno, quando V si trova prima nell'algoritmo di Dijkstra, D (V) è impostato sulla lunghezza del percorso più breve generale e non è mai più cambiato.
14.6.2 Il percorso più breve verso il nodo V non conterrà alcun nodi U che appaiono dopo nel totale
Ordine, perché per i requisiti dell'ordine totale non esiste un percorso da u a v. Quindi, è destinato a gestire V, impegnandosi in un percorso più breve verso V, prima di considerare u.Quindi, esso
è finito per gestire i nodi nell'ordine dato dall'ordine totale.Il vantaggio di questo
L'algoritmo è che non è necessario mantenere una coda prioritaria, come fatto in Dijkstra
algoritmo.Ciò riduce il tempo da (| e | log | v |) a (| e |).
Capitolo 15. Flussi di rete e programmazione lineare
15.2.5 Dato una rete ⟨g, s, t⟩, eseguire l'algoritmo massimo di flusso su di esso.Oltre a restituire un file
flusso massimo, restituisce anche un taglio minimo, che viene utilizzato per assistere al fatto che
Non c'è flusso migliore.
15.5.1 1. Il primo non ha una corrispondenza.Un testimone è il fatto che i nodi 1, 3 e 5 sono solo
collegato a B e D. Quindi, i tre non possono essere abbinati ai due.Nella lingua
del teorema di Hall, let a = {1, 3, 5};Quindi n (a) = {b, d}.Perché | A |> | N (a) |, Hall
Teorema dà che non c'è abbinamento.Il secondo ha una corrispondenza.Un testimone
è la seguente corrispondenza:
E
D
C
B
UN
2
3
4
5
1
2
3
4
1
E
D
C
B
UN
5

---
layout: 
title: Pagina 439
level: 3
---


Soluzioni di esercizio
423
2. Considera un arbitrario a ⊆l.Si noti che l'insieme b = {m (u) | u ∈A} contiene | a |distinto
nodi e quel b ⊆n (a).Quindi, | a |≤ | n (a) |.
3. Lascia che a = u ∩l sia l'insieme di nodi che si trovano entrambi sul lato sinistro del grafico bipartito
e sul lato sinistro del taglio.Considera qualsiasi nodo v ∈N (a).Perché v ∈N (a), lì
è un nodo u ∈a ⊂u tale che ⟨u, è un bordo.Se v ∈V, allora questo bordo (u, v) si incrocia
il taglio.Ma questo vantaggio ha capacità ∞.In questo caso, la capacità del taglio è ben finita
| L |.D'altra parte, se V ∈U, allora il bordo da V a T è attraverso il taglio.Ora
Considera qualsiasi nodo u ∈L −a ⊂v.Il bordo da S a U attraversa il taglio.Questo dimostra
che il numero di bordi attraverso il taglio è almeno n (a) + (| l | - | a |), che dal nostro
L'assunzione è almeno | a |+ (| L | - | a |) = | l |.
4. Abbiamo visto che c'è una corrispondenza con | l |bordi se il flusso massimo in questo grafico
ha valore | l |Se il taglio min in questo grafico ha capacità | l |.Il taglio con S su un lato
di per sé ha | l |bordi che attraversano il taglio, vale a dire quei bordi da s a L.
Ultima domanda, se ∀a ⊆l, | a |≤ | n (a) |, allora ogni taglio ha almeno | l |bordi attraverso di esso.
Quindi, il taglio min deve essere | l |.Quindi, il flusso massimo ha valore | l |.Quindi, c'è un
Abbinamento con | l |bordi.Tutti i nodi in L devono essere abbinati.
5. Dall'ultima domanda, è sufficiente dimostrare che ∀a ⊆l, | a |≤ | n (a) |è vero.Considera alcuni set a ⊆l.Perché ogni nodo in un ⊆L ha una laurea almeno k, noi
Sappi che almeno K · | A |I bordi lasciano A. Tutti i bordi che lasciano un must per entrare
Il suo quartiere ha set n (a).Quindi, il numero che lascia A è al massimo il numero che immette n (a).Perché ogni nodo in n (a) ⊆r ha una laurea al massimo K, noi
Sappi che al massimo K · | n (a) |Immettere n (a).Ne consegue che K · | A |≤# lascia a ≤# immettere
N (a) ≤k · | n (a) |.Quindi, | a |≤ | n (a) |, come è necessario.
Capitolo 16: Algoritmi avidi
16.2.2 Nella seguente istanza del problema della copertura dell'intervallo, il criterio avido che seleziona
L'intervallo che copre il maggior numero di punti scoperti si impegnerebbe in
Intervallo superiore.Tuttavia, la soluzione ottimale non contiene questo intervallo, ma contiene
I due intervalli inferiori.
16.3.2 Gli algoritmi 1, 2 e 4 non sono ottimali per la seguente istanza contro l'esempio:
Room2
Room1
(UN)
(B)
Il diagramma (a) fornisce gli eventi in istanza e il programma ottimale in due stanze.
Il diagramma (b) fornisce il programma non ottimale prodotto da questi tre algoritmi.Nota
Che il terzo algoritmo, che pianifica l'evento successivo nella stanza con l'ultimo tempo di risoluzione di ultimo, dà il programma ottimale.Ora dimostreremo sempre
fornisce una soluzione ottimale.
Come per tutti gli algoritmi avidi, l'invariante loop è che esiste almeno una soluzione ottimale optsli coerente con le scelte fatte finora, ovvero programmazione nel
Stesse stanze gli stessi eventi il ​​cui programma sono stati impegnati finora e non
Pianificare gli eventi respinti finora.Inizialmente, nessuna scelta è stata fatta e quindi
Tripiamente tutte le soluzioni ottimali sono coerenti con queste scelte.Dimostriamo che il ciclo

---
layout: 
title: Pagina 440
level: 3
---


Soluzioni di esercizio
424
Invariant viene mantenuto modificando il programma optsli in un altro programma
Optsours e dimostra che questo nuovo programma è valido, coerente con tutte le scelte precedenti e attuali e ottimale.Ci sono tre casi.
Se il nostro avido algoritmo non ha programmato il prossimo evento, questo evento deve essere confuso
in ogni stanza con un evento precedentemente programmato.Quindi, Optsli non può avere questo successivo
Anche l'evento che ho programmato, perché anche questo ha programmato questi eventi precedenti.Quindi, Optsli stesso è già coerente con la scelta più recente.
Se il nostro avido algoritmo ha programmato il prossimo evento I nella stanza J e Optsli non lo fa
Pianifica questo evento, quindi modifichiamo il programma optsli in optsours aggiungendo
Io nella stanza J e rimuovendo qualsiasi evento da J che confondono con esso.Proprio come fatto con il
Algoritmo di pianificazione di una stanza nella sezione 16.2.1, possiamo dimostrare che solo un evento è
Rimosso e quindi Optsours è valido, coerente e ottimale.
Il caso rimanente si verifica quando il nostro avido algoritmo ha programmato il prossimo evento I in
La stanza J e Optsli lo pianificano nella stanza J ′.(Vedi diagramma (a).) Modifichiamo il programma
optsli in optsours come segue.(Vedi diagramma (b).) Non possiamo spostare gli eventi di cui
Il programma è già stato impegnato dall'algoritmo, perché Optsours deve farlo
Resta coerente con queste scelte.(Vedi gli eventi nella cerchia di commit.) Dobbiamo farlo
Sposta l'evento I dalla stanza J ′ alla stanza J in modo che anche sia coerente con ciò che l'algoritmo
ha fatto.Ma apportare questo cambiamento può creare conflitti.Per risolverli, scambiamo ogni evento
programmato da Optsli nella stanza J ′ con il tempo di conclusione di eventi o successivamente con tutti di questi
lavoro programmato nella stanza j.(Vedi gli eventi nel rettangolo.)
Dimostriamo ora che la soluzione risultante Optsours è valida, coerente e ottimale.
Una soluzione valida: la nostra soluzione modificata Optsours non contiene conflitti, perché optsli
non conteneva nessuno e dimostreremo ora che non sono stati introdotti nuovi conflitti.Ci sono
Nessun nuovo conflitto tra gli eventi precedentemente impegnati (cerchio), perché lo hanno fatto
non cambiare.Non ci sono nuovi conflitti tra gli eventi successivi (rettangolo), perché hanno fluito le stanze tutte insieme.Evento che non conflitto con il precedente
Eventi impegnati nella stanza J, perché l'algoritmo lo ha programmato lì.Anche più tardi
Nemmeno gli eventi nella stanza J ′, perché sono anche più tardi.Gli eventi successivi che
erano nella stanza che non si confonderanno con gli eventi precedentemente programmati nella stanza J ′, perché
Non hanno conflitto con quelli nella stanza J e sappiamo con la scelta della stanza dell'algoritmo
j che il tempo di risoluzione dell'ultimo programma per J è più tardi di quello per la stanza J ′.
Coerentemente con le scelte fatte: Optsli era coerente con le scelte precedenti.Noi
spostato eventi dalla stanza J ′ alla stanza J per rendere Optsours coerente con questo più recente
scelta.Non abbiamo spostato alcun evento in commit.
Ottimale: programma Optsours ha il numero ottimale di eventi in esso, perché ha il
Stesso numero di eventi di Optsli.
Loop Invariant è stato mantenuto: in conclusione, abbiamo costruito un valido programma ottimale che è coerente con le scelte fatte dall'algoritmo.Questo
dimostra che l'invariante in loop è stato mantenuto.
Il resto della prova della correttezza di questo avido algoritmo è uguale a quello di tutti i
altri.

---
layout: 
title: Pagina 441
level: 3
---


Soluzioni di esercizio
425
Capitolo 17. Backtracking ricorsivo
17.5.1 Chiedere di fornire la parola migliore non è una "piccola domanda" per l'uccello.Lo farebbe
La maggior parte del lavoro per te.Chiedere all'amico di fornire il posto migliore sul tabellone da mettere
La parola non è una sottoinstabilità dello stesso problema di quella della data istanza.
17.5.2 Il semplice algoritmo di forza bruta cerca il dizionario per ogni permutazione di ciascuno
sottoinsieme delle lettere.L'algoritmo di backtracking prova tutte le possibilità per la prima
lettera e poi ricorre.Ognuno di questi cornici di stack prova tutte le possibilità rimanenti per la seconda lettera e così via.Questo può essere potato osservando che se la parola
Costruito finora, ad esempio, "XQ", non corrisponde alle prime lettere di alcuna parola nel dizionario, allora non è necessario che questo frame stack si riprenda ulteriormente.(Un altro miglioramento
Nel tempo di esecuzione assicura che le parole siano cercate nel dizionario in ordine alfabetico.)
17.5.3
1. ⟨1, 5, 8, 6, 3, 7, 2, 4⟩
2. ⟨1, 6, 8, 3, 7, 4, 2, 5⟩
3. ⟨1, 7, 4, 6, 8, 2, 5, 3⟩
4. ⟨1, 7, 5, 8, 2, 4, 6, 3⟩
5. ⟨2, 4, 6, 8, 3, 1, 7, 5⟩
6. ⟨2, 5, 7, 1, 3, 8, 6, 4⟩
7. ⟨2, 5, 7, 4, 1, 8, 6, 3⟩
8. ⟨2, 6, 1, 7, 4, 8, 3, 5⟩
9. ⟨2, 6, 8, 3, 1, 4, 7, 5⟩
10. ⟨2, 7, 3, 6, 8, 5, 1, 4⟩
11. ⟨2, 7, 5, 8, 1, 4, 6, 3⟩
12. ⟨2, 8, 6, 1, 3, 5, 7, 4⟩
17.5.4 Dimostreremo che il tempo di esecuzione è limitato tra
n
2
n
6 e nn e quindi lo è
n (n) = 2 (n logn).Senza alcuna potatura, ci sono n scelte su ciascuna delle file su dove
per posizionare la regina della fila.Questo dà a NN diversi posizionamenti delle regine.Ognuno di questi
Le soluzioni corrisponderebbero a una foglia dell'albero dei cornici dello stack.Questa è chiaramente una tomaia
legato al numero quando c'è potatura.
Ora darò un limite inferiore a quanti frame dello stack saranno eseguiti da questo
algoritmo.Sia J uno dei primi n
6 file.Lo sostengo ogni volta che un frame stack
sta mettendo una regina in questa fila, ha almeno n
2 scelte su dove posizionarlo.IL
Stack Frame può posizionare la regina su uno qualsiasi dei n quadrati nella riga finché questo
Il quadrato non può essere catturato da una delle regine poste sopra di essa.Se la riga sono al di sopra del nostro
Fila J, quindi la regina posizionata su fila posso catturare al massimo tre quadrati di fila J: uno
Spostandosi su una diagonale a sinistra, uno spostandosi dritto e uno spostandosi su una diagonale a destra.Perché J è uno dei primi n
6 righe, ci sono al massimo
Questo numero di righe i I sopra di esso, e quindi al massimo 3 × N
6 dei quadrati di fila J possono essere
catturato.Questo lascia, come sostenuto, n
2 quadrati su cui il telaio dello stack può posizionare il
regina.
Dall'affermazione di cui sopra, ne consegue che all'interno dell'albero delle cornici dello stack, ogni stack
frame all'interno del primo albero n
6 livelli si diramano almeno n
2 bambini.Quindi, al
n
6

th livello dell'albero ci sono almeno
n
2
n
6 frame di stack diversi.Alcuni di questi

---
layout: 
title: Pagina 442
level: 3
---


Soluzioni di esercizio
426
terminerà senza trovare un posizionamento valido completo.Tuttavia, questo è un inferiore
rilegato sul tempo di esecuzione dell'algoritmo, perché l'algoritmo si ripresenta a ciascuno
di loro.
17.5.5 La linea "kmin = a k che massimizza costk."
Capitolo 18. Algoritmi di programmazione dinamica
18.3.3
Algoritmo stampa in modo (⟨m; l1,., ln⟩)
⟨Pre-Cond⟩: ⟨l1 ,..., non c'è la lunghezza delle parole e m è la lunghezza di ogni linea.
⟨Post-Cond⟩: Opt Sol divide il testo in linee in modo ottimale e il costo è il suo costo.
inizio
% Tabella: Optsol [i] memorizzerebbe un modo ottimale per stampare le prime parole dell'input, ma in realtà archiviamo solo i consigli dell'uccello per la sottoinstabilità e il costo del suo
soluzione.
Tabella [0..N] BirdAdvice, costo
% Base di base: l'unico caso di base è per la migliore stampa delle prime parole zero.
La sua soluzione è la stampa vuota con costo zero.
% Optsol [0] = ∅
Costo [0] = 0
BirdAdvice [0] = ∅
% CASI GENERALI: ciclo sopra le sottoinstanze nella tabella.
per i = 1 a n
% Risolvi istanza ⟨m; l1 ,..., li⟩ e infilare nella voce della tabella ⟨i⟩.
K = numero massimo k in modo tale che le parole di lunghezza li - k+1 ,..., li ﬁ
su una singola riga.
% Prova ogni possibile risposte degli uccelli.
per k = 1 a k
% L'algoritmo di uccelli e amici
ultima linea.Chiediamo all'amico una stampa ottimale delle prime parole I −k.
Ci dà Optsol [i −k], che aveva memorizzato nel tavolo.A questo aggiungiamo
Le parole K dell'uccello su una nuova ultima riga.Questo ci dà Optsolk, il che è il migliore
Stampa delle prime parole tra quelle stampe coerenti con
la risposta dell'uccello.
% optsolk = ⟨optsub [i −k], k⟩
costk = cost [i −k] + (m −k + 1 - i
j = i - k+1 lj) 3
fine per
% Avere il meglio, Optsolk, per la risposta di ogni uccello K, manteniamo il meglio di questi
migliore.
kmin = a k che minimizza costk
BirdAdvice [i] = kmin

---
layout: 
title: Pagina 443
level: 3
---


Soluzioni di esercizio
427
% optsol [i] = optsolkmin
% costo [i] = costkmin
fine per
OptSol = PrintingNeatlyWithadvice

⟨M; l1 ,..., Ln⟩, BirdAdvice

restituire ⟨optsol, costo [n]⟩
Algoritmo di fine
Capitolo 19. Esempi di programmi dinamici
19.1.1 (a): se xn = ym, allora dobbiamo dimostrare che esiste almeno una soluzione ottimale che contiene entrambi questi ultimi personaggi.Prendi in considerazione una soluzione ottimale.Deve finire in questo
Ultimo personaggio;Altrimenti potrebbe essere esteso per contenerlo.Potrebbe non contenere entrambi
Di questi, come nel caso di x = ⟨a, b, b⟩, y = ⟨a, b⟩, con soluzione ottimale z = ⟨a, b⟩.
Tuttavia, come in questo caso, possiamo anche supporre che la soluzione ottimale prenda
Entrambi.Se xn ̸ = ym, allora la soluzione ottimale non può richiedere entrambi.Quindi, o lo fa
non prendere l'ultimo di x o non prende l'ultimo di Y. Potrebbe non volerci l'ultimo
Oppure, ma questo è incluso in entrambi gli altri due casi.Vedere la sezione 17.3 per un ulteriore
risposta.
(b) Il ciclo sopra le sottoinstanze viene quindi modificato come segue.
% Risolvi l'istanza ⟨⟨x1 ,..., xi⟩, ⟨y1 ,..., yj ⟩⟩ e infilare nella voce della tabella ⟨i, j⟩.
Se xi = yj allora
BirdAdvice [i, J] = 3
% optsol [i, j] = optsol [i −1, j −1] + xi
costo [i, j] = costo [i −1, j −1] + 1
altro
% Prova possibili risposte agli uccelli.
% casi k = 1, 2
% optsol1 = optsol [i −1, j]
cost1 = cost [i −1, j]
% optsil2 = optsol [i, j −1]
cost2 = cost [i, j −1]
% Casi finali
% Avendo il meglio, Optsolk, per la risposta di ogni uccello K, manteniamo il meglio di questi.
kmax = a k ∈ [1, 2] che massimizza costk
% optsol [i, j] = optsolkmax
costo [i, j] = costkmax
BirdAdvice [i, j] = kmax
finisci se
19.1.2 Il tempo di esecuzione è il numero di sottoinstanze volte il numero di possibili risposte agli uccelli e lo spazio è il numero di sottoinstanze.Il numero di sottoinstanze è
(N2) e l'uccello ha k = 3 possibili risposte per te.Quindi, i requisiti di tempo e spazio sono entrambi (N2).

---
layout: 
title: Pagina 444
level: 3
---


Soluzioni di esercizio
428
19.4.2
io
J
A1
A2
A3
A4
A5
A6
A7
A7
A1
A6
A5
A4
A2
A3
io
J
A7
A1
A6
A5
A4
A2
A3
io
J
Secondo
misurare
per j = 1 fino a n
per i = j giù a 1
Istanza di slove 〈ai ..., aj
per i = n fino a 1
per j = i fino a n
% Istanza di slove 〈ai ..., aj
〈
〈
19.5.1 1. Un albero AVL di altezza H ha un sobbolli sinistro e destro di altezze ⟨H −2, H −1⟩, ⟨H −1, H −1⟩ o ⟨H −1, H −2⟩.
2. L'uccello mi dice se le altezze della sottostruttura sono ⟨H −2, H −1⟩, ⟨H −1, H −1⟩ o ⟨H -
1, H −2⟩.Mi dice anche quale Valueak sarà alla radice.Posso quindi chiedere agli amici
per le migliori sottosterie sinistro e destro dell'altezza specificata.
3. In ciascuno di questi tre casi, le altezze sono entro 1.
4. Il set completo di sottoinstanze è il seguente.Ricordiamo che nel capitolo 10 abbiamo dimostrato
che l'altezza minima di un albero AVL con n nodi è h = log2 n e che è
L'altezza massima è h = 1.455 log2 n.Quindi, l'insieme completo di sottoinstanze è S =
{⟨H; ai ,..., A J;pi ,..., PJ⟩ |1 ≤i ≤j ≤n, h ∈ [log2 (j −i + 1) .. 1.455 log2 (j −i + 1)]}.
La tabella è una scatola tridimensionale (n × n × logn).
5. La tabella ha dimensioni (n × n × logn).L'uccello può dare 3 · n risposte diverse.Quindi, il tempo di esecuzione è (N3 Logn).
6. Nel problema originale, l'altezza non è stata fissata.Per risolvere questo problema, potremmo
Basta eseguire l'algoritmo precedente per ogni H e prendere il meglio dall'AVL risultante
alberi.Tuttavia, dopo aver eseguito una volta l'algoritmo precedente, la tabella contiene già
Il costo della migliore AVL per ciascuna delle altezze possibili h.Per trovare il miglior AVL complessivo
albero, dobbiamo solo confrontare quelli elencati nella tabella.
19.7.1
Algoritmo Analisi (⟨g, Tstart, A1,., An⟩)
⟨Pre-conf⟩: G è una grammatica normale di forma normale, Tstart è un non terminal e s è il
String ⟨A1 ,..., an⟩of ​​simboli terminali.
⟨Post-Cond⟩: P, se possibile, è un'analisi che genera S a partire da Tstart usando G.
inizio
% Tabella: Optsol [H, I, J] memorizzerebbe una soluzione ottimale per ⟨G, TH, AI ,..., a J⟩, vale a dire un'analisi per AI ,..., a J che inizia con non terminal th.Invece, archiviamo solo
Il consiglio dell'uccello per la sottoinstabilità e il costo della sua soluzione.
Tabella [| V |, N, N] BirdAdvice, costo

---
layout: 
title: Pagina 445
level: 3
---


Soluzioni di esercizio
429
% Il caso s = ϵ viene gestito separatamente
Se n = 0 allora
Se Tstart ⇒ϵ è una regola, allora
P = l'analisi applica questa regola.
altro
P = ∅
finisci se
restituzione (P)
finisci se
% Di base: i casi di base sono quando la stringa da analizzare è costituita da solo uno
personaggio AI.
Per i = 1 a n
Per ogni non terminal th
Se esiste una regola rq = "aq ⇒ bq", dove Aq è th e bq è AI, allora
BirdAdvice [H, i, i] = ⟨q ,?⟩
costo [h, i, i] = 1
altro
BirdAdvice [H, i, i] = ⟨?,?⟩
costo [h, i, i] = 0
finisci se
End Loop
End Loop
% CASI GENERALI: ciclo sopra le sottoinstanze nella tabella.
per dimensione = lunghezza da 2 a n % della sottostringa ⟨ai ,..., A J⟩
per i = 1 a n -zeze + 1
J = i + dimensione −1
Per ogni th non terminal, cioè h ∈ [1 .. | v |]
% Risolvi istanza ⟨g, th, ai ,..., a j⟩ e riempimento nella voce della tabella ⟨h, i, j⟩.
% Loop su possibili risposte degli uccelli.
Per ogni regola rq = "aq ⇒bqcq" per cui Aq è th
Per ogni divisione nella stringa da K = I a J −1
% Chiedi all'amico se puoi generare ⟨ai ,..., Ak⟩from Bq.
% Chiedi a un altro amico se riesci a generare ⟨ak+1 ,..., A J⟩.
da cq
cost⟨q, k⟩ = min (costo [bq, i, k], costo [cq, k + 1, j])
fine per
fine per
% Prendi la migliore risposta degli uccelli, vale a dire uno dei costi che si può generare.
⟨Qmin, kmax⟩ = a ⟨q, k⟩ che massimizza costi⟨q, k⟩
BirdAdvice [H, I, J] = ⟨qmin, Kmax⟩
COST [H, I, J] = COST⟨QMAX, KMAX⟩
fine per
fine per
fine per

---
layout: 
title: Pagina 446
level: 3
---


Soluzioni di esercizio
430
% Costruire la soluzione P
if (costo [1, 1, n] = 1)
% cioè, se s può essere generato da tstart
P = parsingwithadvice

⟨G, tstart, a1 ,..., an⟩, BirdAdvice

altro
P = ∅
finisci se
restituzione (P)
Algoritmo di fine
Requisiti del tempo e dello spazio: il tempo di esecuzione è il numero di tempi di sottoinstabilità
Il numero di possibili risposte agli uccelli e lo spazio è il numero di sottoinstanze.IL
Numero di sottoinstanze che indicizzano la tabella è (| v | n2), vale a dire la tabella [h, i, j] per h ∈V
e 1 ≤i ≤j ≤n.Il numero di risposte che l'uccello potrebbe darti è al massimo O (Mn), vale a dire, ⟨Q, K⟩ per ciascuna delle regole M RQ e la divisione k ∈ [1..n −1].Questo dà tempo =
O (| v | n2 · mn).Se la grammatica G è fissata, allora il tempo è (N3).
Un'analisi più stretta noterebbe che l'uccello risponderebbe solo a Q per le regole rq = “Aq ⇒
BQCQ ”, per il quale il lato sinistro AQ è il th non terminal specificato nell'istanza.
Sia Mth il numero di tali regole.Quindi il ciclo sui non terminali TH e il ciclo
Over Regole RQ non richiederebbe tempo | v | m, ma
Th∈V mth = m.Questo dà un tempo totale di
(N3M).
19.8.2 Dato un'istanza e = {e1, e2, ..., en} del problema degli elefanti, mappiamo questo su un'istanza
⟨X, y⟩ del problema LCS come segue.Ogni elefante sarà distinto.Sia x = ⟨x1 ,..., xn⟩
Sii gli elefanti ordinati per peso wi e lascia y = ⟨y1 ,..., ym⟩ è lo stesso ordinato da
Smartness Si.Una soluzione a LCS è una sottosequenza z = ⟨z1 ,..., zl⟩ che è comune ad entrambi
X e Y. Nota che Z è un sottoinsieme di elefanti per i quali è più intelligente.Questo
è perché Z è ordinato sia per il peso che per quanto riguarda l'intelligenza.IL
Solo la differenza tra questi problemi è che il costo (o il successo) di una soluzione LCS
è semplicemente la lunghezza di z, mentre per il problema degli elefanti è la somma dei valori di
gli elefanti.Quindi, affinché ciò funzioni, il problema LCS deve essere generalizzato per avere
pesi sulle lettere.Ma questo non cambierebbe l'algoritmo di programmazione dinamica
affatto.
Capitolo 20. Riduzioni e completezza NP
20.2.4 Il primo è facile.InstanceMap (I1) mappa semplicemente ogni istanza I1 ∈S1 ⊆S2 di P1 a se stessa, I1, che è un'istanza valida di P2.Il secondo è molto più difficile, perché InstanceMap (i2)
deve mappare ogni istanza i2 ∈S2 di p2 su una certa istanza I1 all'interno del limitato
Imposta S1.
20.2.5 Il tempo di esecuzione (algoracolo) viene misurato in funzione della propria dimensione di input, vale a dire
(2 | Ioracle |
1
3).Ma perché | Ioracle |= | Ialg | 2, lo stesso tempo è (2
| Ialg | 2/3
), in termini di
Dimensione dell'input di Algalg.Il tempo extra O (| ialg | 3) per le mappature non è sostanziale.Quindi, il tempo di esecuzione totale di Algalg è (2n2/3).

---
layout: 
title: Pagina 447
level: 3
---


Soluzioni di esercizio
431
Allo stesso modo, se l'algoracolo funziona in tempo polinomiale, vale a dire il tempo (algoracolo) = (| ioracle | c), allora anche Algalg, vale a dire il tempo (algalg) = (| ialg | 2c + | ialg | 3), ma notaloIl polinomale è diverso.
20.3.3
Passaggio 5: dato un grafico GCOL che vogliamo colorare, costruiamo un'istanza
⟨Gind, nind⟩ = InstanceMap (GCOL) da dare al set indipendente Oracle come segue.COME
ha detto, Gind avrà un nodo per ogni coppia ⟨u, c⟩where U è un nodo di GCOL e C è uno
dei tre colori.Per ogni nodo u ∈gcol, mettiamo un triangolo di bordi attorno a ⟨u, Red⟩, ⟨u, Blue⟩ e ⟨u, Green⟩.Per ogni bordo ⟨u, v⟩∈Gcol, abbiamo messo tre bordi paralleli tra ⟨u, c⟩ e ⟨v, c⟩, per ogni colore c.La dimensione del set indipendente richiesto sarà
Il numero di nodi, nind = | vcol |, nel grafico GCOL.
Passaggio 6: data una soluzione set indipendente Sind a Gind di dimensioni | vcol |, costruiamo a
colorare scol per gCOL colorandosi u con colore c se nodo ⟨u, c⟩is nell'indipendente
impostato.
Passaggio 7: ora mostriamo che se Sind è un set indipendente valido di dimensioni | vcol |, allora SCOL è un
3-coloranti validi.Per prima cosa mostriamo che è impossibile che un nodo venga dato più di uno
colore, perché il bordo tra ⟨u, c⟩u ⟨u, c′⟩prevents entrambi di questi nodi è
Nel set indipendente.Perché il set indipendente è di dimensioni | vcol |e nessun nodo u
Appare più di una volta, ne consegue che ogni nodo U appare esattamente una volta.Quindi, ogni
Node U viene dato un colore.Infine, mostriamo che i nodi nel bordo ⟨u, v⟩∈Gcol non possono
Entrambi hanno il colore C, perché il bordo tra ⟨u, c⟩ e ⟨v, c⟩prevents entrambi di questi
nodi dall'essere sul set indipendente.
Passaggio 8: dato una scol da colorare per GCOL, costruiamo un set indipendente per Gind
di dimensioni | vcol |Mettendo il nodo ⟨u, c⟩in il set indipendente se u è colorato c.
Passaggio 9: ora mostriamo che se SCOL è un 3-color valido, allora Sind è un valido indipendente
impostato.Dobbiamo dimostrare che per ogni bordo di Gind, entrambi i nodi non sono in Sind.C'è un
bordo tra ⟨u, c⟩u ⟨u, c′⟩, ma non puoi avere entrambi i colori C e C ′.C'è un bordo
tra ⟨u, c⟩ e ⟨v, c⟩, ma u e v non possono entrambi avere il colore c.
Capitolo 22. Quantiumi esistenziali e universali
22.0.2 1. ∀x ∃y x + y = 5 è vero.Lascia che X abbia un valore reale arbitrario e lascia che y = 5 −x.Poi
x + y = 5.
2. ∃y ∀x x + y = 5 è falso.Lascia che y abbia un valore reale arbitrario e lascia x = 6 −y.Poi
x + y ̸ = 5.
3. ∀x ∃y x · y = 5 è falso.Lascia che x = 0. allora Y deve essere 5
0, che è impossibile.
4. ∃y ∀x x · y = 5 è falso.Lascia che abbia un valore reale arbitrario e lascia x = 6
y se y ̸ = 0 e
x = 0 se y = 0. allora x · y ̸ = 5.
5. ∀x ∃y x · y = 0 è vero.Lascia che X abbia un valore reale arbitrario e lascia y = 0. Quindi
x · y = 0.
6. ∃y ∀x x · y = 0 è vero.Sia y = 0, e lascia che X abbia un valore reale arbitrario.Poi
x · y = 0.
7. [∀x ∃y p (x, y)] ⇒ [∃y ∀x p (x, y)] è falso.Sia p (x, y) = [x + y = 5].Quindi, come già
Visto, il primo è vero e il secondo è falso.

---
layout: 
title: Pagina 448
level: 3
---


Soluzioni di esercizio
432
8. [∀x ∃y p (x, y)] ⇐ [∃y ∀x p (x, y)] è vero.Supponiamo che il lato destro sia vero.Lascia che y0 sia la y
per il quale [∀x p (x, y)] è vero.Dimostriamo il lato sinistro come segue.Lascia che X abbia un arbitrario
Valore reale e lascia che y = y0.Quindi p (x, y0) è vero.
9. Scusa, non fornito.
Capitolo 23. Complessità del tempo
23.1.1 Il numero di operazioni è T = 24 × 60 × 60 × 106 = 8.64 × 1010. Abbiamo N1 = T1/4 =
542, n2 = log2 t = log t
Log 2 = 36.
23.1.4 1. Dimostriamo prima che g + h = (max (g, h)) come segue.max (g, h) ≤g + h, supponendo che
Sia G che H sono positivi e G + H ≤2 max (G, H).
2. Si può impostare k su minimizzare assolutamente f (n, k) impostando il derivato di f wrt k uguale a
zero e risoluzione per k.A volte questo è difficile.Perché f (n, k) = (max (
N
Log K, K
log k))
E non ci interessa la costante moltiplicativa, impostiamo invece K in ordine
Per ridurre al minimo Max (
N
Log K, K
Log K).Osserva che se K è molto piccolo, allora il primo termine, essendo molto grande, domina.Quindi, possiamo ridurre l'intera espressione aumentando k.Allo stesso modo, se K è grande, il secondo termine domina l'espressione e noi
può diminuirlo diminuendo K.Quindi per la soluzione ottimale i due termini dovrebbero essere
all'incirca lo stesso.In questo caso
N
log k =
K
Il log k fornisce n = k e f (n, k) = n+k
log k =
N
Logn.Questo
è (asintoticamente) il miglior risultato, perché la riduzione di K aumenta il primo termine e
L'aumento di K aumenta il secondo.
3. Scusa, non incluso.
23.2.1 1. ∃a, ∀i, opere (smistamento, a, i).Sappiamo che lì almeno un algoritmo, ad esempio a =
Unisci l'ordinamento, che funziona per ogni istanza di input I.
2. ∀a, ∃i, ¬Works (fermentazione, a, i) sappiamo che è vera una dichiarazione contraria.Ogni algoritmo non funziona per almeno un'istanza di input I.
3. ∃p, ∀a, ∃i, ¬Works (p, a, i)
4. Dice che ogni input ha un po 'di algoritmo che capita per produrre la risposta giusta.
È vero.Considera un'istanza arbitraria I. Se su istanza I, si ferma a dire
Sì, quindi lascia che A sia l'algoritmo che si ferma semplicemente e dice di sì.Altrimenti, lascia che un sia il
Algoritmo che si ferma semplicemente e dice di no.Ad ogni modo, un lavoro per questa istanza I.
5. Dice che ogni algoritmo risolve correttamente qualche problema.Questo non è vero, perché
Alcuni algoritmi non si fermano su alcune istanze di input.Dimostriamo il complemento
∃a, ∀p, ∃i, ¬Works (p, a, i) come segue.Lascia che A sia un algoritmo che funziona per sempre
qualche istanza i ′.Sia P un problema arbitrario.Lascia che io sia un'istanza I ′ su cui a
non si ferma.Nota che funziona (p, a, i) non è vero.
Capitolo 24. Logaritmi ed esponenziali
24.0.1 A3 × A5 = A8, 3A × 5a = 15a, 3a + 5a =?, 25log4n + 7 = [40.5] 6Log4n × 27 = [4log4n] 3 · 128 =
128n3, N3/log2n = [2log2 N] 3/log2n = 23 = 8.
Capitolo 25. Crescita asintotica
25.1.4 Esercizio 25.0.2 dimostra che 3 logn << n per sufficientemente grande n.Quindi, n2 ≤3n2 logn ≤
N · N2 = N3.
25.1.5 34n >> 43n >> 20.001n
N100
>> 100n100 >> log1.000 n.

---
layout: 
title: Pagina 449
level: 3
---


Soluzioni di esercizio
433
25.2.2
1. 14n9 + 5, 000n7 + 23n2 logn ∈O (n9): lascia c = 15 e n0 = 100. Per tutti n ≥100, noi
Avere
f (n) = 14n9 + 5.000n7 + 23n2 ≤14n9 + n2
2 N7 + N6
2 n2 logn ≤14n9 + n9 =
C · G (N).
2. 2n2 −100n ∈ (N2): Sia C1 = 1, C2 = 2 e N0 = 100. Per tutti N ≥100, C1G (N) = 1N2 =
2n2 −n · n ≤2n2 −100n = f (n) ≤2n2 = c2g (n).
3. 14N8 −100n6 ̸∈O (N7): Sia C e N0 valori arbitrari dati da qualche avversario.
Abbiamo quindi lasciato n = max (10, c, n0).Quindi dimostriamo che F (N) è troppo grande.Perché
n ≥10, abbiamo 100n6 ≤n8.Questo dà f (n) = 14n8 −100n6 ≥14n8 −1N8> n · n7 ≥
C · N7.
4. 14n8 + 100n6 ̸∈ (N9): Sia C1, C2 e N0 valori arbitrari dati da alcuni
avversario.Facciamo n = max (15/c1, 11, n0).Quindi dimostriamo che F (n) è
Troppo piccolo: C1G (N) = C1N9 = N · C1N8 ≥15
C1 · C1N8 = 14N8 + N8 = 14N8 + N2 · N6 ≥14n8 +
(11) 2 · n6> 14n8 + 100n6 = f (n).
5. 2n+1 ∈O (2n): Sia C = 2 e N0 = 0. Per tutti N ≥0, F (N) = 2n+1 ≤2 × 2n = C × G (N).
6. 22n ̸∈O (2n): Sia c e n0 valori arbitrari.Sia n = max (1 + log2 c, n0).Allora noi
avere quel f (n) = 22n = 2n · 2n> c · g (n).
25.2.8
1. x = 7y3 (log2 y) 18 ∈Y3+o (1) =

y3, y3+ϵ
.Risolvere questo dà y = x1/(3+O (1)).
2. Sostituzione
In
y = x1/3+o (1)
dà
x = 7y3 (log2 y) 18 = 7y3 (log2 x1/(3+o (1))) 18 =
(Y3 (log2 x) 18).Risolvere questo dà y =

X
1
3 /(log x) 6
.
Capitolo 26. Aggiunta di approssimazioni fatte
26.2.1 Il suo primo passo del genere lo richiede mezz'ora, il suo secondo un quarto, il suo terzo ottavo ,...per
Un totale di solo ∞
i = 1
1
2i = 1
2 + 1
4 + 1
8 + 1
16 + · · · = 1 ora.Dato che viaggia un chilometro a un chilometro all'ora, questo è ragionevole.
26.2.4
1. La funzione f (n) = 22⌈log2 n⌉is 2 (n), perché è delimitata tra 2n e 22n.Permettere
n = 2k.Quindi ⌈log2 n⌉ = k e f (n) = 22k = 2n, ma per n ′ = n + 1 abbiamo ⌈logn′⌉ =
K + 1 e F (n ′) = 22K + 1 = 22N.
2. Mostriamo n
i = 1 f (i) ̸ = (f (n)) come segue.Con n = 2k, entrambe le funzioni sono più o meno
costante da f (n
2) a f (n).Perché si comportano come funzioni aritmetiche in questo
Range, le tecniche di aggiunta di fabbriche danno che n
i = 1 f (i) = (n · f (n)) e no
(f (n)).
3. Mostriamo che f (n) = 22⌊log logn⌋∈N (1) −1 delimitandolo tra √n e n.Sia n = 22k.
Quindi ⌊log logn⌋ = k e f (n) = 22k = n, ma per n ′ = n −1 abbiamo ⌊log logn′⌋ = k -
1 e f (n ′) = 22k - 1 = √n.
4. Mostriamo che n
i = 1 f (i) ̸∈ (n · f (n)) come segue.Di nuovo lasciano n = 22k, in modo che f (n) = n
Ogni termine precedente è più √n.Il totale di n
i = 1 f (i) quindi è al massimo (n - 1) · √n + n.
Perché l'ultimo termine F (n) è molto più grande di quelli precedenti, il totale non lo è
(n · f (n)), che è (n2).

---
layout: 
title: Pagina 450
level: 3
---


Soluzioni di esercizio
434
5. La funzione f (n) = 2 [1
2 cos (π log2 n) +1,5] · n è un controesempio geometrico spremuto tra 2n e 22n, proprio come f (n) = 22⌈log2 n⌉is:
6
5
4
3
1
0
0
2
4
6
8
10
2
Capitolo 27. Relazioni di ricorrenza
27.1.1 Esempi:
T (n)
loga
Logb
C
D vs −1
Dom.
Regola
Soluzione
2t (n
2) + n
log2 2
log2 2 = 1
1
0>
Tutto
(f (n) logn)
(n logn)
2t (n
2) + 1
log2 2
log2 2 = 1
0
Base
(nloga/ logb)
(N)
4t (n
2) + (n3/ log3 n)
log2 4
log2 2 = 2
3
Superiore
(f (n))
(N3/ LOG3 N)
32t (n
4) + (logn)
Log2 32
log2 4 = 5
2
0
Base
(nloga/ logb)
(N2.5)
27T (n
3) + (n3 log4 n)
log3 27
log3 3 = 3
1
3
4>
Tutto
(f (n) log (n))
(N3 log5 N)
8t (n
4) + ((n/ logn) 1.5)
log2 8
Log 4 = 3
2
3
2
−1,5 <
Base
(nloga/ logb)
(N1.5)
4t (n
2) + (N2/ LOGN)
log2 4
log2 2 = 2
2
−1 =
Esercizio 27.2.4 dà
(nc · log logn) = (n2 log logn)
27.2.1
Il collegamento di Fib (N) = αn in Fib (N) = Fib (N −1) + Fib (N −2) dà che αn ​​= αn - 1 + αn - 2.
Dividi attraverso αn - 2 dà α2 = α + 1. Risoluzione di questo dà che α = 1+
√
5
2
o α =
1−
√
5
2
.Qualsiasi combinazione lineare di queste due soluzioni sarà anche una soluzione valida, vale a dire
FIB (N) = C1 · (α1) N + C2 · (α2) N.Usando il fatto che FIB (0) = 0 e FIB (1) = 1 e risoluzione
per C1 e C2 lo dà
Fib (n) =
1
√
5

1 +
√
5
2
N
-

1 -
√
5
2
N
.

---
layout: 
title: Pagina 451
level: 3
---


Soluzioni di esercizio
435
27.2.2 Dispasso:
1. t (n) = t (n - 1) + n:
Perché
a = 1
E
c> 1, il
tavolo
Dare
T (n) = (n ·
f (n)) = (n2).
Svolgersi
dà
T (n) = n + t (n - 1) = n + (n - 1) + t (n - 2) =
n + (n - 1) + (n - 2) + t (n - 3) = n + (n - 1) + (n - 2) + · · · + (n -i + 1) + t (n−i) =
N + (n - 1) + (n - 2) + · · · + 1 = (N2).
2. t (n) = 2 · t (n −1) + 1: perché a = 2, la tabella dà t (n) = (a
N
b) = (2n).
La svolgimento dà t (n) = 1 + 2t (n - 1) = 1 + 2 + 4t (n - 2) = 1 + 2 + 4 + · · · + 2i - 1 +
2it (n -i) = 1 + 2 + 4 + · · · + 2n - 1 + 2n = (2n).
27.2.4 Supponiamo f (n) = nc · logd n e c = loga
logb;quindi t (n) = (h
i = 0 ai f (n/bi)) = (h
i = 0 AI
(N/BI)
c logd (n/bi)) = (nc · h
i = 0 (1) i [log (n/bi)] d).L'espressione N/BI assume i valori N, N/B, N/B2 ,..., 1. Inversione di questo ordine dà t (n) = (nc · h
j = 0

registro (b j)
d) =
(NC · H
j = 0

J logb
d).Qui

Logb
D è una costante che possiamo nascondere nel Theta.Questo
dà t (n) = (nc · h
j = 0 j d).Le approssimazioni di produzione aggiuntiva affermano che questo
La somma è aritmetica fintanto che d> −1.In questo caso, il totale è t (n) = (nc · h · hd) =
(nc · logd+1 n) = (f (n) logn).Se d = −1, allora otteniamo la somma armonica t (n) = (nc ·
h
j = 0
1
J) = (NC · log H) = (log log nc).Se d <−1, la somma ha una coda limitata, dando t (n) = (nc · (1)) = (nloga/ logb).

---
layout: 
title: Pagina 452
level: 3
---


---
layout: 
title: Pagina 453
level: 3
---


437
CONCLUSIONE
L'obiettivo generale di questo intero testo è stato quello di insegnare abilità nel pensiero astratto.Spero
Che è stato fruttuoso per te.Buona fortuna ad applicare queste abilità a nuovi problemi
Ciò deriva in altri corsi e sul posto di lavoro.
Salutiamo i nostri amici.

---
layout: 
title: Pagina 454
level: 3
---


---
layout: 
title: Pagina 455
level: 3
---


439
INDICE
Tipo di dati astratti (ADT), 1, 43
Soluzioni per l'esercizio, 414
funzioni vs., 43
Flezione con la coda, 56
Specifiche/implementazioni, 44
Dizionario, 47
Grafici, 47
Implementazione dell'elenco dei collegamenti, 51
Elenco, 44
Ordini, 48
coda prioritaria, 46
coda, 45
Set, 46
Imposta sistema, 47
Tipi semplici, 44
stack, 44;Analisi con Stack, 57
Alberi, 48
Avl Tree, 49
albero di ricerca binaria, 48
Definizione ricorsiva dell'albero, 130
Sistema set di sindacato, 49
Funzione di Ackermann, 127
Algoritmo, 127
Crashing, 128
Relazione di ricorrenza, 127
Tempo di esecuzione, 128
Risoluzione, 127
Approssimazioni di Aggiunta di Fa-Fade, 388
Esempi, 391
Soluzioni per l'esercizio, 433
Prove, 393
Funzioni analitiche, semplice, 396
somme aritmetiche, 394
Vicino all'armonica, 395
funzioni, senza forma di base, 396
somme geometriche, semplice, 393
somma armonica, 395
rapporto tra i termini, 393
Classi di soluzione, 389
Tecnica, 389
ADT.Vedi Tipo di dati astratti
Algoritmi.Vedi anche algoritmi ricorsivi
Funzione di Ackermann, 127
Il miglior algoritmo AVL Tree Bird-and-Friend, 312
corrispondenza bipartita con flusso di rete, 342
Algoritmo di forza bruta, 66, 226
definito, 1
L'algoritmo del percorso più basso di Dijkstra, 183
Algoritmi di programmazione dinamica e
Esempi, 267
Tutte le coppie, moltiplicazione matrice, 314
Best AVL Tree, 311
catene di molteplicazioni a matrice, 306
Analisi grammatica senza contesto, 315
Algoritmi di programmazione dinamica.attraverso
Riduzioni, 318
Problema più lungo in sequenza comuni, 295
contiguo più lungo in aumento
Esempio di successione, 301
Esempio di sottocanimazione più lungo, 301
Percorso di peso più corto, diretto livellato
Esempio grafico, 267
Problema di pianificazione del lavoro/evento ponderato, 303
Il più comune divisore comune di Euclid (GCD)
Algoritmo, 79
Algoritmi grafici
Expander Graphs, 351
Problema di taglio massimo, 350
albero di spanning minimo, 244
Network Flows, 198

---
layout: 
title: Pagina 456
level: 3
---


Indice
440
Algoritmi (cont.)
Percorso di peso più corto, diretto livellato
Esempio grafico, 267
3 colori, 330, 338
Algoritmi di ricerca del grafico, 173
Ricerca per la prima volta, percorso più breve, 179, 181
Prima ricerca di profondità, 188
Algoritmo di ricerca generica, 174
Ordine lineare dell'ordine parziale, 194;Algoritmo di ricerca di profondità, 195;facile ma lento
Algoritmo, 195
Ricucita della profondità della profondità, 192
Algoritmi avidi, 225, 260, 295, 307
Algoritmo per l'arco di collina, 221
Algoritmi iterativi, 8, 12, 21
Algoritmi di ordinamento iterativo, 71, 72, 75, 76
in attesa di avanti vs all'indietro, ricorsivo
Algoritmi, 99
Meta-algoritmi, xiii, 2
Specifiche dell'algoritmo di analisi, 161
Algoritmi randomizzati, 346
Algoritmi di smistamento e selezione, 114
Algoritmo per l'arrampicata per collina più ripida, 214
Strassen's Matrix Moltiplicazione, 126
complessità tempo/spazio, 82, 85, 324, 347, 366, 378, 406, 432
Funzioni analitiche, semplice, 396
somme aritmetiche, 394. vedi anche
Approssimazioni di aggiunta di fabbriche
Crescita asintotica, 377
tasso di crescita asintotico, 378
Notazione asintotica, 85, 377, 384
Definizione Bigoh, 85, 385
Little Oh Definition, 85, 386
Little Omega Definition, 85, 386
Loop invariant per limiti inferiori, 85
Definizione Theta, 85, 385
Soluzioni per l'esercizio, 432
Classificazione delle funzioni, 379
Classi di tassi di crescita, 377
scopo, 378
Avl Tree, 49
Best AVL Tree, 311
miglior problema di albero AVL, 313
Ricerca binaria 24
Per i costi nei problemi di ottimizzazione, 329
Restringendo l'esempio dello spazio di ricerca, 24
Esempio di indice di ritorno, 89
Tornando sì/no, 91
alberi, 48, 60
ADT, 48
equilibrato, 49
Miglior problema di ricerca binaria di ricerca, 311
Passaggi di base, 60
Dettagli di codifica/implementazione, 61
finale, 61
Stabilire loop invariant, 61
Condizione di uscita, 61
L'albero è un esempio di albero binario, 138
Loop invariant, 60
Passaggi principali, 61
Mantieni il loop invariante, 61
fare progressi, 61
Misura del progresso, 60
Nodi nell'esempio di albero di ricerca binaria, 131
Tempo di esecuzione, 61
Specificazioni, 60
errori tipici, 26
Definizione Bigoh, 385
bordi bipartiti, 191
corrispondenza bipartita con flusso di rete, 342
Ricerca per la prima volta, 178
Path più breve, 179, 181
Codice, 181
Loop in uscita, 183
Codice iniziale, 183
Codice ad anello, 180
Loop Invariant, 180
Mantenimento del ciclo invariante, 181
Problema di ottimizzazione, 179
Problema del percorso più breve, 179
Prova percorso più breve, 180
Ordine del secchio a mano, 71
Passaggi di base, 71
Condizione di uscita, 72
Loop Invariant, 72
Mantieni loop invariant, 72
Specificazioni, 71
catene di molteplicazioni a matrice, 306
Algoritmo di programmazione dinamica fallita, 307
Algoritmo avido fallito, 307
Piccola domanda per uccelli, 307
Costruzione ottimale della soluzione, 310
Costo della soluzione ottimale, costo per la sottoinstabilità, 308
Struttura ricorsiva, 308
ridotto alla sottoinstabilità, 308
Insieme di sottoinstanze chiamate, 308
Ordine di ﬁ ll della tabella, 308
Tabella indicizzata per costruzione di sottoinstanze, 308
Requisiti di tempo/spazio, 311
colorare l'aereo, 29
Passaggi di base, 29
Dettagli di codifica/implementazione, 30
finale, 30
Stabilire loop invariante, 30

---
layout: 
title: Pagina 457
level: 3
---


Indice
441
Condizione di uscita, 30
Loop Invariant, 29
Passi principali, 30
Mantieni il loop invariante, 30
Misura del progresso, 29
Tempo di esecuzione, 30
Casi speciali, 30
Specifiche, 29.
complessità computazionale, 1
Notazioni asintotiche, 85, 377, 384
prova formale di correttezza, 408
Decisione non deterministica del tempo polinomiale
Problemi (NP), 330
complessità tempo/spazio, 82, 85, 324, 347, 366, 378, 406, 432
Analisi grammatica senza contesto, 159
Analisi del tipo di dati astratte, 161
Prova di correttezza, 165
Esempio di programmazione dinamica, 315
Analisi del tipo di dati astratte, 316
Casi di base, 317
aiuto da amico, 316
Piccola domanda per uccelli, 316
non guardare avanti uno, 315
Numero di scaglioni, 316
Costruzione ottimale della soluzione, 317
Problema di analisi, 315
Insieme di sottoinstanze, 317
tabella ﬁ ll ordine, 317
Tabella indicizzata per sottoinstabilità
Costruzione, 317
Soluzioni per l'esercizio, 421
Analisi dell'espressione, 160
Codice getExp, 163
Espressioni getexp, 161
GetExp, ottieni termine, esempi di getfact, 162
Ottieni codice, 164
Codice getterm, 163
Grammatica, 159
Guarda avanti uno, 159, 165
Non terminali, 160
Specifiche dell'algoritmo di analisi, 161
Regole, 160
Tempo di esecuzione, 165
semantica e, 159
String Derivation, 160
sintassi e, 159
Terminali, 160
albero di cornici dello stack, 165
correttezza, 2
prova formale di correttezza, 408
Per contesto di analisi grammatica senza contesto, 165
Per la prima ricerca di profondità, 196
Per la programmazione dinamica, 283
Per algoritmi avidi, 230
per algoritmi ricorsivi, da forte
induzione, 113
Conteggio dell'ordinamento, 72
Passaggi di base, 73
Codice, 74
Stabilire loop invariante, 74
Condizione di uscita, 74
Loop Invariant, 74
Passaggio principale, 74
Mantieni invariante loop, 74
Tempo di esecuzione, 75
Specificazioni, 72
bordi ciclici, 191
Davis-Putnam, 263
Prima ricerca di profondità, 178, 188
Codice, 189
Classificazione dei bordi, 190
Istituire/mantenere loop invariant, 190
Cambiamenti di algoritmo di ricerca generico, 189
Loop Invariats, 189
ricorsivo, 192
Time Stamping, 191
Automazione infinita deterministica (DFA), 31
Esempio di aggiunta, 35
Applicazioni, 31
Esempio di calcolatore, 36
Compilare il programma iterativo in DFA, 33
Esempio di divisione, 36
Programmazione dinamica, 38
Esempio più lungo di osso, 37
La sottosequenza contigua più lunga in aumento, 38
La sottosequenza più lunga in aumento, 38
L'algoritmo per il percorso più corto di Dijkstra, 183
Codice, 186
Loop in uscita, 188
Codice iniziale, 187
Loop Body, 186
Loop Invariant, 185
Mantenimento di Li1, 186
Mantenimento di Li2, 187
Specifiche problematiche, 183
Approssimazione a distanza più breve, 184
Prova percorso più breve, 184
Programmazione dinamica, 267
ESERCIENT SOLUZIONI, 426, 427
Passaggi nello sviluppo, 267
Casi di base, 274
Codice, 275
Contare la sottoinstabilità, 273
soluzione finale, 275
ridondanza, 272
Tempo di esecuzione, 277
Insieme di sottoinstanze, 272

---
layout: 
title: Pagina 458
level: 3
---


Indice
442
Programmazione dinamica (cont.)
Soluzione dalle subsoluzioni, 274
tabella ﬁ ll ordine, 275
Tabella indicizzata per sottoinstabilità
Costruzione, 273
Backtracking ricorsivo, 267
Tempo di esecuzione, 271
punti sottili, 277
Algoritmi di programmazione dinamica e
esempi
Tutte le coppie, moltiplicazione matrice, 314
Best AVL Tree, 311
miglior problema di albero AVL, 313
Miglior albero di ricerca binaria, 311
catene di molteplicazioni a matrice, 306
Analisi grammatica senza contesto, 315
Algoritmi di programmazione dinamica tramite
Riduzioni, 318
Miglior percorso somiglianza, 319
Problema di elefante più grande-più intelligente, 322
Problema di pianificazione degli eventi, 319
Formazione dell'istanza del grafico, 319
Algoritmo di mappatura, 321
Problema più lungo in sequenza comuni, 295
Casi di base, 297
Codice, 297
Algoritmo avido, 295
Informazioni sulla Subinstance, 299
Little Bird Possibili risposte, 295
Piccola domanda per uccelli, 296
Sequenza comune più lunga, 295
Costruzione ottimale della soluzione, 299
Set di sottoinstanze, 296
Ordine di ﬁ ll della tabella, 297
Tabella indicizzata dalla costruzione di subindex, 297
Requisiti di tempo/spazio, 299
Sottosessenza contigua più lunga in aumento
Esempio, 301
Esempio di sottocanimazione più lungo, 301
Requisiti di tempo/spazio, 300
Percorso di peso più corto, grafico livellato diretto
Esempio, 267
Problema di pianificazione del lavoro/evento ponderato, 303
Algoritmi falliti, 303
programmazione dinamica avida, 304
Classificazione dei bordi, 190
bordi, 190
bordi bipartiti, 191
Cross Edges, 191
bordi ciclici, 191
bordi in avanti, 191
bordi degli alberi, 190
L'algoritmo GCD di Euclid.Vedi il più grande comune
Algoritmo divisore
Ciclo di eulero, 40
Pianificazione degli eventi 236, 319
Problema di pianificazione del lavoro/evento ponderato, 303
quantità esistenziali/universali, 357, 358, 372
Definizione delle variabili legate, 359
Combinando quantitazioni, 359
Soluzioni per l'esercizio, 431
Expressions Building, 360
Definizione delle variabili gratuite, 359
Ama Esempio, 358
Negazione, 361
Ordine dei quantitazioni, 359
Definizione della relazione, 358
rappresentazioni, 358
Dominio variabile, 360
Exponentials, 374
base, 376
Soluzioni per l'esercizio, 432
rapporto, 376
Regole, 375
usi, 374
trasformazione veloce di Fourier, 125
Esempio di algoritmo a due finali.
forward/cross borgs, 191
Livello di astrazione di amici, ricorsivo
Algoritmi, 100
Casi di base, 101
Ingresso generale, 100
Problema generalizzante, 101
Collegamento a tecniche, algoritmi iterativi, 102
minimizzare il numero di casi, 101
Tempo di esecuzione, 102
dimensione, 100
Specificazioni, 100
funzioni.Vedi anche la funzione di Ackermann
Tipi di dati astratti vs., 43
Funzioni analitiche, semplice, 396
Funzione lineare, 382
Funzione quadratica, 382
complessità tempo/spazio come, 367
Algoritmo GCD.Vedi il più grande divisore comune
(GCD) Algoritmo
somme geometriche, semplice, 393
Codice getExp, 163
Espressioni getexp, 161
GetExp, ottieni termine, esempi di getfact, 162
GetExp Reasoning, 163
Ottieni codice, 164
GetFact Reasoning, 164
Codice getterm, 163

---
layout: 
title: Pagina 459
level: 3
---


Indice
443
Considerazioni globali vs. locali, 200, 204, 222, 226, 228, 252, 278
Algoritmi grafici
Expander Graphs, 351
Problema di taglio massimo, 350
albero di spanning minimo, 244
Network Flows, 198
Percorso di peso più corto, grafico livellato diretto
Esempio, 267
3 colori, 330, 338
Algoritmi di ricerca del grafico, 173
Ricerca per la prima volta, percorso più breve, 179, 181
Prima ricerca di profondità, 188
L'algoritmo per il percorso più corto di Dijkstra, 183
Soluzioni per l'esercizio, 422
Algoritmo di ricerca generica, 174
Passaggi di base, 174
Codice, 175
condizione di uscita, 176
Uship Loop, 177
Gestione dei nodi, 178
Codice iniziale, 176
Codice del ciclo, 175
Loop Invariant, 174
Mantenimento invariante in loop, 176
Misura del progresso, 176
Problema di raggiungibilità, 174
Tempo di esecuzione, 177
Ordine lineare dell'ordine parziale, 194
Ricucita della profondità della profondità, 192
Problemi di teoria dei grafici, 173
Algoritmo di divisore comune (GCD) più grande, 79
Codice, 81
finale, 79, 81
Stabilire loop invariant, 79
Esempio, 82
Soluzioni per l'esercizio, 415
Condizione di uscita, 81
Iterazione su istanza generale, 79
Loop Invariant, 79
Legato inferiore, 82
Fare progressi, 80, 80
ricorsivo, 126
Tempo di esecuzione, 82
Casi speciali, 80
Specificazioni, 79
risoluzione, 81
Algoritmi avidi, 225
Algoritmo di forza bruta, 226
Prova di correttezza, 230
Utilizzando invarianti loop, 227
esempi
Game Show, 226
Problema di copertura a intervalli, 240
Problema di pianificazione del lavoro/eventi, 236
Problema minimo di spanning Tree, 244
Soluzioni per l'esercizio, 423
ﬁ xity vs. priorità adattiva, 234
Scelta avida, 226
Invarianti ad anello, tipi, 227
Specificazioni, 225
somma armonica, 395
Vicino all'armonica, 395
heap ordin/priorità code, 141
Implementazione dell'array, albero binario equilibrato, 141
errori comuni, 147
albero binario completamente equilibrato, 141
Definizione dell'heap, 141
accumulare problema, 142
Codice, 143
Algoritmo iterativo, 143
Algoritmo ricorsivo, 142
Tempo di esecuzione, 143, 144
Specificazioni, 142
Problema di heapsort, 145
Algoritmo, 145
Implementazione dell'array, 146
Codice, 147
Specifica, 145
Problema di makeheap, 144
Algoritmo iterativo, 144
Algoritmi ricorsivi, 144
Tempo di esecuzione, 145
Specificazioni, 144
Code prioritarie, 147
Algoritmo per l'arco di collina, 221. Vedi anche
Metodo di arrampicata su collina primordiale;
Algoritmo per l'arrampicata per collina più ripida
Piccolo massimo locale, 200
Algoritmo, difettoso, 203
algoritmo fisso, 205
Grafico di aumento, difettoso, 202
Idee di base, 201
controesempio, 204
massimo locale, 204
disegno immagine vedi disegno immagine ricorsivo
Informazioni Nascondo, 43
Informazioni teoriche bassi inferiori, 87, 92
Algoritmi iterativi, 8, 12
Passaggi di base, 13
Struttura del codice, 8
Dettagli di codifica/implementazione, 19
Prova di correttezza, 8
finale, 19
Stabilire loop invariant, 17
Condizione di uscita, 18

---
layout: 
title: Pagina 460
level: 3
---


Indice
444
Algoritmi iterativi (cont.)
Esempio di ﬁ nd-max due ﬁ nGeralgorithm, 10
Prova formale, 20
Invarianti ad anello per, 8, 13, 15
Passi principali, 16
Mantieni il loop invariante, 16
fare progressi, 16
Misura del progresso, 13
Tempo di esecuzione, 8, 19
Casi speciali, 19
Specifica, 12
Tipi di algoritmi iterativi, 21
Analisi del caso, 22
più di input, 21;Esempio di ordinamento di inserzione, 23
più di output, 21;Esempio di ordinamento di selezione, 22
Cerca lo spazio restringimento, 22
Esempio di restringimento della ricerca binaria, 24
lavoro svolto, 22
Esempio di ordinamento della bolla, 25
Algoritmi di smistamento iterativo
Ordine del secchio a mano, 71
Conteggio dell'ordinamento, 72
RADIX CONTENTI SORT, 76
radix ordin, 75
Pianificazione di lavoro/eventi Vedi pianificazione degli eventi
Esempio di elemento più piccolo KTH, 117
Modello di Las Vegas, 347
Funzione lineare, 382
Programmazione lineare, 219 Vedi anche il flusso di rete
Interpretazione dello spazio euclideo, 220
Esempio, 219
Specifica formale, 219
Algoritmo per l'arco di collina, 221
Rappresentazione matrice, 220
flussi di rete, 220
Tempo di esecuzione, 223
Piccolo massimo locale, 222
Implementazione dell'elenco dei collegamenti, 51
Aggiunta di nodo alla fine, 53
Aggiunta di nodo alla parte anteriore, 51
Eliminazione del nodo, 55
Invarianti nascosti, 51
Inizializza Walk, 54
Notazione, 51
Rimozione del nodo dalla fine, 53
Rimozione del nodo dalla parte anteriore, 52
Testare se vuoto, 53
Camminando lungo la lista collegata, 53
Little Oh Definition, 85, 386
Little Omega Definition, 85, 386
Logaritmi, 374
base, 376
Soluzioni per l'esercizio, 432
rapporto, 376
Regole, 375
usi, 374
Esempio più lungo di osso, 37
Problema più lungo in sequenza comune, 169, 295
Casi di base, 297
Codice, 297
Algoritmo avido, 295
Little Bird Possibili risposte, 295
Piccola domanda per uccelli, 296
Sequenza comune più lunga, 295
Costruzione ottimale della soluzione, 299
Set di sottoinstanze, 296
Ordine di ﬁ ll della tabella, 297
Tabella indicizzata dalla costruzione di subindex, 297
Requisiti di tempo/spazio, 299
Sottosessenza contigua più lunga in aumento
Esempio, 301
Esempio di sottocanimazione più lungo, 301
in attesa di avanti rispetto all'indietro, ricorsivo
Algoritmi, 99
Algoritmo, 99
Loop invariant per limiti inferiori, 85
Notazione asintotica, 85
Esempio di indice di ritorno della ricerca binaria, 89
Ricerca binaria che ritorna Sì/No, 91
Algoritmi dinamici, 90
Soluzioni per l'esercizio, 415
fliping un po ', 90
Argomento invariante in loop, 86
Prove di limiti inferiori, stato d'arte, 92
Esempio multiplexer, 90
Esempio di parità, 89, 90
Esempio di ordinamento, 87
complessità temporale, 85
Coprodo superiore, algoritmo, 85
Invarianti a loop per algoritmi iterativi, 8, 13, 15
limiti inferiori, 82, 85, 92, 264, 325, 415, 425 Vedi
anche loop invariante per limiti inferiori
per GCD, 82
Loop invariant per limiti inferiori, 85
Prove di limiti inferiori, stato d'arte, 92
Riduzioni, 324
Magic Sevens, 62
Passaggi di base, 63
Stabilire loop invariante, 64
Condizione di uscita, 64
Loop Invariant, 63
Mantieni invariante loop, 63

---
layout: 
title: Pagina 461
level: 3
---


Indice
445
Tempo di esecuzione, 64
Specificazioni, 62
moltiplicazione matrice
Tutte le coppie, 314
catene di, soluzione come albero, 306
Esempio di moltiplicazione della matrice di Strassen, 126
Misure di progresso, invarianti ad anello
Unisci Esempio di ordinamento, 114
Flezione con la coda, 56
Meta-algoritmi, xiii, 2
Min Cut Specification, 199
Monte Carlo Model, 348
più di input
invariante il ciclo iterativo più di Input
Algoritmi, 21, 29, 67, 102, 227, 300, 412
Colorare l'esempio del piano, 29
Automazione definita deterministica, 31
Soluzioni per l'esercizio, 412
Nella programmazione dinamica
contiguo più lungo in aumento
Esempio di successione, 301
Esempio di sottocanimazione più lungo, 301
In algoritmi avidi, 228
più di the-input vs. più output, 39
Esempio di tornei, 39
Algoritmi ricorsivi, collegamento a, 102
Nell'esempio di test del chip VLSI, 67
Algoritmi invarianti più output, 21
Esempio di ordinamento di selezione, 22
Esempio di ciclo Eulero, 40
Esempio multiplexer, 90, 90
Restringendo lo spazio di ricerca, 22, 24, 60, 86, 102, 228, 414
Esempio di ricerca binaria, 24
alberi di ricerca binari, 60
Soluzioni per l'esercizio, 414
Magic Sevens, 62
Test del chip VLSI, 65
flussi di rete/programmazione lineare, 198
corrispondenza bipartita con flusso di rete, 342
Soluzioni per l'esercizio, 422
Algoritmo per l'arrampicata in collina, piccolo locale
massimo, 200
Programmazione lineare, 219
Min Cut Specification, 199
Metodo di arrampicata in collina primordiale, 206
Specification, 198
Algoritmo per l'arrampicata per collina più ripida, 214
Decisione non deterministica del tempo polinomiale
Problemi (NP) completezza, 324
Matching bipartite, algoritmo di flusso di rete, 342, 343
Classificazione dei problemi, 326
Soluzioni per l'esercizio, 430
limiti inferiori, 325
Passaggi a prova di completezza NP, 330, 331
tempo polinomiale non deterministico
Problemi di decisione (NP), 330
Riduzione P1Poly P2, 324
Riduzioni inverse, 325
SATIS Abilità vs. ottimizzazione
Alg per il problema di ottimizzazione, 329
CIR-SAT, 326
Problemi di ottimizzazione, 328
3 Esempio di colorazione, 324
limiti superiori, 324
Perché ridurre, 324
Operazioni sui numeri interi, 122
BN Esempio, 122
Esempio di moltiplicazione della matrice di Strassen, 126
XYZ Esempio, 123
Problemi di ottimizzazione, 171
Esempi, 172
Airplane, 172
Pianificazione del corso, 172
Sequenza comune più lunga, 172
Network Flow, 198
Specificazione del problema, 171
Esempio di parità, 89, 90
Analisi con Stack, 57. Vedi anche senza contesto
Analisi
Codice, 58
finale, 58
Esempio, 57
Condizioni iniziali, 58
Loop Invariant, 58
Mantenimento invariante in loop, 58
Solo analisi, 59
Analisi con grammatica senza contesto, 59
Specificazioni, 57
Ordine lineare dell'ordine parziale, 194
Algoritmo di ricerca di profondità, 195
Algoritmo facile ma lento, 195
Definizione dell'ordine parziale, 194
Path di peso più corto, DAG, 196
Specificazioni del problema dell'ordinamento topologico, 195
Definizione totale dell'ordine, 194
Postconditions, 1
Precondizioni, 1
Metodo di arrampicata in collina primordiale, 206
Algoritmo, 206
finale, 209
Principio di dualità a taglio massimo, 213
Tempo di esecuzione, 213

---
layout: 
title: Pagina 462
level: 3
---


Indice
446
Test di primalità, randomizzato, 349
Stampa ordinatamente Esempio, 277
quanti.Vedi quantità esistenziali/universali
Funzione quadratica, 382
Ordine rapida
Esempio, 116
randomizzato, 348
RADIX CONTENTI SORT, 76
Algoritmo, 77
Esempio, 77
Tempo di esecuzione, 78
Specificazioni, 77
radix ordin, 75
Passaggi di base, 75
finale, 76
Stabilire loop invariante, 76
Loop Invariant, 76
Mantieni loop invariante, 76
Specifica, 75
Algoritmi randomizzati, 346
nascondere i casi peggiori dall'avversario, 346, 347
Modello deterministico del caso peggiore, 347
Problema dello spettacolo di gioco, 348
Modello di Las Vegas, 34
Monte Carlo Model, 348
Ordine rapida, 348
Conteggio randomizzato, 349
Test di primalità randomizzati, 349
Problemi di ottimizzazione con casuali
Struttura, 350
Expander Graphs, 351
Problema di taglio massimo, 350
Test del chip VLSI, 69
Generazione casuale Maze, 156
Condizioni iniziali, 157
Postcondition, 156
PRESIDIZIONE, 156
Tempo di esecuzione, 158
Cerca il labirinto, 158
Substanze, 157
relazioni di ricorrenza, 398
Soluzioni per l'esercizio, 433
Prove, 401
In algoritmi di backtracking ricorsivi, 259
tempistica dei programmi ricorsivi, 398
Risoluzione delle relazioni ricorsive, 399
ricorsione 97
Livello di astrazione degli amici, 100
sugli alberi
Soluzioni per l'esercizio, 419
generalizzare il problema risolto, 138
heap ordin/priorità code, 141
Definizione ricorsiva dell'albero, 130
rappresentando espressioni con alberi, 149
Esempi semplici, 135
Algoritmi ricorsivi vedi anche ricorsivi
backtracking
Elenco di controllo per, 104
Struttura del codice, 104
Specificazioni, 105
compiti da completare, 107
Variabili, 105
Prova di correttezza, con una forte induzione, 113
esempi
Funzione di Ackermann, 127
Soluzioni per l'esercizio, 417
Operazioni sui numeri interi, 122
BN Esempio, 122
Esempio di moltiplicazione della matrice di Strassen, 126
XYZ Esempio, 123
Soluzioni per l'esercizio, 416
Casi di base, 101
Ingresso generale, 100
generalizzare il problema, 101
Collegamento a tecniche, algoritmi iterativi, 102
minimizzare il numero di casi, 101
Tempo di esecuzione, 102
dimensione, 100
Specificazioni, 100
In attesa di avanti rispetto all'indietro, 99
Risoluzione, 127
Ordinamento/selezione di algoritmi, 114
Scegliere il perno, 118
trovando l'esempio più piccolo KTH, 117
Algoritmo di smistamento ricorsivo generale, 114
Unisci Esempio di ordinamento, 114
partizionamento secondo l'elemento pivot, 120
Esempio di ordinamento rapido, 116
Frame di stack, 110
forte induzione, 112, 112
Torre di Hanoi, 102
Algoritmi di backtracking ricorsivi, 251, 425
Come sequenza di decisioni, 251
miglior esempio di ricerca sugli animali, 253
Esempio di ricerca del labirinto, 252
Sviluppo di passaggi, 256
Soluzioni per l'esercizio, 425
rami di potatura, 260
Algoritmi avidi, 260
Esempio di problema delle regine, 256
SATIS ABILAZIONE, 261
Codice, 264
Davis-Putnam, 263
istanze/sotterranei, 262
potatura, 263

---
layout: 
title: Pagina 463
level: 3
---


Indice
447
Tempo di esecuzione, 264
Problema di capacità di Satis, 261
Soluzioni iterando, 262
Ricucita della profondità della profondità, 192
Raggiungere il postcondition, 193
Codice, 192
Esempio, 193
Tempo di esecuzione, 194
Immagini ricorsive, 153
Soluzioni per l'esercizio, 421
immagine ricorsiva/base di base fissa, 153
Caso base, 153
torta di compleanno, 154
Esempi, 154
Frattal, 155
disegno di immagine, 153
Uomo incorniciato in modo ricorsivo, 154
ricorso, 154
quadrato rotante, 154
Generazione casuale Maze, 156
Specificazione dell'immagine ricorsiva, 153
Riduzione, 324
Algoritmi di programmazione dinamica tramite, 318
Miglior percorso somiglianza, 319
Problema di elefante più grande-più intelligente, 322
Problema di pianificazione degli eventi, 319
Formazione dell'istanza del grafico, 319
Algoritmo di mappatura, 321
Legato inferiore, 325
Riduzione dei problemi di ottimizzazione, 326
Riduzione inversa, 325
Copro superiore, 324
Utilizzare nei problemi di classificazione, 326
Tempo di esecuzione, 2. Vedi anche complessità del tempo/spazio
Funzione di Ackermann, 128
miglior albero di ricerca binaria, 313
Ricerca binaria, 24
alberi di ricerca binari, 61
colorare l'aereo, 30
Analisi grammatica senza contesto, 165
Conteggio di ordinamento, 75
Programmazione dinamica, 277
Algoritmo GCD, 82
Algoritmo di ricerca generica, 177
heapsort, 147
accumulare, 143
Copertura a intervalli, 243
Algoritmi iterativi, 8, 19
Pianificazione di lavoro/eventi, 240
Programmazione lineare, 223
MakeHeap, 145
Magic Sevens, 62
unisci Ordine, 115
albero di spanning minimo, 247
nodi nell'albero binario, 132
Problema delle regine, 260
Ordine rapida, 116
Metodo di arrampicata in collina primordiale, 213
RADIX CONTEGGING ORMINE, 78
Generando casualmente labirinto, 158
Algoritmi ricorsivi, 102
Backtracking ricorsivo, 271
SATIS Abilità, 264
Algoritmo per l'arrampicata per collina più ripida, 216
Torri di Hanoi, 104
Sistema set di sindacati, 50
Test del chip VLSI, 69
Percorso di peso più corto, grafico livellato diretto
Esempio, 267
Algoritmi di smistamento e selezione, 114
Esempio di ordinamento della bolla, 25
trovando l'esempio più piccolo KTH, 117
Scegliere il perno, 118
Algoritmi di smistamento iterativo
Ordine del secchio a mano, 71
Conteggio dell'ordinamento, 72
RADIX CONTENTI SORT, 76
radix ordin, 75
unisci Ordine, 115
Ordine rapida, 116
Ordina rapida randomizzata, 348
Algoritmo di smistamento ricorsivo, generale, 114
Frame di stack, 110
Memoria, 111
Stack of Stack frame, 110
Tree of Stack Frame, 98, 110, 132, 165
Usando, 111
Algoritmo per l'arrampicata per collina più ripida, 214
Path di aumento, 215
Tempo di esecuzione, 216
Esempio di moltiplicazione della matrice di Strassen, 126
Complessità tempo/spazio, 82, 82, 85, 324, 347, 366, 378, 406, 432
Esempi, 369, 369
Soluzioni per l'esercizio, 432
Definizione formale, 371
Come funzioni, 367
Definizione dell'operazione, 368
scopo, 366
Definizione delle dimensioni, 367
complessità temporale del problema, 368
Esempio di tornei, 39
Torri di Hanoi, 102
Codice, 104

---
layout: 
title: Pagina 464
level: 3
---


Indice
448
Torri di Hanoi (cont.)
Dividi e conquista, 103
Tempo di esecuzione, 104
Specifica, 102, 103
Subinstance, 104
bordi degli alberi, 190
Alberi, 48. Vedi anche alberi di ricerca binaria;ricorsione
sugli alberi
Avl Tree, 49
miglior problema di albero AVL, 313
Miglior albero di ricerca binaria, 311
albero di ricerca binaria, 48
catene di moltiplicazioni a matrice, soluzione come
Esempio di albero, 306
è un albero un esempio di albero di ricerca binaria, 138
Nodi nell'esempio di albero binario, 131
rappresentando espressioni con
differenziare l'esempio di espressione, 150
Valuta Esempio di espressione, 149
Definizione ricorsiva dell'espressione, 149
Semplifica Esempio di espressione, 151
Struttura dei dati dell'albero, 149
Definizione ricorsiva di, 130
di frame dello stack, 98, 110, 132, 165
Traversals, 133
Quantificanti universali.Vedi esistenziale/universale
quanti
CONSIGLIO DELL'UPERNO, 82
tagli come limite superiore, 209
per l'arco di collina, 222
Test del chip VLSI, 65
Algoritmo di forza bruta, 66
Struttura dei dati, 66
Loop in uscita, 69
estendendo l'algoritmo, 69
Algoritmo più veloce, 67
Codice iniziale, 69
Design invariante in loop, 67
Mantenimento invariante in loop, 68
Misura del progresso, 68
Algoritmo randomizzato, 69
Tempo di esecuzione, 69
Specifica, 65
Problema di pianificazione del lavoro/evento ponderato, 303
Algoritmi falliti, 303
programmazione dinamica avida, 304
Problema di pianificazione degli eventi ponderati, 303
Esempio di ordinamento del lavoro fatto da lavoro, 25